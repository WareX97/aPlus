{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 9;}
{\s50\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext51 List Continue 0;}
{\s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext52 List Continue 1;}
{\s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext53 List Continue 2;}
{\s53\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext54 List Continue 3;}
{\s54\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext55 List Continue 4;}
{\s55\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext56 List Continue 5;}
{\s56\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext57 List Continue 6;}
{\s57\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext58 List Continue 7;}
{\s58\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 8;}
{\s59\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 9;}
{\s60\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext61 DescContinue 0;}
{\s61\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext62 DescContinue 1;}
{\s62\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext63 DescContinue 2;}
{\s63\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext64 DescContinue 3;}
{\s64\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext65 DescContinue 4;}
{\s65\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext66 DescContinue 5;}
{\s66\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext67 DescContinue 6;}
{\s67\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext68 DescContinue 7;}
{\s68\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 8;}
{\s69\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 9;}
{\s70\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext81 LatexTOC 0;}
{\s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext82 LatexTOC 1;}
{\s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext83 LatexTOC 2;}
{\s73\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext84 LatexTOC 3;}
{\s74\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext85 LatexTOC 4;}
{\s75\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext86 LatexTOC 5;}
{\s76\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext87 LatexTOC 6;}
{\s77\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext88 LatexTOC 7;}
{\s78\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 8;}
{\s79\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 9;}
{\s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext81 \sautoupd List Bullet 0;}
{\s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid \sbasedon0 \snext82 \sautoupd List Bullet 1;}
{\s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid \sbasedon0 \snext83 \sautoupd List Bullet 2;}
{\s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid \sbasedon0 \snext84 \sautoupd List Bullet 3;}
{\s84\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls5\adjustright \fs20\cgrid \sbasedon0 \snext85 \sautoupd List Bullet 4;}
{\s85\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls6\adjustright \fs20\cgrid \sbasedon0 \snext86 \sautoupd List Bullet 5;}
{\s86\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls7\adjustright \fs20\cgrid \sbasedon0 \snext87 \sautoupd List Bullet 6;}
{\s87\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls8\adjustright \fs20\cgrid \sbasedon0 \snext88 \sautoupd List Bullet 7;}
{\s88\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls9\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 8;}
{\s89\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls10\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 9;}
{\s90\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext91 \sautoupd List Enum 0;}
{\s91\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext92 \sautoupd List Enum 1;}
{\s92\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext93 \sautoupd List Enum 2;}
{\s93\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext94 \sautoupd List Enum 3;}
{\s94\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext95 \sautoupd List Enum 4;}
{\s95\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s96\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s97\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext98 \sautoupd List Enum 7;}
{\s98\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 8;}
{\s99\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 9;}
}
{\comment begin body}
{\info 
{\title {\comment aPlus  {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
0.1 \par
}}aPlus}
{\comment Generated byDoxgyen. }
{\creatim \yr2014\mo11\dy9\hr20\min21\sec41}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt TITLE}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Version 0.1\par{\field\fldedit {\*\fldinst CREATEDATE \\*MERGEFORMAT}{\fldrslt CREATEDATE}}\par
\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Table of Contents\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
README{\tc \v README}\par \pard\plain 
{\bkmkstart AAAAAAACPZ}
{\bkmkend AAAAAAACPZ}
\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid }

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
C Posix library{\tc \v C Posix library}\par \pard\plain 
{\bkmkstart AAAAAAACQA}
{\bkmkend AAAAAAACQA}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The C POSIX library is a specification of a C standard library for POSIX systems. It was developed at the same time as the ANSI C standard. Some effort was made to make POSIX compatible with standard C; POSIX includes additional functions to those introduced in standard C.\par
{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {\tc\tcl \v 4}Required function\par}
{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Read directory entries\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Get groups;\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Schedule Yield.\par}
``` struct dirent* __os_readdir(DIR* d); int __os_getgroups(int length, gid_t* list); void __os_yield(void);\par
See "/config.h". ``` \par
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Posix Thread library{\tc \v Posix Thread library}\par \pard\plain 
{\bkmkstart AAAAAAACQB}
{\bkmkend AAAAAAACQB}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
POSIX Threads, usually referred to as Pthreads, is a POSIX standard for threads. The standard, POSIX.1c, Threads extensions (IEEE Std 1003.1c-1995), defines an API for creating and manipulating threads.\par
{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {\tc\tcl \v 4}Required function\par}
{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Create a Thread;\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Terminate a Thread;\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Get Thread ID.\par}
``` tid_t {\b __os_thread_create(void* entrypoint, void* params, int priority)}; int {\b __os_thread_kill(int killid, int exitcode)}; tid_t {\b __os_gettid()};\par
See "/platform/win32/hooks.h" as example. ```\par
{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {\tc\tcl \v 4}Current status\par}
{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
[X] Thread functions\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
[X] Thread attribute functions\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
[X] Scheduling functions\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
[X] Thread specific data functions\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
[X] Mutex attribute functions\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
[X] Mutex functions\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
[X] Condition variable attribute functions\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
[X] Condition variable functions\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
[X] Barrier attribute functions\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
[X] Barrier functions\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
[X] Read-write lock attribute functions\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
[X] Read-write lock functions\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
[X] Spinlock functions \par}
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Data Structure Index\par \pard\plain 
{\tc \v Data Structure Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Data Structures\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here are the data structures with brief descriptions:}
{
\par
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b __DIR} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABXY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b __pthread_key} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b __syscall} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b arp_cache_entry} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b arp_header} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b attribute} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b block} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b BootInfo_t} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b bufio} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b card} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b dirent} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b elf32_hdr} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ELF32 Header })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b elf32_shdr} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ELF32 Section Header })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b eth_header} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b fsys} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b gdt_entry} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b heap} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b inode} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ipv4_header} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACDQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ipv6_header} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACEB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b iso9660_dir} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACEK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b iso9660_pvd} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACEW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b iso9660_volume_descriptor} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACGE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b list} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACGJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b list_body} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACGN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b netif} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACGQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b netif_packet} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACHP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b netif_socket} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACHW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b pci_device} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACHX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b pipeinfo} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACIK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b pthread_attr} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACIO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b pthread_barrier} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACIV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b pthread_barrierattr} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACIY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b pthread_cond} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACJA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b pthread_condattr} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACJD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b pthread_context} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACJF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b pthread_mutex} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACJO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b pthread_mutexattr} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACJV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b pthread_once} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACJY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b pthread_rwlock} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACKB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b pthread_rwlockattr} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACKJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b pthread_spinlock} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACKL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b regs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACKO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b slirpcard} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACLH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b task} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACLO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b task_env} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACMM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b udp_header} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACMW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b vesaInfo_t} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACNB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b vesaModeInfo_t} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACNM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Index\par \pard\plain 
{\tc \v File Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
File List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all files with brief descriptions:}
{
\par
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b initrd/{\b test.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b bufio.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b debug.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAED \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b exec.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b main.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b panic.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b sched.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b spinlock.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABFG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/arch/{\b desc.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/arch/{\b pci.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/arch/{\b serial.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/arch/{\b syscall.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/arch/{\b task.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/fs/{\b devfs.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/fs/{\b fs.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/fs/{\b pipe.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/fs/{\b ramdev.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/fs/{\b vfs.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/fs/iso9660/{\b iso9660.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/fs/iso9660/{\b iso9660.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/fs/iso9660/{\b iso9660_finddir.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/fs/iso9660/{\b iso9660_mount.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/fs/iso9660/{\b iso9660_read.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/fs/iso9660/{\b iso9660_readdir.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/include/{\b aplus.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/include/{\b grub.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/include/aplus/{\b attribute.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/include/aplus/{\b bufio.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/include/aplus/{\b fs.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/include/aplus/{\b fsys.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/include/aplus/{\b list.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/include/aplus/{\b mm.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/include/aplus/{\b netif.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/include/aplus/{\b pci.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/include/aplus/{\b spinlock.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/include/aplus/{\b syscall.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAATM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/include/aplus/{\b task.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAATP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/include/aplus/net/{\b arp.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/include/aplus/net/{\b eth.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/include/aplus/net/{\b ipv4.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/include/aplus/net/{\b ipv6.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/include/aplus/net/{\b udp.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/mm/{\b heap.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/mm/{\b kheap.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/mm/{\b mm.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/mm/{\b paging.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/net/{\b arp.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/net/{\b eth.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/net/{\b ipv4.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/net/{\b ipv6.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/net/{\b netif.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/net/{\b udp.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/net/loopback/{\b loopback.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/net/rtl8139/{\b rtl8139.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/net/rtl8139/{\b rtl8139.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABBJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/net/slirp/{\b slirp.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABCW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/net/slirp/{\b slirp.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/syscall/{\b _exit.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABFM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/syscall/{\b chown.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABFP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/syscall/{\b clone.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABFT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/syscall/{\b close.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABFX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/syscall/{\b execve.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABGB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/syscall/{\b fcntl.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABGF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/syscall/{\b fork.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABGK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/syscall/{\b fstat.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABGN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/syscall/{\b getgroups.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABGR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/syscall/{\b getpid.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABGW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/syscall/{\b gettimeofday.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABGZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/syscall/{\b ioctl.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABHC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/syscall/{\b isatty.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABHG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/syscall/{\b kill.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABHJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/syscall/{\b link.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABHM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/syscall/{\b lseek.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABHP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/syscall/{\b mount.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABHT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/syscall/{\b open.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABHX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/syscall/{\b read.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABIE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/syscall/{\b readdir.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABIJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/syscall/{\b sbrk.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABIP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/syscall/{\b stat.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABIS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/syscall/{\b test.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/syscall/{\b time.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABIW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/syscall/{\b times.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABIY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/syscall/{\b umount.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABJC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/syscall/{\b unlink.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABJI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/syscall/{\b wait.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABJL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/syscall/{\b write.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABJP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/syscall/{\b yield.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABJU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b usr/src/libcrt0/src/{\b crt0.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABJX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b usr/src/libcrt0/src/{\b syscalls.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABKG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b usr/src/libcrt0/test/{\b main.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b usr/src/libposix/include/sys/{\b dirent.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABKO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b usr/src/libposix/src/{\b _execve.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b usr/src/libposix/src/{\b alarm.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b usr/src/libposix/src/{\b alphasort.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b usr/src/libposix/src/{\b closedir.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b usr/src/libposix/src/{\b config.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b usr/src/libposix/src/{\b dup2.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b usr/src/libposix/src/{\b environ.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b usr/src/libposix/src/{\b errno.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b usr/src/libposix/src/{\b execl.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b usr/src/libposix/src/{\b execle.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b usr/src/libposix/src/{\b execlp.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b usr/src/libposix/src/{\b execv.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b usr/src/libposix/src/{\b execvp.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b usr/src/libposix/src/{\b getcwd.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b usr/src/libposix/src/{\b gid.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b usr/src/libposix/src/{\b lstat.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b usr/src/libposix/src/{\b nanosleep.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b usr/src/libposix/src/{\b opendir.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b usr/src/libposix/src/{\b readdir.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABIN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b usr/src/libposix/src/{\b rewinddir.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b usr/src/libposix/src/{\b scandir.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b usr/src/libposix/src/{\b sched.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b usr/src/libposix/src/{\b seekdir.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b usr/src/libposix/src/{\b sleep.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABND \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b usr/src/libposix/src/{\b telldir.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b usr/src/libposix/src/{\b uid.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b usr/src/libposix/src/{\b usleep.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b usr/src/libpthread/include/{\b pthread.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b usr/src/libpthread/src/{\b pthread_attr.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b usr/src/libpthread/src/{\b pthread_barrier.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b usr/src/libpthread/src/{\b pthread_barrierattr.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b usr/src/libpthread/src/{\b pthread_cancel.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b usr/src/libpthread/src/{\b pthread_cond.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABUA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b usr/src/libpthread/src/{\b pthread_condattr.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABUI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b usr/src/libpthread/src/{\b pthread_create.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABUN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b usr/src/libpthread/src/{\b pthread_detach.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABUT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b usr/src/libpthread/src/{\b pthread_equal.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABUX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b usr/src/libpthread/src/{\b pthread_exit.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABUZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b usr/src/libpthread/src/{\b pthread_internal.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABVB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b usr/src/libpthread/src/{\b pthread_join.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABVL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b usr/src/libpthread/src/{\b pthread_key.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABVN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b usr/src/libpthread/src/{\b pthread_mutex.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABVT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b usr/src/libpthread/src/{\b pthread_mutexattr.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABWB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b usr/src/libpthread/src/{\b pthread_once.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABWI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b usr/src/libpthread/src/{\b pthread_queue.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABWK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b usr/src/libpthread/src/{\b pthread_rwlock.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABWP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b usr/src/libpthread/src/{\b pthread_rwlockattr.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABWZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b usr/src/libpthread/src/{\b pthread_sched.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABXE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b usr/src/libpthread/src/{\b pthread_self.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABXL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b usr/src/libpthread/src/{\b pthread_spin.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABXO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b usr/src/libpthread/src/platform/posix/{\b hooks.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b usr/src/libpthread/src/platform/win32/{\b hooks.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b usr/src/libpthread/test/{\b main.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b usr/src/libssp/src/{\b chkfail.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABXU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Data Structure Documentation{\tc \v Data Structure Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
__DIR Struct Reference\par \pard\plain 
{\tc\tcl2 \v __DIR}
{\xe \v __DIR}
{\bkmkstart AAAAAAABXY}
{\bkmkend AAAAAAABXY}
\par
{
{\f2 #include <dirent.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b fd}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b position}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 29 of file dirent.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v fd\:__DIR}
{\xe \v __DIR\:fd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int __DIR::fd}}
\par
{\bkmkstart AAAAAAABXZ}
{\bkmkend AAAAAAABXZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 30 of file dirent.h.}\par
}
{\xe \v position\:__DIR}
{\xe \v __DIR\:position}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int __DIR::position}}
\par
{\bkmkstart AAAAAAABYA}
{\bkmkend AAAAAAABYA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 31 of file dirent.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
usr/src/libposix/include/sys/{\b dirent.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
__pthread_key Struct Reference\par \pard\plain 
{\tc\tcl2 \v __pthread_key}
{\xe \v __pthread_key}
{\bkmkstart AAAAAAABYB}
{\bkmkend AAAAAAABYB}
\par
{
{\f2 #include <pthread_internal.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b used}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void(* {\b dtor} )(void *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b value}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 31 of file pthread_internal.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v dtor\:__pthread_key}
{\xe \v __pthread_key\:dtor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void(* __pthread_key::dtor)(void *)}}
\par
{\bkmkstart AAAAAAABYC}
{\bkmkend AAAAAAABYC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 33 of file pthread_internal.h.}\par
}
{\xe \v used\:__pthread_key}
{\xe \v __pthread_key\:used}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char __pthread_key::used}}
\par
{\bkmkstart AAAAAAABYD}
{\bkmkend AAAAAAABYD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 32 of file pthread_internal.h.}\par
}
{\xe \v value\:__pthread_key}
{\xe \v __pthread_key\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* __pthread_key::value}}
\par
{\bkmkstart AAAAAAABYE}
{\bkmkend AAAAAAABYE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 34 of file pthread_internal.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
usr/src/libpthread/src/{\b pthread_internal.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
__syscall Struct Reference\par \pard\plain 
{\tc\tcl2 \v __syscall}
{\xe \v __syscall}
{\bkmkstart AAAAAAABYF}
{\bkmkend AAAAAAABYF}
\par
{
{\f2 #include <syscall.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b handler}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b number}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 9 of file syscall.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v handler\:__syscall}
{\xe \v __syscall\:handler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* __syscall::handler}}
\par
{\bkmkstart AAAAAAABYG}
{\bkmkend AAAAAAABYG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 10 of file syscall.h.}\par
}
{\xe \v number\:__syscall}
{\xe \v __syscall\:number}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int __syscall::number}}
\par
{\bkmkstart AAAAAAABYH}
{\bkmkend AAAAAAABYH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 11 of file syscall.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
src/include/aplus/{\b syscall.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
arp_cache_entry Struct Reference\par \pard\plain 
{\tc\tcl2 \v arp_cache_entry}
{\xe \v arp_cache_entry}
{\bkmkstart AAAAAAABYI}
{\bkmkend AAAAAAABYI}
\par
{
{\f2 #include <arp.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ipv4_t} {\b ipv4}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b macaddr_t} {\b macaddr}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
time_t {\b ttl}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 39 of file arp.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v ipv4\:arp_cache_entry}
{\xe \v arp_cache_entry\:ipv4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ipv4_t} arp_cache_entry::ipv4}}
\par
{\bkmkstart AAAAAAABYJ}
{\bkmkend AAAAAAABYJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 40 of file arp.h.}\par
}
{\xe \v macaddr\:arp_cache_entry}
{\xe \v arp_cache_entry\:macaddr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b macaddr_t} arp_cache_entry::macaddr}}
\par
{\bkmkstart AAAAAAABYK}
{\bkmkend AAAAAAABYK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 41 of file arp.h.}\par
}
{\xe \v ttl\:arp_cache_entry}
{\xe \v arp_cache_entry\:ttl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
time_t arp_cache_entry::ttl}}
\par
{\bkmkstart AAAAAAABYL}
{\bkmkend AAAAAAABYL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 43 of file arp.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
src/include/aplus/net/{\b arp.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
arp_header Struct Reference\par \pard\plain 
{\tc\tcl2 \v arp_header}
{\xe \v arp_header}
{\bkmkstart AAAAAAABYM}
{\bkmkend AAAAAAABYM}
\par
{
{\f2 #include <arp.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b hwtype}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b prtype}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b hwlen}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b prlen}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b operation}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b macaddr_t} {\b sha}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ipv4_t} {\b spa}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b macaddr_t} {\b tha}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ipv4_t} {\b tpa}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 26 of file arp.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v hwlen\:arp_header}
{\xe \v arp_header\:hwlen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} arp_header::hwlen}}
\par
{\bkmkstart AAAAAAABYN}
{\bkmkend AAAAAAABYN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 29 of file arp.h.}\par
}
{\xe \v hwtype\:arp_header}
{\xe \v arp_header\:hwtype}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} arp_header::hwtype}}
\par
{\bkmkstart AAAAAAABYO}
{\bkmkend AAAAAAABYO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 27 of file arp.h.}\par
}
{\xe \v operation\:arp_header}
{\xe \v arp_header\:operation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} arp_header::operation}}
\par
{\bkmkstart AAAAAAABYP}
{\bkmkend AAAAAAABYP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 31 of file arp.h.}\par
}
{\xe \v prlen\:arp_header}
{\xe \v arp_header\:prlen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} arp_header::prlen}}
\par
{\bkmkstart AAAAAAABYQ}
{\bkmkend AAAAAAABYQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 30 of file arp.h.}\par
}
{\xe \v prtype\:arp_header}
{\xe \v arp_header\:prtype}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} arp_header::prtype}}
\par
{\bkmkstart AAAAAAABYR}
{\bkmkend AAAAAAABYR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 28 of file arp.h.}\par
}
{\xe \v sha\:arp_header}
{\xe \v arp_header\:sha}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b macaddr_t} arp_header::sha}}
\par
{\bkmkstart AAAAAAABYS}
{\bkmkend AAAAAAABYS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 32 of file arp.h.}\par
}
{\xe \v spa\:arp_header}
{\xe \v arp_header\:spa}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ipv4_t} arp_header::spa}}
\par
{\bkmkstart AAAAAAABYT}
{\bkmkend AAAAAAABYT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 33 of file arp.h.}\par
}
{\xe \v tha\:arp_header}
{\xe \v arp_header\:tha}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b macaddr_t} arp_header::tha}}
\par
{\bkmkstart AAAAAAABYU}
{\bkmkend AAAAAAABYU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 34 of file arp.h.}\par
}
{\xe \v tpa\:arp_header}
{\xe \v arp_header\:tpa}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ipv4_t} arp_header::tpa}}
\par
{\bkmkstart AAAAAAABYV}
{\bkmkend AAAAAAABYV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 35 of file arp.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
src/include/aplus/net/{\b arp.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
attribute Struct Reference\par \pard\plain 
{\tc\tcl2 \v attribute}
{\xe \v attribute}
{\bkmkstart AAAAAAABYW}
{\bkmkend AAAAAAABYW}
\par
{
{\f2 #include <attribute.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b name} [0x80]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b value}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 25 of file attribute.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v name\:attribute}
{\xe \v attribute\:name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char attribute::name[0x80]}}
\par
{\bkmkstart AAAAAAABYX}
{\bkmkend AAAAAAABYX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 26 of file attribute.h.}\par
}
{\xe \v value\:attribute}
{\xe \v attribute\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} attribute::value}}
\par
{\bkmkstart AAAAAAABYY}
{\bkmkend AAAAAAABYY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 27 of file attribute.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
src/include/aplus/{\b attribute.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
block Struct Reference\par \pard\plain 
{\tc\tcl2 \v block}
{\xe \v block}
{\bkmkstart AAAAAAABYZ}
{\bkmkend AAAAAAABYZ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b magic}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b size}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 44 of file mm.c.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v magic\:block}
{\xe \v block\:magic}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} block::magic}}
\par
{\bkmkstart AAAAAAABZA}
{\bkmkend AAAAAAABZA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 45 of file mm.c.}\par
}
{\xe \v size\:block}
{\xe \v block\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t block::size}}
\par
{\bkmkstart AAAAAAABZB}
{\bkmkend AAAAAAABZB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 46 of file mm.c.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
src/mm/{\b mm.c}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
BootInfo_t Struct Reference\par \pard\plain 
{\tc\tcl2 \v BootInfo_t}
{\xe \v BootInfo_t}
{\bkmkstart AAAAAAABZC}
{\bkmkend AAAAAAABZC}
\par
{
{\f2 #include <grub.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b flags}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b mem_lower}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b mem_upper}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b boot_device}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b cmdline}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b mods_count}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int ** {\b mods_addr}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b num}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b size}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b addr}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b shndx}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b mmap_length}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b mmap_addr}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b drives_length}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b drives_addr}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b config_table}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b boot_loader_name}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b apm_table}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b vbe_control_info}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
vesaModeInfo * {\b vbe_mode_info}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b vesaInfo} * {\b vbe_mode}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b vbe_interface_seg}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b vbe_interface_off}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b vbe_interface_len}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 64 of file grub.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v addr\:BootInfo_t}
{\xe \v BootInfo_t\:addr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int BootInfo_t::addr}}
\par
{\bkmkstart AAAAAAABZD}
{\bkmkend AAAAAAABZD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 74 of file grub.h.}\par
}
{\xe \v apm_table\:BootInfo_t}
{\xe \v BootInfo_t\:apm_table}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int BootInfo_t::apm_table}}
\par
{\bkmkstart AAAAAAABZE}
{\bkmkend AAAAAAABZE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 82 of file grub.h.}\par
}
{\xe \v boot_device\:BootInfo_t}
{\xe \v BootInfo_t\:boot_device}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int BootInfo_t::boot_device}}
\par
{\bkmkstart AAAAAAABZF}
{\bkmkend AAAAAAABZF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 68 of file grub.h.}\par
}
{\xe \v boot_loader_name\:BootInfo_t}
{\xe \v BootInfo_t\:boot_loader_name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int BootInfo_t::boot_loader_name}}
\par
{\bkmkstart AAAAAAABZG}
{\bkmkend AAAAAAABZG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 81 of file grub.h.}\par
}
{\xe \v cmdline\:BootInfo_t}
{\xe \v BootInfo_t\:cmdline}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int BootInfo_t::cmdline}}
\par
{\bkmkstart AAAAAAABZH}
{\bkmkend AAAAAAABZH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 69 of file grub.h.}\par
}
{\xe \v config_table\:BootInfo_t}
{\xe \v BootInfo_t\:config_table}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int BootInfo_t::config_table}}
\par
{\bkmkstart AAAAAAABZI}
{\bkmkend AAAAAAABZI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 80 of file grub.h.}\par
}
{\xe \v drives_addr\:BootInfo_t}
{\xe \v BootInfo_t\:drives_addr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int BootInfo_t::drives_addr}}
\par
{\bkmkstart AAAAAAABZJ}
{\bkmkend AAAAAAABZJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 79 of file grub.h.}\par
}
{\xe \v drives_length\:BootInfo_t}
{\xe \v BootInfo_t\:drives_length}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int BootInfo_t::drives_length}}
\par
{\bkmkstart AAAAAAABZK}
{\bkmkend AAAAAAABZK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 78 of file grub.h.}\par
}
{\xe \v flags\:BootInfo_t}
{\xe \v BootInfo_t\:flags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int BootInfo_t::flags}}
\par
{\bkmkstart AAAAAAABZL}
{\bkmkend AAAAAAABZL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 65 of file grub.h.}\par
}
{\xe \v mem_lower\:BootInfo_t}
{\xe \v BootInfo_t\:mem_lower}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int BootInfo_t::mem_lower}}
\par
{\bkmkstart AAAAAAABZM}
{\bkmkend AAAAAAABZM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 66 of file grub.h.}\par
}
{\xe \v mem_upper\:BootInfo_t}
{\xe \v BootInfo_t\:mem_upper}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int BootInfo_t::mem_upper}}
\par
{\bkmkstart AAAAAAABZN}
{\bkmkend AAAAAAABZN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 67 of file grub.h.}\par
}
{\xe \v mmap_addr\:BootInfo_t}
{\xe \v BootInfo_t\:mmap_addr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int BootInfo_t::mmap_addr}}
\par
{\bkmkstart AAAAAAABZO}
{\bkmkend AAAAAAABZO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 77 of file grub.h.}\par
}
{\xe \v mmap_length\:BootInfo_t}
{\xe \v BootInfo_t\:mmap_length}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int BootInfo_t::mmap_length}}
\par
{\bkmkstart AAAAAAABZP}
{\bkmkend AAAAAAABZP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 76 of file grub.h.}\par
}
{\xe \v mods_addr\:BootInfo_t}
{\xe \v BootInfo_t\:mods_addr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int** BootInfo_t::mods_addr}}
\par
{\bkmkstart AAAAAAABZQ}
{\bkmkend AAAAAAABZQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 71 of file grub.h.}\par
}
{\xe \v mods_count\:BootInfo_t}
{\xe \v BootInfo_t\:mods_count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int BootInfo_t::mods_count}}
\par
{\bkmkstart AAAAAAABZR}
{\bkmkend AAAAAAABZR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 70 of file grub.h.}\par
}
{\xe \v num\:BootInfo_t}
{\xe \v BootInfo_t\:num}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int BootInfo_t::num}}
\par
{\bkmkstart AAAAAAABZS}
{\bkmkend AAAAAAABZS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 72 of file grub.h.}\par
}
{\xe \v shndx\:BootInfo_t}
{\xe \v BootInfo_t\:shndx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int BootInfo_t::shndx}}
\par
{\bkmkstart AAAAAAABZT}
{\bkmkend AAAAAAABZT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 75 of file grub.h.}\par
}
{\xe \v size\:BootInfo_t}
{\xe \v BootInfo_t\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int BootInfo_t::size}}
\par
{\bkmkstart AAAAAAABZU}
{\bkmkend AAAAAAABZU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 73 of file grub.h.}\par
}
{\xe \v vbe_control_info\:BootInfo_t}
{\xe \v BootInfo_t\:vbe_control_info}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int BootInfo_t::vbe_control_info}}
\par
{\bkmkstart AAAAAAABZV}
{\bkmkend AAAAAAABZV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 83 of file grub.h.}\par
}
{\xe \v vbe_interface_len\:BootInfo_t}
{\xe \v BootInfo_t\:vbe_interface_len}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int BootInfo_t::vbe_interface_len}}
\par
{\bkmkstart AAAAAAABZW}
{\bkmkend AAAAAAABZW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 88 of file grub.h.}\par
}
{\xe \v vbe_interface_off\:BootInfo_t}
{\xe \v BootInfo_t\:vbe_interface_off}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int BootInfo_t::vbe_interface_off}}
\par
{\bkmkstart AAAAAAABZX}
{\bkmkend AAAAAAABZX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 87 of file grub.h.}\par
}
{\xe \v vbe_interface_seg\:BootInfo_t}
{\xe \v BootInfo_t\:vbe_interface_seg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int BootInfo_t::vbe_interface_seg}}
\par
{\bkmkstart AAAAAAABZY}
{\bkmkend AAAAAAABZY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 86 of file grub.h.}\par
}
{\xe \v vbe_mode\:BootInfo_t}
{\xe \v BootInfo_t\:vbe_mode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b vesaInfo}* BootInfo_t::vbe_mode}}
\par
{\bkmkstart AAAAAAABZZ}
{\bkmkend AAAAAAABZZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 85 of file grub.h.}\par
}
{\xe \v vbe_mode_info\:BootInfo_t}
{\xe \v BootInfo_t\:vbe_mode_info}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
vesaModeInfo* BootInfo_t::vbe_mode_info}}
\par
{\bkmkstart AAAAAAACAA}
{\bkmkend AAAAAAACAA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 84 of file grub.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
src/include/{\b grub.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
bufio Struct Reference\par \pard\plain 
{\tc\tcl2 \v bufio}
{\xe \v bufio}
{\bkmkstart AAAAAAACAB}
{\bkmkend AAAAAAACAB}
\par
{
{\f2 #include <bufio.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b raw}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b size}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
off_t {\b offset}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b type}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b spinlock_t} {\b lock}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b task_t} * {\b task}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 32 of file bufio.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v lock\:bufio}
{\xe \v bufio\:lock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b spinlock_t} bufio::lock}}
\par
{\bkmkstart AAAAAAACAC}
{\bkmkend AAAAAAACAC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 37 of file bufio.h.}\par
}
{\xe \v offset\:bufio}
{\xe \v bufio\:offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
off_t bufio::offset}}
\par
{\bkmkstart AAAAAAACAD}
{\bkmkend AAAAAAACAD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 35 of file bufio.h.}\par
}
{\xe \v raw\:bufio}
{\xe \v bufio\:raw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* bufio::raw}}
\par
{\bkmkstart AAAAAAACAE}
{\bkmkend AAAAAAACAE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 33 of file bufio.h.}\par
}
{\xe \v size\:bufio}
{\xe \v bufio\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t bufio::size}}
\par
{\bkmkstart AAAAAAACAF}
{\bkmkend AAAAAAACAF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 34 of file bufio.h.}\par
}
{\xe \v task\:bufio}
{\xe \v bufio\:task}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b task_t}* bufio::task}}
\par
{\bkmkstart AAAAAAACAG}
{\bkmkend AAAAAAACAG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 38 of file bufio.h.}\par
}
{\xe \v type\:bufio}
{\xe \v bufio\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} bufio::type}}
\par
{\bkmkstart AAAAAAACAH}
{\bkmkend AAAAAAACAH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 36 of file bufio.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
src/include/aplus/{\b bufio.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
card Struct Reference\par \pard\plain 
{\tc\tcl2 \v card}
{\xe \v card}
{\bkmkstart AAAAAAACAI}
{\bkmkend AAAAAAACAI}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b pci_device_t} * {\b device}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b netif_t} * {\b netif}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b macaddr} [6]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b rxBuffer}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b rxBufferOffset}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b txBuffer}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b txBufferUsed}:1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b curBuffer}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b magic}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 18 of file rtl8139.c.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v curBuffer\:card}
{\xe \v card\:curBuffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char card::curBuffer}}
\par
{\bkmkstart AAAAAAACAJ}
{\bkmkend AAAAAAACAJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 29 of file rtl8139.c.}\par
}
{\xe \v device\:card}
{\xe \v card\:device}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b pci_device_t}* card::device}}
\par
{\bkmkstart AAAAAAACAK}
{\bkmkend AAAAAAACAK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 19 of file rtl8139.c.}\par
}
{\xe \v macaddr\:card}
{\xe \v card\:macaddr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char card::macaddr[6]}}
\par
{\bkmkstart AAAAAAACAL}
{\bkmkend AAAAAAACAL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 22 of file rtl8139.c.}\par
}
{\xe \v magic\:card}
{\xe \v card\:magic}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int card::magic}}
\par
{\bkmkstart AAAAAAACAM}
{\bkmkend AAAAAAACAM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 31 of file rtl8139.c.}\par
}
{\xe \v netif\:card}
{\xe \v card\:netif}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b netif_t}* card::netif}}
\par
{\bkmkstart AAAAAAACAN}
{\bkmkend AAAAAAACAN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 20 of file rtl8139.c.}\par
}
{\xe \v rxBuffer\:card}
{\xe \v card\:rxBuffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* card::rxBuffer}}
\par
{\bkmkstart AAAAAAACAO}
{\bkmkend AAAAAAACAO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 24 of file rtl8139.c.}\par
}
{\xe \v rxBufferOffset\:card}
{\xe \v card\:rxBufferOffset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int card::rxBufferOffset}}
\par
{\bkmkstart AAAAAAACAP}
{\bkmkend AAAAAAACAP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 25 of file rtl8139.c.}\par
}
{\xe \v txBuffer\:card}
{\xe \v card\:txBuffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* card::txBuffer}}
\par
{\bkmkstart AAAAAAACAQ}
{\bkmkend AAAAAAACAQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 27 of file rtl8139.c.}\par
}
{\xe \v txBufferUsed\:card}
{\xe \v card\:txBufferUsed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char card::txBufferUsed}}
\par
{\bkmkstart AAAAAAACAR}
{\bkmkend AAAAAAACAR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 28 of file rtl8139.c.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
src/net/rtl8139/{\b rtl8139.c}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
dirent Struct Reference\par \pard\plain 
{\tc\tcl2 \v dirent}
{\xe \v dirent}
{\bkmkstart AAAAAAACAS}
{\bkmkend AAAAAAACAS}
\par
{
{\f2 #include <dirent.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b d_ino}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b d_name} []\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 35 of file dirent.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v d_ino\:dirent}
{\xe \v dirent\:d_ino}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int dirent::d_ino}}
\par
{\bkmkstart AAAAAAACAT}
{\bkmkend AAAAAAACAT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 36 of file dirent.h.}\par
}
{\xe \v d_name\:dirent}
{\xe \v dirent\:d_name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char dirent::d_name[]}}
\par
{\bkmkstart AAAAAAACAU}
{\bkmkend AAAAAAACAU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 37 of file dirent.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
usr/src/libposix/include/sys/{\b dirent.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
elf32_hdr Struct Reference\par \pard\plain 
{\tc\tcl2 \v elf32_hdr}
{\xe \v elf32_hdr}
{\bkmkstart AAAAAAACAV}
{\bkmkend AAAAAAACAV}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ELF32 Header. }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b e_ident} [{\b EI_NIDENT}]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Elf32_Half} {\b e_type}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Elf32_Half} {\b e_machine}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Elf32_Word} {\b e_version}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Elf32_Addr} {\b e_entry}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Elf32_Off} {\b e_phoff}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Elf32_Off} {\b e_shoff}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Elf32_Word} {\b e_flags}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Elf32_Half} {\b e_ehsize}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Elf32_Half} {\b e_phentsize}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Elf32_Half} {\b e_phnum}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Elf32_Half} {\b e_shentsize}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Elf32_Half} {\b e_shnum}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Elf32_Half} {\b e_shstrndx}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ELF32 Header. \par
}{
Definition at line 64 of file exec.c.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v e_ehsize\:elf32_hdr}
{\xe \v elf32_hdr\:e_ehsize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Elf32_Half} elf32_hdr::e_ehsize}}
\par
{\bkmkstart AAAAAAACAW}
{\bkmkend AAAAAAACAW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 73 of file exec.c.}\par
}
{\xe \v e_entry\:elf32_hdr}
{\xe \v elf32_hdr\:e_entry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Elf32_Addr} elf32_hdr::e_entry}}
\par
{\bkmkstart AAAAAAACAX}
{\bkmkend AAAAAAACAX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 69 of file exec.c.}\par
}
{\xe \v e_flags\:elf32_hdr}
{\xe \v elf32_hdr\:e_flags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Elf32_Word} elf32_hdr::e_flags}}
\par
{\bkmkstart AAAAAAACAY}
{\bkmkend AAAAAAACAY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 72 of file exec.c.}\par
}
{\xe \v e_ident\:elf32_hdr}
{\xe \v elf32_hdr\:e_ident}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} elf32_hdr::e_ident[{\b EI_NIDENT}]}}
\par
{\bkmkstart AAAAAAACAZ}
{\bkmkend AAAAAAACAZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 65 of file exec.c.}\par
}
{\xe \v e_machine\:elf32_hdr}
{\xe \v elf32_hdr\:e_machine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Elf32_Half} elf32_hdr::e_machine}}
\par
{\bkmkstart AAAAAAACBA}
{\bkmkend AAAAAAACBA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 67 of file exec.c.}\par
}
{\xe \v e_phentsize\:elf32_hdr}
{\xe \v elf32_hdr\:e_phentsize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Elf32_Half} elf32_hdr::e_phentsize}}
\par
{\bkmkstart AAAAAAACBB}
{\bkmkend AAAAAAACBB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 74 of file exec.c.}\par
}
{\xe \v e_phnum\:elf32_hdr}
{\xe \v elf32_hdr\:e_phnum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Elf32_Half} elf32_hdr::e_phnum}}
\par
{\bkmkstart AAAAAAACBC}
{\bkmkend AAAAAAACBC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 75 of file exec.c.}\par
}
{\xe \v e_phoff\:elf32_hdr}
{\xe \v elf32_hdr\:e_phoff}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Elf32_Off} elf32_hdr::e_phoff}}
\par
{\bkmkstart AAAAAAACBD}
{\bkmkend AAAAAAACBD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 70 of file exec.c.}\par
}
{\xe \v e_shentsize\:elf32_hdr}
{\xe \v elf32_hdr\:e_shentsize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Elf32_Half} elf32_hdr::e_shentsize}}
\par
{\bkmkstart AAAAAAACBE}
{\bkmkend AAAAAAACBE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 76 of file exec.c.}\par
}
{\xe \v e_shnum\:elf32_hdr}
{\xe \v elf32_hdr\:e_shnum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Elf32_Half} elf32_hdr::e_shnum}}
\par
{\bkmkstart AAAAAAACBF}
{\bkmkend AAAAAAACBF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 77 of file exec.c.}\par
}
{\xe \v e_shoff\:elf32_hdr}
{\xe \v elf32_hdr\:e_shoff}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Elf32_Off} elf32_hdr::e_shoff}}
\par
{\bkmkstart AAAAAAACBG}
{\bkmkend AAAAAAACBG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 71 of file exec.c.}\par
}
{\xe \v e_shstrndx\:elf32_hdr}
{\xe \v elf32_hdr\:e_shstrndx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Elf32_Half} elf32_hdr::e_shstrndx}}
\par
{\bkmkstart AAAAAAACBH}
{\bkmkend AAAAAAACBH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 78 of file exec.c.}\par
}
{\xe \v e_type\:elf32_hdr}
{\xe \v elf32_hdr\:e_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Elf32_Half} elf32_hdr::e_type}}
\par
{\bkmkstart AAAAAAACBI}
{\bkmkend AAAAAAACBI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 66 of file exec.c.}\par
}
{\xe \v e_version\:elf32_hdr}
{\xe \v elf32_hdr\:e_version}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Elf32_Word} elf32_hdr::e_version}}
\par
{\bkmkstart AAAAAAACBJ}
{\bkmkend AAAAAAACBJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 68 of file exec.c.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
src/{\b exec.c}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
elf32_shdr Struct Reference\par \pard\plain 
{\tc\tcl2 \v elf32_shdr}
{\xe \v elf32_shdr}
{\bkmkstart AAAAAAACBK}
{\bkmkend AAAAAAACBK}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ELF32 Section Header. }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Elf32_Word} {\b sh_name}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Elf32_Word} {\b sh_type}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Elf32_Word} {\b sh_flags}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Elf32_Addr} {\b sh_addr}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Elf32_Off} {\b sh_offset}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Elf32_Word} {\b sh_size}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Elf32_Word} {\b sh_link}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Elf32_Word} {\b sh_info}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Elf32_Word} {\b sh_addralign}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Elf32_Word} {\b sh_entsize}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ELF32 Section Header. \par
}{
Definition at line 84 of file exec.c.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v sh_addr\:elf32_shdr}
{\xe \v elf32_shdr\:sh_addr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Elf32_Addr} elf32_shdr::sh_addr}}
\par
{\bkmkstart AAAAAAACBL}
{\bkmkend AAAAAAACBL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 88 of file exec.c.}\par
}
{\xe \v sh_addralign\:elf32_shdr}
{\xe \v elf32_shdr\:sh_addralign}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Elf32_Word} elf32_shdr::sh_addralign}}
\par
{\bkmkstart AAAAAAACBM}
{\bkmkend AAAAAAACBM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 93 of file exec.c.}\par
}
{\xe \v sh_entsize\:elf32_shdr}
{\xe \v elf32_shdr\:sh_entsize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Elf32_Word} elf32_shdr::sh_entsize}}
\par
{\bkmkstart AAAAAAACBN}
{\bkmkend AAAAAAACBN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 94 of file exec.c.}\par
}
{\xe \v sh_flags\:elf32_shdr}
{\xe \v elf32_shdr\:sh_flags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Elf32_Word} elf32_shdr::sh_flags}}
\par
{\bkmkstart AAAAAAACBO}
{\bkmkend AAAAAAACBO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 87 of file exec.c.}\par
}
{\xe \v sh_info\:elf32_shdr}
{\xe \v elf32_shdr\:sh_info}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Elf32_Word} elf32_shdr::sh_info}}
\par
{\bkmkstart AAAAAAACBP}
{\bkmkend AAAAAAACBP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 92 of file exec.c.}\par
}
{\xe \v sh_link\:elf32_shdr}
{\xe \v elf32_shdr\:sh_link}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Elf32_Word} elf32_shdr::sh_link}}
\par
{\bkmkstart AAAAAAACBQ}
{\bkmkend AAAAAAACBQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 91 of file exec.c.}\par
}
{\xe \v sh_name\:elf32_shdr}
{\xe \v elf32_shdr\:sh_name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Elf32_Word} elf32_shdr::sh_name}}
\par
{\bkmkstart AAAAAAACBR}
{\bkmkend AAAAAAACBR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 85 of file exec.c.}\par
}
{\xe \v sh_offset\:elf32_shdr}
{\xe \v elf32_shdr\:sh_offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Elf32_Off} elf32_shdr::sh_offset}}
\par
{\bkmkstart AAAAAAACBS}
{\bkmkend AAAAAAACBS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 89 of file exec.c.}\par
}
{\xe \v sh_size\:elf32_shdr}
{\xe \v elf32_shdr\:sh_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Elf32_Word} elf32_shdr::sh_size}}
\par
{\bkmkstart AAAAAAACBT}
{\bkmkend AAAAAAACBT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 90 of file exec.c.}\par
}
{\xe \v sh_type\:elf32_shdr}
{\xe \v elf32_shdr\:sh_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Elf32_Word} elf32_shdr::sh_type}}
\par
{\bkmkstart AAAAAAACBU}
{\bkmkend AAAAAAACBU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 86 of file exec.c.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
src/{\b exec.c}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
eth_header Struct Reference\par \pard\plain 
{\tc\tcl2 \v eth_header}
{\xe \v eth_header}
{\bkmkstart AAAAAAACBV}
{\bkmkend AAAAAAACBV}
\par
{
{\f2 #include <eth.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b macaddr_t} {\b dest}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b macaddr_t} {\b source}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b type}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 20 of file eth.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v dest\:eth_header}
{\xe \v eth_header\:dest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b macaddr_t} eth_header::dest}}
\par
{\bkmkstart AAAAAAACBW}
{\bkmkend AAAAAAACBW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 21 of file eth.h.}\par
}
{\xe \v source\:eth_header}
{\xe \v eth_header\:source}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b macaddr_t} eth_header::source}}
\par
{\bkmkstart AAAAAAACBX}
{\bkmkend AAAAAAACBX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 22 of file eth.h.}\par
}
{\xe \v type\:eth_header}
{\xe \v eth_header\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} eth_header::type}}
\par
{\bkmkstart AAAAAAACBY}
{\bkmkend AAAAAAACBY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 23 of file eth.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
src/include/aplus/net/{\b eth.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
fsys Struct Reference\par \pard\plain 
{\tc\tcl2 \v fsys}
{\xe \v fsys}
{\bkmkstart AAAAAAACBZ}
{\bkmkend AAAAAAACBZ}
\par
{
{\f2 #include <fsys.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b name} [255]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int(* {\b mount} )(struct {\b inode} *idev, struct {\b inode} *idir, int {\b flags})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 7 of file fsys.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v mount\:fsys}
{\xe \v fsys\:mount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int(* fsys::mount)(struct {\b inode} *idev, struct {\b inode} *idir, int {\b flags})}}
\par
{\bkmkstart AAAAAAACCA}
{\bkmkend AAAAAAACCA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9 of file fsys.h.}\par
}
{\xe \v name\:fsys}
{\xe \v fsys\:name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char fsys::name[255]}}
\par
{\bkmkstart AAAAAAACCB}
{\bkmkend AAAAAAACCB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 8 of file fsys.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
src/include/aplus/{\b fsys.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gdt_entry Struct Reference\par \pard\plain 
{\tc\tcl2 \v gdt_entry}
{\xe \v gdt_entry}
{\bkmkstart AAAAAAACCC}
{\bkmkend AAAAAAACCC}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b limit_l}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b base_l}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b base_m}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b access}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b granularity}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b base_h}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 41 of file desc.c.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v access\:gdt_entry}
{\xe \v gdt_entry\:access}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} gdt_entry::access}}
\par
{\bkmkstart AAAAAAACCD}
{\bkmkend AAAAAAACCD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 43 of file desc.c.}\par
}
{\xe \v base_h\:gdt_entry}
{\xe \v gdt_entry\:base_h}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} gdt_entry::base_h}}
\par
{\bkmkstart AAAAAAACCE}
{\bkmkend AAAAAAACCE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 43 of file desc.c.}\par
}
{\xe \v base_l\:gdt_entry}
{\xe \v gdt_entry\:base_l}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} gdt_entry::base_l}}
\par
{\bkmkstart AAAAAAACCF}
{\bkmkend AAAAAAACCF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 42 of file desc.c.}\par
}
{\xe \v base_m\:gdt_entry}
{\xe \v gdt_entry\:base_m}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} gdt_entry::base_m}}
\par
{\bkmkstart AAAAAAACCG}
{\bkmkend AAAAAAACCG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 43 of file desc.c.}\par
}
{\xe \v granularity\:gdt_entry}
{\xe \v gdt_entry\:granularity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} gdt_entry::granularity}}
\par
{\bkmkstart AAAAAAACCH}
{\bkmkend AAAAAAACCH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 43 of file desc.c.}\par
}
{\xe \v limit_l\:gdt_entry}
{\xe \v gdt_entry\:limit_l}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} gdt_entry::limit_l}}
\par
{\bkmkstart AAAAAAACCI}
{\bkmkend AAAAAAACCI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 42 of file desc.c.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
src/arch/{\b desc.c}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
heap Struct Reference\par \pard\plain 
{\tc\tcl2 \v heap}
{\xe \v heap}
{\bkmkstart AAAAAAACCJ}
{\bkmkend AAAAAAACCJ}
\par
{
{\f2 #include <mm.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} * {\b bitmap}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b size}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b used}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void *(* {\b alloc} )(struct {\b heap} *, size_t)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void(* {\b free} )(struct {\b heap} *, void *, size_t)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 62 of file mm.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v alloc\:heap}
{\xe \v heap\:alloc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void*(* heap::alloc)(struct {\b heap} *, size_t)}}
\par
{\bkmkstart AAAAAAACCK}
{\bkmkend AAAAAAACCK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 67 of file mm.h.}\par
}
{\xe \v bitmap\:heap}
{\xe \v heap\:bitmap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t}* heap::bitmap}}
\par
{\bkmkstart AAAAAAACCL}
{\bkmkend AAAAAAACCL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 63 of file mm.h.}\par
}
{\xe \v free\:heap}
{\xe \v heap\:free}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void(* heap::free)(struct {\b heap} *, void *, size_t)}}
\par
{\bkmkstart AAAAAAACCM}
{\bkmkend AAAAAAACCM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 68 of file mm.h.}\par
}
{\xe \v size\:heap}
{\xe \v heap\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} heap::size}}
\par
{\bkmkstart AAAAAAACCN}
{\bkmkend AAAAAAACCN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 64 of file mm.h.}\par
}
{\xe \v used\:heap}
{\xe \v heap\:used}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} heap::used}}
\par
{\bkmkstart AAAAAAACCO}
{\bkmkend AAAAAAACCO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 65 of file mm.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
src/include/aplus/{\b mm.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
inode Struct Reference\par \pard\plain 
{\tc\tcl2 \v inode}
{\xe \v inode}
{\bkmkstart AAAAAAACCP}
{\bkmkend AAAAAAACCP}
\par
{
{\f2 #include <fs.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b name} [255]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
dev_t {\b dev}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ino_t {\b ino}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
mode_t {\b mode}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
nlink_t {\b nlink}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uid_t {\b uid}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gid_t {\b gid}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
dev_t {\b rdev}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
off_t {\b size}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
off_t {\b position}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
time_t {\b atime}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
time_t {\b mtime}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
time_t {\b ctime}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b userdata}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int(* {\b read} )(struct {\b inode} *{\b inode}, char *ptr, int len)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int(* {\b write} )(struct {\b inode} *{\b inode}, char *ptr, int len)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b dirent} *(* {\b readdir} )(struct {\b inode} *{\b inode}, int index)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b inode} *(* {\b finddir} )(struct {\b inode} *{\b inode}, char *{\b name})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b inode} *(* {\b creat} )(struct {\b inode} *{\b inode}, char *{\b name}, mode_t {\b mode})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int(* {\b rename} )(struct {\b inode} *{\b inode}, char *oldname, char *newname)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int(* {\b unlink} )(struct {\b inode} *{\b inode}, char *{\b name})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int(* {\b chown} )(struct {\b inode} *{\b inode}, uid_t owner, gid_t group)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void(* {\b flush} )(struct {\b inode} *{\b inode})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int(* {\b ioctl} )(struct {\b inode} *{\b inode}, int req, void *buf)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b inode} * {\b parent}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b inode} * {\b link}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 37 of file fs.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v atime\:inode}
{\xe \v inode\:atime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
time_t inode::atime}}
\par
{\bkmkstart AAAAAAACCQ}
{\bkmkend AAAAAAACCQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 50 of file fs.h.}\par
}
{\xe \v chown\:inode}
{\xe \v inode\:chown}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int(* inode::chown)(struct {\b inode} *{\b inode}, uid_t owner, gid_t group)}}
\par
{\bkmkstart AAAAAAACCR}
{\bkmkend AAAAAAACCR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 65 of file fs.h.}\par
}
{\xe \v creat\:inode}
{\xe \v inode\:creat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b inode}*(* inode::creat)(struct {\b inode} *{\b inode}, char *{\b name}, mode_t {\b mode})}}
\par
{\bkmkstart AAAAAAACCS}
{\bkmkend AAAAAAACCS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 61 of file fs.h.}\par
}
{\xe \v ctime\:inode}
{\xe \v inode\:ctime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
time_t inode::ctime}}
\par
{\bkmkstart AAAAAAACCT}
{\bkmkend AAAAAAACCT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 52 of file fs.h.}\par
}
{\xe \v dev\:inode}
{\xe \v inode\:dev}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
dev_t inode::dev}}
\par
{\bkmkstart AAAAAAACCU}
{\bkmkend AAAAAAACCU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 40 of file fs.h.}\par
}
{\xe \v finddir\:inode}
{\xe \v inode\:finddir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b inode}*(* inode::finddir)(struct {\b inode} *{\b inode}, char *{\b name})}}
\par
{\bkmkstart AAAAAAACCV}
{\bkmkend AAAAAAACCV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 60 of file fs.h.}\par
}
{\xe \v flush\:inode}
{\xe \v inode\:flush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void(* inode::flush)(struct {\b inode} *{\b inode})}}
\par
{\bkmkstart AAAAAAACCW}
{\bkmkend AAAAAAACCW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 66 of file fs.h.}\par
}
{\xe \v gid\:inode}
{\xe \v inode\:gid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
gid_t inode::gid}}
\par
{\bkmkstart AAAAAAACCX}
{\bkmkend AAAAAAACCX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 45 of file fs.h.}\par
}
{\xe \v ino\:inode}
{\xe \v inode\:ino}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ino_t inode::ino}}
\par
{\bkmkstart AAAAAAACCY}
{\bkmkend AAAAAAACCY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 41 of file fs.h.}\par
}
{\xe \v ioctl\:inode}
{\xe \v inode\:ioctl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int(* inode::ioctl)(struct {\b inode} *{\b inode}, int req, void *buf)}}
\par
{\bkmkstart AAAAAAACCZ}
{\bkmkend AAAAAAACCZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 68 of file fs.h.}\par
}
{\xe \v link\:inode}
{\xe \v inode\:link}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b inode}* inode::link}}
\par
{\bkmkstart AAAAAAACDA}
{\bkmkend AAAAAAACDA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 72 of file fs.h.}\par
}
{\xe \v mode\:inode}
{\xe \v inode\:mode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
mode_t inode::mode}}
\par
{\bkmkstart AAAAAAACDB}
{\bkmkend AAAAAAACDB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 42 of file fs.h.}\par
}
{\xe \v mtime\:inode}
{\xe \v inode\:mtime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
time_t inode::mtime}}
\par
{\bkmkstart AAAAAAACDC}
{\bkmkend AAAAAAACDC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 51 of file fs.h.}\par
}
{\xe \v name\:inode}
{\xe \v inode\:name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char inode::name[255]}}
\par
{\bkmkstart AAAAAAACDD}
{\bkmkend AAAAAAACDD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 38 of file fs.h.}\par
}
{\xe \v nlink\:inode}
{\xe \v inode\:nlink}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
nlink_t inode::nlink}}
\par
{\bkmkstart AAAAAAACDE}
{\bkmkend AAAAAAACDE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 43 of file fs.h.}\par
}
{\xe \v parent\:inode}
{\xe \v inode\:parent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b inode}* inode::parent}}
\par
{\bkmkstart AAAAAAACDF}
{\bkmkend AAAAAAACDF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 71 of file fs.h.}\par
}
{\xe \v position\:inode}
{\xe \v inode\:position}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
off_t inode::position}}
\par
{\bkmkstart AAAAAAACDG}
{\bkmkend AAAAAAACDG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 48 of file fs.h.}\par
}
{\xe \v rdev\:inode}
{\xe \v inode\:rdev}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
dev_t inode::rdev}}
\par
{\bkmkstart AAAAAAACDH}
{\bkmkend AAAAAAACDH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 46 of file fs.h.}\par
}
{\xe \v read\:inode}
{\xe \v inode\:read}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int(* inode::read)(struct {\b inode} *{\b inode}, char *ptr, int len)}}
\par
{\bkmkstart AAAAAAACDI}
{\bkmkend AAAAAAACDI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 56 of file fs.h.}\par
}
{\xe \v readdir\:inode}
{\xe \v inode\:readdir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b dirent}*(* inode::readdir)(struct {\b inode} *{\b inode}, int index)}}
\par
{\bkmkstart AAAAAAACDJ}
{\bkmkend AAAAAAACDJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 59 of file fs.h.}\par
}
{\xe \v rename\:inode}
{\xe \v inode\:rename}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int(* inode::rename)(struct {\b inode} *{\b inode}, char *oldname, char *newname)}}
\par
{\bkmkstart AAAAAAACDK}
{\bkmkend AAAAAAACDK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 63 of file fs.h.}\par
}
{\xe \v size\:inode}
{\xe \v inode\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
off_t inode::size}}
\par
{\bkmkstart AAAAAAACDL}
{\bkmkend AAAAAAACDL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 47 of file fs.h.}\par
}
{\xe \v uid\:inode}
{\xe \v inode\:uid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uid_t inode::uid}}
\par
{\bkmkstart AAAAAAACDM}
{\bkmkend AAAAAAACDM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 44 of file fs.h.}\par
}
{\xe \v unlink\:inode}
{\xe \v inode\:unlink}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int(* inode::unlink)(struct {\b inode} *{\b inode}, char *{\b name})}}
\par
{\bkmkstart AAAAAAACDN}
{\bkmkend AAAAAAACDN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 64 of file fs.h.}\par
}
{\xe \v userdata\:inode}
{\xe \v inode\:userdata}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* inode::userdata}}
\par
{\bkmkstart AAAAAAACDO}
{\bkmkend AAAAAAACDO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 54 of file fs.h.}\par
}
{\xe \v write\:inode}
{\xe \v inode\:write}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int(* inode::write)(struct {\b inode} *{\b inode}, char *ptr, int len)}}
\par
{\bkmkstart AAAAAAACDP}
{\bkmkend AAAAAAACDP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 57 of file fs.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
src/include/aplus/{\b fs.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ipv4_header Struct Reference\par \pard\plain 
{\tc\tcl2 \v ipv4_header}
{\xe \v ipv4_header}
{\bkmkstart AAAAAAACDQ}
{\bkmkend AAAAAAACDQ}
\par
{
{\f2 #include <ipv4.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b info}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b tos}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b length}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b id}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b offset}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b ttl}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b protocol}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b checksum}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ipv4_t} {\b source}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ipv4_t} {\b dest}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 30 of file ipv4.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v checksum\:ipv4_header}
{\xe \v ipv4_header\:checksum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} ipv4_header::checksum}}
\par
{\bkmkstart AAAAAAACDR}
{\bkmkend AAAAAAACDR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 38 of file ipv4.h.}\par
}
{\xe \v dest\:ipv4_header}
{\xe \v ipv4_header\:dest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ipv4_t} ipv4_header::dest}}
\par
{\bkmkstart AAAAAAACDS}
{\bkmkend AAAAAAACDS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 41 of file ipv4.h.}\par
}
{\xe \v id\:ipv4_header}
{\xe \v ipv4_header\:id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} ipv4_header::id}}
\par
{\bkmkstart AAAAAAACDT}
{\bkmkend AAAAAAACDT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 34 of file ipv4.h.}\par
}
{\xe \v info\:ipv4_header}
{\xe \v ipv4_header\:info}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} ipv4_header::info}}
\par
{\bkmkstart AAAAAAACDU}
{\bkmkend AAAAAAACDU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 31 of file ipv4.h.}\par
}
{\xe \v length\:ipv4_header}
{\xe \v ipv4_header\:length}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} ipv4_header::length}}
\par
{\bkmkstart AAAAAAACDV}
{\bkmkend AAAAAAACDV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 33 of file ipv4.h.}\par
}
{\xe \v offset\:ipv4_header}
{\xe \v ipv4_header\:offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} ipv4_header::offset}}
\par
{\bkmkstart AAAAAAACDW}
{\bkmkend AAAAAAACDW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 35 of file ipv4.h.}\par
}
{\xe \v protocol\:ipv4_header}
{\xe \v ipv4_header\:protocol}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} ipv4_header::protocol}}
\par
{\bkmkstart AAAAAAACDX}
{\bkmkend AAAAAAACDX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 37 of file ipv4.h.}\par
}
{\xe \v source\:ipv4_header}
{\xe \v ipv4_header\:source}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ipv4_t} ipv4_header::source}}
\par
{\bkmkstart AAAAAAACDY}
{\bkmkend AAAAAAACDY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 40 of file ipv4.h.}\par
}
{\xe \v tos\:ipv4_header}
{\xe \v ipv4_header\:tos}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} ipv4_header::tos}}
\par
{\bkmkstart AAAAAAACDZ}
{\bkmkend AAAAAAACDZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 32 of file ipv4.h.}\par
}
{\xe \v ttl\:ipv4_header}
{\xe \v ipv4_header\:ttl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} ipv4_header::ttl}}
\par
{\bkmkstart AAAAAAACEA}
{\bkmkend AAAAAAACEA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 36 of file ipv4.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
src/include/aplus/net/{\b ipv4.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ipv6_header Struct Reference\par \pard\plain 
{\tc\tcl2 \v ipv6_header}
{\xe \v ipv6_header}
{\bkmkstart AAAAAAACEB}
{\bkmkend AAAAAAACEB}
\par
{
{\f2 #include <ipv6.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b version}:4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b traffic}:8\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b flow}:20\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b length}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b protocol}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b ttl}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ipv6_t} {\b source}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ipv6_t} {\b dest}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 15 of file ipv6.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v dest\:ipv6_header}
{\xe \v ipv6_header\:dest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ipv6_t} ipv6_header::dest}}
\par
{\bkmkstart AAAAAAACEC}
{\bkmkend AAAAAAACEC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 25 of file ipv6.h.}\par
}
{\xe \v flow\:ipv6_header}
{\xe \v ipv6_header\:flow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} ipv6_header::flow}}
\par
{\bkmkstart AAAAAAACED}
{\bkmkend AAAAAAACED}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 18 of file ipv6.h.}\par
}
{\xe \v length\:ipv6_header}
{\xe \v ipv6_header\:length}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} ipv6_header::length}}
\par
{\bkmkstart AAAAAAACEE}
{\bkmkend AAAAAAACEE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 20 of file ipv6.h.}\par
}
{\xe \v protocol\:ipv6_header}
{\xe \v ipv6_header\:protocol}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} ipv6_header::protocol}}
\par
{\bkmkstart AAAAAAACEF}
{\bkmkend AAAAAAACEF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 21 of file ipv6.h.}\par
}
{\xe \v source\:ipv6_header}
{\xe \v ipv6_header\:source}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ipv6_t} ipv6_header::source}}
\par
{\bkmkstart AAAAAAACEG}
{\bkmkend AAAAAAACEG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 24 of file ipv6.h.}\par
}
{\xe \v traffic\:ipv6_header}
{\xe \v ipv6_header\:traffic}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} ipv6_header::traffic}}
\par
{\bkmkstart AAAAAAACEH}
{\bkmkend AAAAAAACEH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 17 of file ipv6.h.}\par
}
{\xe \v ttl\:ipv6_header}
{\xe \v ipv6_header\:ttl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} ipv6_header::ttl}}
\par
{\bkmkstart AAAAAAACEI}
{\bkmkend AAAAAAACEI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 22 of file ipv6.h.}\par
}
{\xe \v version\:ipv6_header}
{\xe \v ipv6_header\:version}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} ipv6_header::version}}
\par
{\bkmkstart AAAAAAACEJ}
{\bkmkend AAAAAAACEJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 16 of file ipv6.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
src/include/aplus/net/{\b ipv6.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
iso9660_dir Struct Reference\par \pard\plain 
{\tc\tcl2 \v iso9660_dir}
{\xe \v iso9660_dir}
{\bkmkstart AAAAAAACEK}
{\bkmkend AAAAAAACEK}
\par
{
{\f2 #include <iso9660.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b size}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b exattr}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b lba}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b length}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b date} [7]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b flags}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b unitsize}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b gapsize}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b volnumber}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b idlen}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b reserved} [0]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 78 of file iso9660.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v date\:iso9660_dir}
{\xe \v iso9660_dir\:date}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char iso9660_dir::date[7]}}
\par
{\bkmkstart AAAAAAACEL}
{\bkmkend AAAAAAACEL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 83 of file iso9660.h.}\par
}
{\xe \v exattr\:iso9660_dir}
{\xe \v iso9660_dir\:exattr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} iso9660_dir::exattr}}
\par
{\bkmkstart AAAAAAACEM}
{\bkmkend AAAAAAACEM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 80 of file iso9660.h.}\par
}
{\xe \v flags\:iso9660_dir}
{\xe \v iso9660_dir\:flags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} iso9660_dir::flags}}
\par
{\bkmkstart AAAAAAACEN}
{\bkmkend AAAAAAACEN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 84 of file iso9660.h.}\par
}
{\xe \v gapsize\:iso9660_dir}
{\xe \v iso9660_dir\:gapsize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} iso9660_dir::gapsize}}
\par
{\bkmkstart AAAAAAACEO}
{\bkmkend AAAAAAACEO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 86 of file iso9660.h.}\par
}
{\xe \v idlen\:iso9660_dir}
{\xe \v iso9660_dir\:idlen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} iso9660_dir::idlen}}
\par
{\bkmkstart AAAAAAACEP}
{\bkmkend AAAAAAACEP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 88 of file iso9660.h.}\par
}
{\xe \v lba\:iso9660_dir}
{\xe \v iso9660_dir\:lba}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t iso9660_dir::lba}}
\par
{\bkmkstart AAAAAAACEQ}
{\bkmkend AAAAAAACEQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 81 of file iso9660.h.}\par
}
{\xe \v length\:iso9660_dir}
{\xe \v iso9660_dir\:length}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t iso9660_dir::length}}
\par
{\bkmkstart AAAAAAACER}
{\bkmkend AAAAAAACER}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 82 of file iso9660.h.}\par
}
{\xe \v reserved\:iso9660_dir}
{\xe \v iso9660_dir\:reserved}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char iso9660_dir::reserved[0]}}
\par
{\bkmkstart AAAAAAACES}
{\bkmkend AAAAAAACES}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 89 of file iso9660.h.}\par
}
{\xe \v size\:iso9660_dir}
{\xe \v iso9660_dir\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} iso9660_dir::size}}
\par
{\bkmkstart AAAAAAACET}
{\bkmkend AAAAAAACET}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 79 of file iso9660.h.}\par
}
{\xe \v unitsize\:iso9660_dir}
{\xe \v iso9660_dir\:unitsize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} iso9660_dir::unitsize}}
\par
{\bkmkstart AAAAAAACEU}
{\bkmkend AAAAAAACEU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 85 of file iso9660.h.}\par
}
{\xe \v volnumber\:iso9660_dir}
{\xe \v iso9660_dir\:volnumber}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} iso9660_dir::volnumber}}
\par
{\bkmkstart AAAAAAACEV}
{\bkmkend AAAAAAACEV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 87 of file iso9660.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
src/fs/iso9660/{\b iso9660.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
iso9660_pvd Struct Reference\par \pard\plain 
{\tc\tcl2 \v iso9660_pvd}
{\xe \v iso9660_pvd}
{\bkmkstart AAAAAAACEW}
{\bkmkend AAAAAAACEW}
\par
{
{\f2 #include <iso9660.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b type}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b id} [5]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b version}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b unused}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b sysid} [32]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b volid} [32]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b null0} [8]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b volsize}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b null1} [32]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b volsetsize}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b volnumber}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b logical_blksize}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b path_size}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b path_lba}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b optpath_lba}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b path_lba_msb}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b optpath_lba_msb}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b rootdir} [34]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b volsetid} [128]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b pubid} [128]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b dataid} [128]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b appid} [128]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b copyid} [38]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b abstractfileid} [36]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b bibid} [37]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b cdate} [17]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b mdate} [17]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b edate} [17]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b efdate} [17]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b fileversion}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b unused0}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b null2} [512]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b reserved} [653]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 36 of file iso9660.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v abstractfileid\:iso9660_pvd}
{\xe \v iso9660_pvd\:abstractfileid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char iso9660_pvd::abstractfileid[36]}}
\par
{\bkmkstart AAAAAAACEX}
{\bkmkend AAAAAAACEX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 65 of file iso9660.h.}\par
}
{\xe \v appid\:iso9660_pvd}
{\xe \v iso9660_pvd\:appid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char iso9660_pvd::appid[128]}}
\par
{\bkmkstart AAAAAAACEY}
{\bkmkend AAAAAAACEY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 63 of file iso9660.h.}\par
}
{\xe \v bibid\:iso9660_pvd}
{\xe \v iso9660_pvd\:bibid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char iso9660_pvd::bibid[37]}}
\par
{\bkmkstart AAAAAAACEZ}
{\bkmkend AAAAAAACEZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 66 of file iso9660.h.}\par
}
{\xe \v cdate\:iso9660_pvd}
{\xe \v iso9660_pvd\:cdate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char iso9660_pvd::cdate[17]}}
\par
{\bkmkstart AAAAAAACFA}
{\bkmkend AAAAAAACFA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 67 of file iso9660.h.}\par
}
{\xe \v copyid\:iso9660_pvd}
{\xe \v iso9660_pvd\:copyid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char iso9660_pvd::copyid[38]}}
\par
{\bkmkstart AAAAAAACFB}
{\bkmkend AAAAAAACFB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 64 of file iso9660.h.}\par
}
{\xe \v dataid\:iso9660_pvd}
{\xe \v iso9660_pvd\:dataid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char iso9660_pvd::dataid[128]}}
\par
{\bkmkstart AAAAAAACFC}
{\bkmkend AAAAAAACFC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 62 of file iso9660.h.}\par
}
{\xe \v edate\:iso9660_pvd}
{\xe \v iso9660_pvd\:edate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char iso9660_pvd::edate[17]}}
\par
{\bkmkstart AAAAAAACFD}
{\bkmkend AAAAAAACFD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 69 of file iso9660.h.}\par
}
{\xe \v efdate\:iso9660_pvd}
{\xe \v iso9660_pvd\:efdate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char iso9660_pvd::efdate[17]}}
\par
{\bkmkstart AAAAAAACFE}
{\bkmkend AAAAAAACFE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 70 of file iso9660.h.}\par
}
{\xe \v fileversion\:iso9660_pvd}
{\xe \v iso9660_pvd\:fileversion}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t iso9660_pvd::fileversion}}
\par
{\bkmkstart AAAAAAACFF}
{\bkmkend AAAAAAACFF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 71 of file iso9660.h.}\par
}
{\xe \v id\:iso9660_pvd}
{\xe \v iso9660_pvd\:id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char iso9660_pvd::id[5]}}
\par
{\bkmkstart AAAAAAACFG}
{\bkmkend AAAAAAACFG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 38 of file iso9660.h.}\par
}
{\xe \v logical_blksize\:iso9660_pvd}
{\xe \v iso9660_pvd\:logical_blksize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} iso9660_pvd::logical_blksize}}
\par
{\bkmkstart AAAAAAACFH}
{\bkmkend AAAAAAACFH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 52 of file iso9660.h.}\par
}
{\xe \v mdate\:iso9660_pvd}
{\xe \v iso9660_pvd\:mdate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char iso9660_pvd::mdate[17]}}
\par
{\bkmkstart AAAAAAACFI}
{\bkmkend AAAAAAACFI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 68 of file iso9660.h.}\par
}
{\xe \v null0\:iso9660_pvd}
{\xe \v iso9660_pvd\:null0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char iso9660_pvd::null0[8]}}
\par
{\bkmkstart AAAAAAACFJ}
{\bkmkend AAAAAAACFJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 44 of file iso9660.h.}\par
}
{\xe \v null1\:iso9660_pvd}
{\xe \v iso9660_pvd\:null1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char iso9660_pvd::null1[32]}}
\par
{\bkmkstart AAAAAAACFK}
{\bkmkend AAAAAAACFK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 48 of file iso9660.h.}\par
}
{\xe \v null2\:iso9660_pvd}
{\xe \v iso9660_pvd\:null2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char iso9660_pvd::null2[512]}}
\par
{\bkmkstart AAAAAAACFL}
{\bkmkend AAAAAAACFL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 73 of file iso9660.h.}\par
}
{\xe \v optpath_lba\:iso9660_pvd}
{\xe \v iso9660_pvd\:optpath_lba}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} iso9660_pvd::optpath_lba}}
\par
{\bkmkstart AAAAAAACFM}
{\bkmkend AAAAAAACFM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 55 of file iso9660.h.}\par
}
{\xe \v optpath_lba_msb\:iso9660_pvd}
{\xe \v iso9660_pvd\:optpath_lba_msb}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} iso9660_pvd::optpath_lba_msb}}
\par
{\bkmkstart AAAAAAACFN}
{\bkmkend AAAAAAACFN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 57 of file iso9660.h.}\par
}
{\xe \v path_lba\:iso9660_pvd}
{\xe \v iso9660_pvd\:path_lba}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} iso9660_pvd::path_lba}}
\par
{\bkmkstart AAAAAAACFO}
{\bkmkend AAAAAAACFO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 54 of file iso9660.h.}\par
}
{\xe \v path_lba_msb\:iso9660_pvd}
{\xe \v iso9660_pvd\:path_lba_msb}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} iso9660_pvd::path_lba_msb}}
\par
{\bkmkstart AAAAAAACFP}
{\bkmkend AAAAAAACFP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 56 of file iso9660.h.}\par
}
{\xe \v path_size\:iso9660_pvd}
{\xe \v iso9660_pvd\:path_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t iso9660_pvd::path_size}}
\par
{\bkmkstart AAAAAAACFQ}
{\bkmkend AAAAAAACFQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 53 of file iso9660.h.}\par
}
{\xe \v pubid\:iso9660_pvd}
{\xe \v iso9660_pvd\:pubid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char iso9660_pvd::pubid[128]}}
\par
{\bkmkstart AAAAAAACFR}
{\bkmkend AAAAAAACFR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 61 of file iso9660.h.}\par
}
{\xe \v reserved\:iso9660_pvd}
{\xe \v iso9660_pvd\:reserved}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char iso9660_pvd::reserved[653]}}
\par
{\bkmkstart AAAAAAACFS}
{\bkmkend AAAAAAACFS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 74 of file iso9660.h.}\par
}
{\xe \v rootdir\:iso9660_pvd}
{\xe \v iso9660_pvd\:rootdir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char iso9660_pvd::rootdir[34]}}
\par
{\bkmkstart AAAAAAACFT}
{\bkmkend AAAAAAACFT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 59 of file iso9660.h.}\par
}
{\xe \v sysid\:iso9660_pvd}
{\xe \v iso9660_pvd\:sysid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char iso9660_pvd::sysid[32]}}
\par
{\bkmkstart AAAAAAACFU}
{\bkmkend AAAAAAACFU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 42 of file iso9660.h.}\par
}
{\xe \v type\:iso9660_pvd}
{\xe \v iso9660_pvd\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t iso9660_pvd::type}}
\par
{\bkmkstart AAAAAAACFV}
{\bkmkend AAAAAAACFV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 37 of file iso9660.h.}\par
}
{\xe \v unused\:iso9660_pvd}
{\xe \v iso9660_pvd\:unused}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t iso9660_pvd::unused}}
\par
{\bkmkstart AAAAAAACFW}
{\bkmkend AAAAAAACFW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 40 of file iso9660.h.}\par
}
{\xe \v unused0\:iso9660_pvd}
{\xe \v iso9660_pvd\:unused0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t iso9660_pvd::unused0}}
\par
{\bkmkstart AAAAAAACFX}
{\bkmkend AAAAAAACFX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 72 of file iso9660.h.}\par
}
{\xe \v version\:iso9660_pvd}
{\xe \v iso9660_pvd\:version}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t iso9660_pvd::version}}
\par
{\bkmkstart AAAAAAACFY}
{\bkmkend AAAAAAACFY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 39 of file iso9660.h.}\par
}
{\xe \v volid\:iso9660_pvd}
{\xe \v iso9660_pvd\:volid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char iso9660_pvd::volid[32]}}
\par
{\bkmkstart AAAAAAACFZ}
{\bkmkend AAAAAAACFZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 43 of file iso9660.h.}\par
}
{\xe \v volnumber\:iso9660_pvd}
{\xe \v iso9660_pvd\:volnumber}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} iso9660_pvd::volnumber}}
\par
{\bkmkstart AAAAAAACGA}
{\bkmkend AAAAAAACGA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 51 of file iso9660.h.}\par
}
{\xe \v volsetid\:iso9660_pvd}
{\xe \v iso9660_pvd\:volsetid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char iso9660_pvd::volsetid[128]}}
\par
{\bkmkstart AAAAAAACGB}
{\bkmkend AAAAAAACGB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 60 of file iso9660.h.}\par
}
{\xe \v volsetsize\:iso9660_pvd}
{\xe \v iso9660_pvd\:volsetsize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} iso9660_pvd::volsetsize}}
\par
{\bkmkstart AAAAAAACGC}
{\bkmkend AAAAAAACGC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 50 of file iso9660.h.}\par
}
{\xe \v volsize\:iso9660_pvd}
{\xe \v iso9660_pvd\:volsize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t iso9660_pvd::volsize}}
\par
{\bkmkstart AAAAAAACGD}
{\bkmkend AAAAAAACGD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 46 of file iso9660.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
src/fs/iso9660/{\b iso9660.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
iso9660_volume_descriptor Struct Reference\par \pard\plain 
{\tc\tcl2 \v iso9660_volume_descriptor}
{\xe \v iso9660_volume_descriptor}
{\bkmkstart AAAAAAACGE}
{\bkmkend AAAAAAACGE}
\par
{
{\f2 #include <iso9660.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b type}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b id} [5]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b version}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b data} [2041]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 29 of file iso9660.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v data\:iso9660_volume_descriptor}
{\xe \v iso9660_volume_descriptor\:data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char iso9660_volume_descriptor::data[2041]}}
\par
{\bkmkstart AAAAAAACGF}
{\bkmkend AAAAAAACGF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 33 of file iso9660.h.}\par
}
{\xe \v id\:iso9660_volume_descriptor}
{\xe \v iso9660_volume_descriptor\:id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char iso9660_volume_descriptor::id[5]}}
\par
{\bkmkstart AAAAAAACGG}
{\bkmkend AAAAAAACGG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 31 of file iso9660.h.}\par
}
{\xe \v type\:iso9660_volume_descriptor}
{\xe \v iso9660_volume_descriptor\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t iso9660_volume_descriptor::type}}
\par
{\bkmkstart AAAAAAACGH}
{\bkmkend AAAAAAACGH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 30 of file iso9660.h.}\par
}
{\xe \v version\:iso9660_volume_descriptor}
{\xe \v iso9660_volume_descriptor\:version}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t iso9660_volume_descriptor::version}}
\par
{\bkmkstart AAAAAAACGI}
{\bkmkend AAAAAAACGI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 32 of file iso9660.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
src/fs/iso9660/{\b iso9660.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
list Struct Reference\par \pard\plain 
{\tc\tcl2 \v list}
{\xe \v list}
{\bkmkstart AAAAAAACGJ}
{\bkmkend AAAAAAACGJ}
\par
{
{\f2 #include <list.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b list_body_t} * {\b body}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b spinlock_t} {\b lock}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b size}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 41 of file list.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v body\:list}
{\xe \v list\:body}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b list_body_t}* list::body}}
\par
{\bkmkstart AAAAAAACGK}
{\bkmkend AAAAAAACGK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 42 of file list.h.}\par
}
{\xe \v lock\:list}
{\xe \v list\:lock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b spinlock_t} list::lock}}
\par
{\bkmkstart AAAAAAACGL}
{\bkmkend AAAAAAACGL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 44 of file list.h.}\par
}
{\xe \v size\:list}
{\xe \v list\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t list::size}}
\par
{\bkmkstart AAAAAAACGM}
{\bkmkend AAAAAAACGM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 45 of file list.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
src/include/aplus/{\b list.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
list_body Struct Reference\par \pard\plain 
{\tc\tcl2 \v list_body}
{\xe \v list_body}
{\bkmkstart AAAAAAACGN}
{\bkmkend AAAAAAACGN}
\par
{
{\f2 #include <list.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b listval_t} {\b value}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b list_body} * {\b next}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 35 of file list.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v next\:list_body}
{\xe \v list_body\:next}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b list_body}* list_body::next}}
\par
{\bkmkstart AAAAAAACGO}
{\bkmkend AAAAAAACGO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 38 of file list.h.}\par
}
{\xe \v value\:list_body}
{\xe \v list_body\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b listval_t} list_body::value}}
\par
{\bkmkstart AAAAAAACGP}
{\bkmkend AAAAAAACGP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 36 of file list.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
src/include/aplus/{\b list.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
netif Struct Reference\par \pard\plain 
{\tc\tcl2 \v netif}
{\xe \v netif}
{\bkmkstart AAAAAAACGQ}
{\bkmkend AAAAAAACGQ}
\par
{
{\f2 #include <netif.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b name} [32]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b data}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ipv6_t} {\b ipv6}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ipv4_t} {\b ipv4}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ipv4_t} {\b netmask}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b macaddr_t} {\b macaddr}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct \{\par

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ struct \{\par

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ {\b ipv4_t} {\b ipv4}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ {\b ipv6_t} {\b ipv6}\par
}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \} {\b primary}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ struct \{\par

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ {\b ipv4_t} {\b ipv4}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ {\b ipv6_t} {\b ipv6}\par
}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \} {\b secondary}\par
}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\} {\b dns}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct \{\par

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ uint64_t {\b rx_packets}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ uint64_t {\b rx_bytes}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ uint64_t {\b rx_errors}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ uint64_t {\b rx_dropped}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ uint64_t {\b tx_packets}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ uint64_t {\b tx_bytes}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ uint64_t {\b tx_errors}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ uint64_t {\b tx_dropped}\par
}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\} {\b state}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int(* {\b send} )(struct {\b netif} *, void *, size_t, int)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int(* {\b ifup} )(struct {\b netif} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int(* {\b ifdown} )(struct {\b netif} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b mtu}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b flags}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b pci_device_t} * {\b device}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 33 of file netif.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v data\:netif}
{\xe \v netif\:data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* netif::data}}
\par
{\bkmkstart AAAAAAACGR}
{\bkmkend AAAAAAACGR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 35 of file netif.h.}\par
}
{\xe \v device\:netif}
{\xe \v netif\:device}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b pci_device_t}* netif::device}}
\par
{\bkmkstart AAAAAAACGS}
{\bkmkend AAAAAAACGS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 73 of file netif.h.}\par
}
{\xe \v dns\:netif}
{\xe \v netif\:dns}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct \{ ... \}   netif::dns}}
\par
{\bkmkstart AAAAAAACGT}
{\bkmkend AAAAAAACGT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v flags\:netif}
{\xe \v netif\:flags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} netif::flags}}
\par
{\bkmkstart AAAAAAACGU}
{\bkmkend AAAAAAACGU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 71 of file netif.h.}\par
}
{\xe \v ifdown\:netif}
{\xe \v netif\:ifdown}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int(* netif::ifdown)(struct {\b netif} *)}}
\par
{\bkmkstart AAAAAAACGV}
{\bkmkend AAAAAAACGV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 68 of file netif.h.}\par
}
{\xe \v ifup\:netif}
{\xe \v netif\:ifup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int(* netif::ifup)(struct {\b netif} *)}}
\par
{\bkmkstart AAAAAAACGW}
{\bkmkend AAAAAAACGW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 67 of file netif.h.}\par
}
{\xe \v ipv4\:netif}
{\xe \v netif\:ipv4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ipv4_t} netif::ipv4}}
\par
{\bkmkstart AAAAAAACGX}
{\bkmkend AAAAAAACGX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 38 of file netif.h.}\par
}
{\xe \v ipv6\:netif}
{\xe \v netif\:ipv6}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ipv6_t} netif::ipv6}}
\par
{\bkmkstart AAAAAAACGY}
{\bkmkend AAAAAAACGY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 37 of file netif.h.}\par
}
{\xe \v macaddr\:netif}
{\xe \v netif\:macaddr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b macaddr_t} netif::macaddr}}
\par
{\bkmkstart AAAAAAACGZ}
{\bkmkend AAAAAAACGZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 40 of file netif.h.}\par
}
{\xe \v mtu\:netif}
{\xe \v netif\:mtu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} netif::mtu}}
\par
{\bkmkstart AAAAAAACHA}
{\bkmkend AAAAAAACHA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 70 of file netif.h.}\par
}
{\xe \v name\:netif}
{\xe \v netif\:name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char netif::name[32]}}
\par
{\bkmkstart AAAAAAACHB}
{\bkmkend AAAAAAACHB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 34 of file netif.h.}\par
}
{\xe \v netmask\:netif}
{\xe \v netif\:netmask}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ipv4_t} netif::netmask}}
\par
{\bkmkstart AAAAAAACHC}
{\bkmkend AAAAAAACHC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 39 of file netif.h.}\par
}
{\xe \v primary\:netif}
{\xe \v netif\:primary}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct \{ ... \}   netif::primary}}
\par
{\bkmkstart AAAAAAACHD}
{\bkmkend AAAAAAACHD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v rx_bytes\:netif}
{\xe \v netif\:rx_bytes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t netif::rx_bytes}}
\par
{\bkmkstart AAAAAAACHE}
{\bkmkend AAAAAAACHE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 56 of file netif.h.}\par
}
{\xe \v rx_dropped\:netif}
{\xe \v netif\:rx_dropped}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t netif::rx_dropped}}
\par
{\bkmkstart AAAAAAACHF}
{\bkmkend AAAAAAACHF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 58 of file netif.h.}\par
}
{\xe \v rx_errors\:netif}
{\xe \v netif\:rx_errors}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t netif::rx_errors}}
\par
{\bkmkstart AAAAAAACHG}
{\bkmkend AAAAAAACHG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 57 of file netif.h.}\par
}
{\xe \v rx_packets\:netif}
{\xe \v netif\:rx_packets}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t netif::rx_packets}}
\par
{\bkmkstart AAAAAAACHH}
{\bkmkend AAAAAAACHH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 55 of file netif.h.}\par
}
{\xe \v secondary\:netif}
{\xe \v netif\:secondary}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct \{ ... \}   netif::secondary}}
\par
{\bkmkstart AAAAAAACHI}
{\bkmkend AAAAAAACHI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v send\:netif}
{\xe \v netif\:send}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int(* netif::send)(struct {\b netif} *, void *, size_t, int)}}
\par
{\bkmkstart AAAAAAACHJ}
{\bkmkend AAAAAAACHJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 66 of file netif.h.}\par
}
{\xe \v state\:netif}
{\xe \v netif\:state}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct \{ ... \}   netif::state}}
\par
{\bkmkstart AAAAAAACHK}
{\bkmkend AAAAAAACHK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tx_bytes\:netif}
{\xe \v netif\:tx_bytes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t netif::tx_bytes}}
\par
{\bkmkstart AAAAAAACHL}
{\bkmkend AAAAAAACHL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 61 of file netif.h.}\par
}
{\xe \v tx_dropped\:netif}
{\xe \v netif\:tx_dropped}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t netif::tx_dropped}}
\par
{\bkmkstart AAAAAAACHM}
{\bkmkend AAAAAAACHM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 63 of file netif.h.}\par
}
{\xe \v tx_errors\:netif}
{\xe \v netif\:tx_errors}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t netif::tx_errors}}
\par
{\bkmkstart AAAAAAACHN}
{\bkmkend AAAAAAACHN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 62 of file netif.h.}\par
}
{\xe \v tx_packets\:netif}
{\xe \v netif\:tx_packets}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t netif::tx_packets}}
\par
{\bkmkstart AAAAAAACHO}
{\bkmkend AAAAAAACHO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 60 of file netif.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
src/include/aplus/{\b netif.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
netif_packet Struct Reference\par \pard\plain 
{\tc\tcl2 \v netif_packet}
{\xe \v netif_packet}
{\bkmkstart AAAAAAACHP}
{\bkmkend AAAAAAACHP}
\par
{
{\f2 #include <netif.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b id}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b protocol}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b length}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b header}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b data}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b netif_t} * {\b netif}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 77 of file netif.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v data\:netif_packet}
{\xe \v netif_packet\:data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* netif_packet::data}}
\par
{\bkmkstart AAAAAAACHQ}
{\bkmkend AAAAAAACHQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 83 of file netif.h.}\par
}
{\xe \v header\:netif_packet}
{\xe \v netif_packet\:header}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* netif_packet::header}}
\par
{\bkmkstart AAAAAAACHR}
{\bkmkend AAAAAAACHR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 82 of file netif.h.}\par
}
{\xe \v id\:netif_packet}
{\xe \v netif_packet\:id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t netif_packet::id}}
\par
{\bkmkstart AAAAAAACHS}
{\bkmkend AAAAAAACHS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 78 of file netif.h.}\par
}
{\xe \v length\:netif_packet}
{\xe \v netif_packet\:length}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int netif_packet::length}}
\par
{\bkmkstart AAAAAAACHT}
{\bkmkend AAAAAAACHT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 80 of file netif.h.}\par
}
{\xe \v netif\:netif_packet}
{\xe \v netif_packet\:netif}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b netif_t}* netif_packet::netif}}
\par
{\bkmkstart AAAAAAACHU}
{\bkmkend AAAAAAACHU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 85 of file netif.h.}\par
}
{\xe \v protocol\:netif_packet}
{\xe \v netif_packet\:protocol}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int netif_packet::protocol}}
\par
{\bkmkstart AAAAAAACHV}
{\bkmkend AAAAAAACHV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 79 of file netif.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
src/include/aplus/{\b netif.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
netif_socket Struct Reference\par \pard\plain 
{\tc\tcl2 \v netif_socket}
{\xe \v netif_socket}
{\bkmkstart AAAAAAACHW}
{\bkmkend AAAAAAACHW}
\par
{
{\f2 #include <netif.h>}}\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 90 of file netif.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
src/include/aplus/{\b netif.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
pci_device Struct Reference\par \pard\plain 
{\tc\tcl2 \v pci_device}
{\xe \v pci_device}
{\bkmkstart AAAAAAACHX}
{\bkmkend AAAAAAACHX}
\par
{
{\f2 #include <pci.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b vendorID}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b deviceID}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b bus}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b dev}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b func}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b revision}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b pci_class}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b iobase}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b membase}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b header}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b intr_pin}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b intr_line}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 23 of file pci.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v bus\:pci_device}
{\xe \v pci_device\:bus}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} pci_device::bus}}
\par
{\bkmkstart AAAAAAACHY}
{\bkmkend AAAAAAACHY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 27 of file pci.h.}\par
}
{\xe \v dev\:pci_device}
{\xe \v pci_device\:dev}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} pci_device::dev}}
\par
{\bkmkstart AAAAAAACHZ}
{\bkmkend AAAAAAACHZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 28 of file pci.h.}\par
}
{\xe \v deviceID\:pci_device}
{\xe \v pci_device\:deviceID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} pci_device::deviceID}}
\par
{\bkmkstart AAAAAAACIA}
{\bkmkend AAAAAAACIA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 25 of file pci.h.}\par
}
{\xe \v func\:pci_device}
{\xe \v pci_device\:func}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} pci_device::func}}
\par
{\bkmkstart AAAAAAACIB}
{\bkmkend AAAAAAACIB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 29 of file pci.h.}\par
}
{\xe \v header\:pci_device}
{\xe \v pci_device\:header}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} pci_device::header}}
\par
{\bkmkstart AAAAAAACIC}
{\bkmkend AAAAAAACIC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 36 of file pci.h.}\par
}
{\xe \v intr_line\:pci_device}
{\xe \v pci_device\:intr_line}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} pci_device::intr_line}}
\par
{\bkmkstart AAAAAAACID}
{\bkmkend AAAAAAACID}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 38 of file pci.h.}\par
}
{\xe \v intr_pin\:pci_device}
{\xe \v pci_device\:intr_pin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} pci_device::intr_pin}}
\par
{\bkmkstart AAAAAAACIE}
{\bkmkend AAAAAAACIE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 37 of file pci.h.}\par
}
{\xe \v iobase\:pci_device}
{\xe \v pci_device\:iobase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} pci_device::iobase}}
\par
{\bkmkstart AAAAAAACIF}
{\bkmkend AAAAAAACIF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 33 of file pci.h.}\par
}
{\xe \v membase\:pci_device}
{\xe \v pci_device\:membase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} pci_device::membase}}
\par
{\bkmkstart AAAAAAACIG}
{\bkmkend AAAAAAACIG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 34 of file pci.h.}\par
}
{\xe \v pci_class\:pci_device}
{\xe \v pci_device\:pci_class}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} pci_device::pci_class}}
\par
{\bkmkstart AAAAAAACIH}
{\bkmkend AAAAAAACIH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 32 of file pci.h.}\par
}
{\xe \v revision\:pci_device}
{\xe \v pci_device\:revision}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} pci_device::revision}}
\par
{\bkmkstart AAAAAAACII}
{\bkmkend AAAAAAACII}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 30 of file pci.h.}\par
}
{\xe \v vendorID\:pci_device}
{\xe \v pci_device\:vendorID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} pci_device::vendorID}}
\par
{\bkmkstart AAAAAAACIJ}
{\bkmkend AAAAAAACIJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 24 of file pci.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
src/include/aplus/{\b pci.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
pipeinfo Struct Reference\par \pard\plain 
{\tc\tcl2 \v pipeinfo}
{\xe \v pipeinfo}
{\bkmkstart AAAAAAACIK}
{\bkmkend AAAAAAACIK}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bufio_t} * {\b stream}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
off_t {\b read_offset}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
off_t {\b write_offset}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 20 of file pipe.c.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v read_offset\:pipeinfo}
{\xe \v pipeinfo\:read_offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
off_t pipeinfo::read_offset}}
\par
{\bkmkstart AAAAAAACIL}
{\bkmkend AAAAAAACIL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 22 of file pipe.c.}\par
}
{\xe \v stream\:pipeinfo}
{\xe \v pipeinfo\:stream}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bufio_t}* pipeinfo::stream}}
\par
{\bkmkstart AAAAAAACIM}
{\bkmkend AAAAAAACIM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 21 of file pipe.c.}\par
}
{\xe \v write_offset\:pipeinfo}
{\xe \v pipeinfo\:write_offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
off_t pipeinfo::write_offset}}
\par
{\bkmkstart AAAAAAACIN}
{\bkmkend AAAAAAACIN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 23 of file pipe.c.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
src/fs/{\b pipe.c}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
pthread_attr Struct Reference\par \pard\plain 
{\tc\tcl2 \v pthread_attr}
{\xe \v pthread_attr}
{\bkmkstart AAAAAAACIO}
{\bkmkend AAAAAAACIO}
\par
{
{\f2 #include <pthread.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b stackaddr}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b stacksize}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b detachstate}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct sched_param {\b param}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b inheritsched}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b contentionscope}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 57 of file pthread.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v contentionscope\:pthread_attr}
{\xe \v pthread_attr\:contentionscope}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_attr::contentionscope}}
\par
{\bkmkstart AAAAAAACIP}
{\bkmkend AAAAAAACIP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 63 of file pthread.h.}\par
}
{\xe \v detachstate\:pthread_attr}
{\xe \v pthread_attr\:detachstate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_attr::detachstate}}
\par
{\bkmkstart AAAAAAACIQ}
{\bkmkend AAAAAAACIQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 60 of file pthread.h.}\par
}
{\xe \v inheritsched\:pthread_attr}
{\xe \v pthread_attr\:inheritsched}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_attr::inheritsched}}
\par
{\bkmkstart AAAAAAACIR}
{\bkmkend AAAAAAACIR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 62 of file pthread.h.}\par
}
{\xe \v param\:pthread_attr}
{\xe \v pthread_attr\:param}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct sched_param pthread_attr::param}}
\par
{\bkmkstart AAAAAAACIS}
{\bkmkend AAAAAAACIS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 61 of file pthread.h.}\par
}
{\xe \v stackaddr\:pthread_attr}
{\xe \v pthread_attr\:stackaddr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* pthread_attr::stackaddr}}
\par
{\bkmkstart AAAAAAACIT}
{\bkmkend AAAAAAACIT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 58 of file pthread.h.}\par
}
{\xe \v stacksize\:pthread_attr}
{\xe \v pthread_attr\:stacksize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t pthread_attr::stacksize}}
\par
{\bkmkstart AAAAAAACIU}
{\bkmkend AAAAAAACIU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 59 of file pthread.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
usr/src/libpthread/include/{\b pthread.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
pthread_barrier Struct Reference\par \pard\plain 
{\tc\tcl2 \v pthread_barrier}
{\xe \v pthread_barrier}
{\bkmkstart AAAAAAACIV}
{\bkmkend AAAAAAACIV}
\par
{
{\f2 #include <pthread.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b curr_height}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b init_height}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 121 of file pthread.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v curr_height\:pthread_barrier}
{\xe \v pthread_barrier\:curr_height}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} pthread_barrier::curr_height}}
\par
{\bkmkstart AAAAAAACIW}
{\bkmkend AAAAAAACIW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 122 of file pthread.h.}\par
}
{\xe \v init_height\:pthread_barrier}
{\xe \v pthread_barrier\:init_height}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} pthread_barrier::init_height}}
\par
{\bkmkstart AAAAAAACIX}
{\bkmkend AAAAAAACIX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 123 of file pthread.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
usr/src/libpthread/include/{\b pthread.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
pthread_barrierattr Struct Reference\par \pard\plain 
{\tc\tcl2 \v pthread_barrierattr}
{\xe \v pthread_barrierattr}
{\bkmkstart AAAAAAACIY}
{\bkmkend AAAAAAACIY}
\par
{
{\f2 #include <pthread.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pshared}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 116 of file pthread.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v pshared\:pthread_barrierattr}
{\xe \v pthread_barrierattr\:pshared}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_barrierattr::pshared}}
\par
{\bkmkstart AAAAAAACIZ}
{\bkmkend AAAAAAACIZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 117 of file pthread.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
usr/src/libpthread/include/{\b pthread.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
pthread_cond Struct Reference\par \pard\plain 
{\tc\tcl2 \v pthread_cond}
{\xe \v pthread_cond}
{\bkmkstart AAAAAAACJA}
{\bkmkend AAAAAAACJA}
\par
{
{\f2 #include <pthread.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b waiting}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b handle_t} {\b semaphore}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 105 of file pthread.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v semaphore\:pthread_cond}
{\xe \v pthread_cond\:semaphore}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b handle_t} pthread_cond::semaphore}}
\par
{\bkmkstart AAAAAAACJB}
{\bkmkend AAAAAAACJB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 107 of file pthread.h.}\par
}
{\xe \v waiting\:pthread_cond}
{\xe \v pthread_cond\:waiting}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_cond::waiting}}
\par
{\bkmkstart AAAAAAACJC}
{\bkmkend AAAAAAACJC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 106 of file pthread.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
usr/src/libpthread/include/{\b pthread.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
pthread_condattr Struct Reference\par \pard\plain 
{\tc\tcl2 \v pthread_condattr}
{\xe \v pthread_condattr}
{\bkmkstart AAAAAAACJD}
{\bkmkend AAAAAAACJD}
\par
{
{\f2 #include <pthread.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pshared}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 101 of file pthread.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v pshared\:pthread_condattr}
{\xe \v pthread_condattr\:pshared}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_condattr::pshared}}
\par
{\bkmkstart AAAAAAACJE}
{\bkmkend AAAAAAACJE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 102 of file pthread.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
usr/src/libpthread/include/{\b pthread.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
pthread_context Struct Reference\par \pard\plain 
{\tc\tcl2 \v pthread_context}
{\xe \v pthread_context}
{\bkmkstart AAAAAAACJF}
{\bkmkend AAAAAAACJF}
\par
{
{\f2 #include <pthread_internal.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b tid}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void *(* {\b entry} )(void *p)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b param}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b exitval}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b pthread_once_t} {\b once}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b pthread_attr_t} {\b attr}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b pthread_cond_t} * {\b cond}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b pthread_context} * {\b next}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 37 of file pthread_internal.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v attr\:pthread_context}
{\xe \v pthread_context\:attr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b pthread_attr_t} pthread_context::attr}}
\par
{\bkmkstart AAAAAAACJG}
{\bkmkend AAAAAAACJG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 44 of file pthread_internal.h.}\par
}
{\xe \v cond\:pthread_context}
{\xe \v pthread_context\:cond}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b pthread_cond_t}* pthread_context::cond}}
\par
{\bkmkstart AAAAAAACJH}
{\bkmkend AAAAAAACJH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 45 of file pthread_internal.h.}\par
}
{\xe \v entry\:pthread_context}
{\xe \v pthread_context\:entry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void*(* pthread_context::entry)(void *p)}}
\par
{\bkmkstart AAAAAAACJI}
{\bkmkend AAAAAAACJI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 39 of file pthread_internal.h.}\par
}
{\xe \v exitval\:pthread_context}
{\xe \v pthread_context\:exitval}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* pthread_context::exitval}}
\par
{\bkmkstart AAAAAAACJJ}
{\bkmkend AAAAAAACJJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 41 of file pthread_internal.h.}\par
}
{\xe \v next\:pthread_context}
{\xe \v pthread_context\:next}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b pthread_context}* pthread_context::next}}
\par
{\bkmkstart AAAAAAACJK}
{\bkmkend AAAAAAACJK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 47 of file pthread_internal.h.}\par
}
{\xe \v once\:pthread_context}
{\xe \v pthread_context\:once}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b pthread_once_t} pthread_context::once}}
\par
{\bkmkstart AAAAAAACJL}
{\bkmkend AAAAAAACJL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 43 of file pthread_internal.h.}\par
}
{\xe \v param\:pthread_context}
{\xe \v pthread_context\:param}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* pthread_context::param}}
\par
{\bkmkstart AAAAAAACJM}
{\bkmkend AAAAAAACJM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 40 of file pthread_internal.h.}\par
}
{\xe \v tid\:pthread_context}
{\xe \v pthread_context\:tid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_context::tid}}
\par
{\bkmkstart AAAAAAACJN}
{\bkmkend AAAAAAACJN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 38 of file pthread_internal.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
usr/src/libpthread/src/{\b pthread_internal.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
pthread_mutex Struct Reference\par \pard\plain 
{\tc\tcl2 \v pthread_mutex}
{\xe \v pthread_mutex}
{\bkmkstart AAAAAAACJO}
{\bkmkend AAAAAAACJO}
\par
{
{\f2 #include <pthread.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b lock}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b recursion}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b kind}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b pthread_t} {\b owner}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b handle_t} {\b event}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b time}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 87 of file pthread.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v event\:pthread_mutex}
{\xe \v pthread_mutex\:event}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b handle_t} pthread_mutex::event}}
\par
{\bkmkstart AAAAAAACJP}
{\bkmkend AAAAAAACJP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 92 of file pthread.h.}\par
}
{\xe \v kind\:pthread_mutex}
{\xe \v pthread_mutex\:kind}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_mutex::kind}}
\par
{\bkmkstart AAAAAAACJQ}
{\bkmkend AAAAAAACJQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 90 of file pthread.h.}\par
}
{\xe \v lock\:pthread_mutex}
{\xe \v pthread_mutex\:lock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_mutex::lock}}
\par
{\bkmkstart AAAAAAACJR}
{\bkmkend AAAAAAACJR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 88 of file pthread.h.}\par
}
{\xe \v owner\:pthread_mutex}
{\xe \v pthread_mutex\:owner}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b pthread_t} pthread_mutex::owner}}
\par
{\bkmkstart AAAAAAACJS}
{\bkmkend AAAAAAACJS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 91 of file pthread.h.}\par
}
{\xe \v recursion\:pthread_mutex}
{\xe \v pthread_mutex\:recursion}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_mutex::recursion}}
\par
{\bkmkstart AAAAAAACJT}
{\bkmkend AAAAAAACJT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 89 of file pthread.h.}\par
}
{\xe \v time\:pthread_mutex}
{\xe \v pthread_mutex\:time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_mutex::time}}
\par
{\bkmkstart AAAAAAACJU}
{\bkmkend AAAAAAACJU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 93 of file pthread.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
usr/src/libpthread/include/{\b pthread.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
pthread_mutexattr Struct Reference\par \pard\plain 
{\tc\tcl2 \v pthread_mutexattr}
{\xe \v pthread_mutexattr}
{\bkmkstart AAAAAAACJV}
{\bkmkend AAAAAAACJV}
\par
{
{\f2 #include <pthread.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pshared}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b kind}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 81 of file pthread.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v kind\:pthread_mutexattr}
{\xe \v pthread_mutexattr\:kind}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_mutexattr::kind}}
\par
{\bkmkstart AAAAAAACJW}
{\bkmkend AAAAAAACJW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 83 of file pthread.h.}\par
}
{\xe \v pshared\:pthread_mutexattr}
{\xe \v pthread_mutexattr\:pshared}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_mutexattr::pshared}}
\par
{\bkmkstart AAAAAAACJX}
{\bkmkend AAAAAAACJX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 82 of file pthread.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
usr/src/libpthread/include/{\b pthread.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
pthread_once Struct Reference\par \pard\plain 
{\tc\tcl2 \v pthread_once}
{\xe \v pthread_once}
{\bkmkstart AAAAAAACJY}
{\bkmkend AAAAAAACJY}
\par
{
{\f2 #include <pthread.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile int {\b done}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b started}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 67 of file pthread.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v done\:pthread_once}
{\xe \v pthread_once\:done}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile int pthread_once::done}}
\par
{\bkmkstart AAAAAAACJZ}
{\bkmkend AAAAAAACJZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 68 of file pthread.h.}\par
}
{\xe \v started\:pthread_once}
{\xe \v pthread_once\:started}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_once::started}}
\par
{\bkmkstart AAAAAAACKA}
{\bkmkend AAAAAAACKA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 69 of file pthread.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
usr/src/libpthread/include/{\b pthread.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
pthread_rwlock Struct Reference\par \pard\plain 
{\tc\tcl2 \v pthread_rwlock}
{\xe \v pthread_rwlock}
{\bkmkstart AAAAAAACKB}
{\bkmkend AAAAAAACKB}
\par
{
{\f2 #include <pthread.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b pthread_mutex_t} {\b rdmutex}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b pthread_mutex_t} {\b wrmutex}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b handle_t} {\b shared_waiters}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b handle_t} {\b exclusive_waiters}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b num_shared_waiters}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b num_exclusive_waiters}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b pthread_t} {\b owner}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 132 of file pthread.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v exclusive_waiters\:pthread_rwlock}
{\xe \v pthread_rwlock\:exclusive_waiters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b handle_t} pthread_rwlock::exclusive_waiters}}
\par
{\bkmkstart AAAAAAACKC}
{\bkmkend AAAAAAACKC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 136 of file pthread.h.}\par
}
{\xe \v num_exclusive_waiters\:pthread_rwlock}
{\xe \v pthread_rwlock\:num_exclusive_waiters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_rwlock::num_exclusive_waiters}}
\par
{\bkmkstart AAAAAAACKD}
{\bkmkend AAAAAAACKD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 138 of file pthread.h.}\par
}
{\xe \v num_shared_waiters\:pthread_rwlock}
{\xe \v pthread_rwlock\:num_shared_waiters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_rwlock::num_shared_waiters}}
\par
{\bkmkstart AAAAAAACKE}
{\bkmkend AAAAAAACKE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 137 of file pthread.h.}\par
}
{\xe \v owner\:pthread_rwlock}
{\xe \v pthread_rwlock\:owner}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b pthread_t} pthread_rwlock::owner}}
\par
{\bkmkstart AAAAAAACKF}
{\bkmkend AAAAAAACKF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 139 of file pthread.h.}\par
}
{\xe \v rdmutex\:pthread_rwlock}
{\xe \v pthread_rwlock\:rdmutex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b pthread_mutex_t} pthread_rwlock::rdmutex}}
\par
{\bkmkstart AAAAAAACKG}
{\bkmkend AAAAAAACKG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 133 of file pthread.h.}\par
}
{\xe \v shared_waiters\:pthread_rwlock}
{\xe \v pthread_rwlock\:shared_waiters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b handle_t} pthread_rwlock::shared_waiters}}
\par
{\bkmkstart AAAAAAACKH}
{\bkmkend AAAAAAACKH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 135 of file pthread.h.}\par
}
{\xe \v wrmutex\:pthread_rwlock}
{\xe \v pthread_rwlock\:wrmutex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b pthread_mutex_t} pthread_rwlock::wrmutex}}
\par
{\bkmkstart AAAAAAACKI}
{\bkmkend AAAAAAACKI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 134 of file pthread.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
usr/src/libpthread/include/{\b pthread.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
pthread_rwlockattr Struct Reference\par \pard\plain 
{\tc\tcl2 \v pthread_rwlockattr}
{\xe \v pthread_rwlockattr}
{\bkmkstart AAAAAAACKJ}
{\bkmkend AAAAAAACKJ}
\par
{
{\f2 #include <pthread.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pshared}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 127 of file pthread.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v pshared\:pthread_rwlockattr}
{\xe \v pthread_rwlockattr\:pshared}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_rwlockattr::pshared}}
\par
{\bkmkstart AAAAAAACKK}
{\bkmkend AAAAAAACKK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 128 of file pthread.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
usr/src/libpthread/include/{\b pthread.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
pthread_spinlock Struct Reference\par \pard\plain 
{\tc\tcl2 \v pthread_spinlock}
{\xe \v pthread_spinlock}
{\bkmkstart AAAAAAACKL}
{\bkmkend AAAAAAACKL}
\par
{
{\f2 #include <pthread.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b interlock}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b pthread_mutex_t} {\b mutex}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 149 of file pthread.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v interlock\:pthread_spinlock}
{\xe \v pthread_spinlock\:interlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_spinlock::interlock}}
\par
{\bkmkstart AAAAAAACKM}
{\bkmkend AAAAAAACKM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 150 of file pthread.h.}\par
}
{\xe \v mutex\:pthread_spinlock}
{\xe \v pthread_spinlock\:mutex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b pthread_mutex_t} pthread_spinlock::mutex}}
\par
{\bkmkstart AAAAAAACKN}
{\bkmkend AAAAAAACKN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 151 of file pthread.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
usr/src/libpthread/include/{\b pthread.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
regs Struct Reference\par \pard\plain 
{\tc\tcl2 \v regs}
{\xe \v regs}
{\bkmkstart AAAAAAACKO}
{\bkmkend AAAAAAACKO}
\par
{
{\f2 #include <aplus.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b gs}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b fs}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b es}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b ds}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b edi}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b esi}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b ebp}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b esp}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b ebx}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b edx}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b ecx}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b eax}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b int_no}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b err_code}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b eip}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b cs}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b eflags}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b useresp}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 141 of file aplus.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v cs\:regs}
{\xe \v regs\:cs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} regs::cs}}
\par
{\bkmkstart AAAAAAACKP}
{\bkmkend AAAAAAACKP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 142 of file aplus.h.}\par
}
{\xe \v ds\:regs}
{\xe \v regs\:ds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} regs::ds}}
\par
{\bkmkstart AAAAAAACKQ}
{\bkmkend AAAAAAACKQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 142 of file aplus.h.}\par
}
{\xe \v eax\:regs}
{\xe \v regs\:eax}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} regs::eax}}
\par
{\bkmkstart AAAAAAACKR}
{\bkmkend AAAAAAACKR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 142 of file aplus.h.}\par
}
{\xe \v ebp\:regs}
{\xe \v regs\:ebp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} regs::ebp}}
\par
{\bkmkstart AAAAAAACKS}
{\bkmkend AAAAAAACKS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 142 of file aplus.h.}\par
}
{\xe \v ebx\:regs}
{\xe \v regs\:ebx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} regs::ebx}}
\par
{\bkmkstart AAAAAAACKT}
{\bkmkend AAAAAAACKT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 142 of file aplus.h.}\par
}
{\xe \v ecx\:regs}
{\xe \v regs\:ecx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} regs::ecx}}
\par
{\bkmkstart AAAAAAACKU}
{\bkmkend AAAAAAACKU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 142 of file aplus.h.}\par
}
{\xe \v edi\:regs}
{\xe \v regs\:edi}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} regs::edi}}
\par
{\bkmkstart AAAAAAACKV}
{\bkmkend AAAAAAACKV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 142 of file aplus.h.}\par
}
{\xe \v edx\:regs}
{\xe \v regs\:edx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} regs::edx}}
\par
{\bkmkstart AAAAAAACKW}
{\bkmkend AAAAAAACKW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 142 of file aplus.h.}\par
}
{\xe \v eflags\:regs}
{\xe \v regs\:eflags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} regs::eflags}}
\par
{\bkmkstart AAAAAAACKX}
{\bkmkend AAAAAAACKX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 142 of file aplus.h.}\par
}
{\xe \v eip\:regs}
{\xe \v regs\:eip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} regs::eip}}
\par
{\bkmkstart AAAAAAACKY}
{\bkmkend AAAAAAACKY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 142 of file aplus.h.}\par
}
{\xe \v err_code\:regs}
{\xe \v regs\:err_code}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} regs::err_code}}
\par
{\bkmkstart AAAAAAACKZ}
{\bkmkend AAAAAAACKZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 142 of file aplus.h.}\par
}
{\xe \v es\:regs}
{\xe \v regs\:es}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} regs::es}}
\par
{\bkmkstart AAAAAAACLA}
{\bkmkend AAAAAAACLA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 142 of file aplus.h.}\par
}
{\xe \v esi\:regs}
{\xe \v regs\:esi}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} regs::esi}}
\par
{\bkmkstart AAAAAAACLB}
{\bkmkend AAAAAAACLB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 142 of file aplus.h.}\par
}
{\xe \v esp\:regs}
{\xe \v regs\:esp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} regs::esp}}
\par
{\bkmkstart AAAAAAACLC}
{\bkmkend AAAAAAACLC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 142 of file aplus.h.}\par
}
{\xe \v fs\:regs}
{\xe \v regs\:fs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} regs::fs}}
\par
{\bkmkstart AAAAAAACLD}
{\bkmkend AAAAAAACLD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 142 of file aplus.h.}\par
}
{\xe \v gs\:regs}
{\xe \v regs\:gs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} regs::gs}}
\par
{\bkmkstart AAAAAAACLE}
{\bkmkend AAAAAAACLE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 142 of file aplus.h.}\par
}
{\xe \v int_no\:regs}
{\xe \v regs\:int_no}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} regs::int_no}}
\par
{\bkmkstart AAAAAAACLF}
{\bkmkend AAAAAAACLF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 142 of file aplus.h.}\par
}
{\xe \v useresp\:regs}
{\xe \v regs\:useresp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} regs::useresp}}
\par
{\bkmkstart AAAAAAACLG}
{\bkmkend AAAAAAACLG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 142 of file aplus.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
src/include/{\b aplus.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
slirpcard Struct Reference\par \pard\plain 
{\tc\tcl2 \v slirpcard}
{\xe \v slirpcard}
{\bkmkstart AAAAAAACLH}
{\bkmkend AAAAAAACLH}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b magic}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} * {\b buffer}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b used}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b offset}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ioport}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b netif_t} * {\b netif}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 16 of file slirp.c.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v buffer\:slirpcard}
{\xe \v slirpcard\:buffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t}* slirpcard::buffer}}
\par
{\bkmkstart AAAAAAACLI}
{\bkmkend AAAAAAACLI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 18 of file slirp.c.}\par
}
{\xe \v ioport\:slirpcard}
{\xe \v slirpcard\:ioport}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int slirpcard::ioport}}
\par
{\bkmkstart AAAAAAACLJ}
{\bkmkend AAAAAAACLJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 22 of file slirp.c.}\par
}
{\xe \v magic\:slirpcard}
{\xe \v slirpcard\:magic}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} slirpcard::magic}}
\par
{\bkmkstart AAAAAAACLK}
{\bkmkend AAAAAAACLK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 17 of file slirp.c.}\par
}
{\xe \v netif\:slirpcard}
{\xe \v slirpcard\:netif}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b netif_t}* slirpcard::netif}}
\par
{\bkmkstart AAAAAAACLL}
{\bkmkend AAAAAAACLL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 23 of file slirp.c.}\par
}
{\xe \v offset\:slirpcard}
{\xe \v slirpcard\:offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int slirpcard::offset}}
\par
{\bkmkstart AAAAAAACLM}
{\bkmkend AAAAAAACLM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 21 of file slirp.c.}\par
}
{\xe \v used\:slirpcard}
{\xe \v slirpcard\:used}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} slirpcard::used}}
\par
{\bkmkstart AAAAAAACLN}
{\bkmkend AAAAAAACLN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 19 of file slirp.c.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
src/net/slirp/{\b slirp.c}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
task Struct Reference\par \pard\plain 
{\tc\tcl2 \v task}
{\xe \v task}
{\bkmkstart AAAAAAACLO}
{\bkmkend AAAAAAACLO}
\par
{
{\f2 #include <task.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
pid_t {\b pid}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct \{\par

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ task_env_t * {\b env}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ {\b uint32_t} {\b stack}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ {\b uint32_t} {\b cr3}\par
}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\} {\b context}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uid_t {\b uid}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gid_t {\b gid}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b inode_t} * {\b cwd}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b inode_t} * {\b exe}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b inode_t} * {\b fd} [{\b TASK_MAX_FD}]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct \{\par

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ {\b uint32_t} {\b vaddr}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ {\b uint32_t} {\b ptr}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ {\b uint32_t} {\b length}\par
}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\} {\b image}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void(* {\b signal_handler} )(int)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b signal_sig}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char ** {\b argv}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char ** {\b envp}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b state}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b priority}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b clock}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b exitcode}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b task} * {\b parent}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 72 of file task.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v argv\:task}
{\xe \v task\:argv}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char** task::argv}}
\par
{\bkmkstart AAAAAAACLP}
{\bkmkend AAAAAAACLP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 99 of file task.h.}\par
}
{\xe \v clock\:task}
{\xe \v task\:clock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} task::clock}}
\par
{\bkmkstart AAAAAAACLQ}
{\bkmkend AAAAAAACLQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 104 of file task.h.}\par
}
{\xe \v context\:task}
{\xe \v task\:context}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct \{ ... \}   task::context}}
\par
{\bkmkstart AAAAAAACLR}
{\bkmkend AAAAAAACLR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v cr3\:task}
{\xe \v task\:cr3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} task::cr3}}
\par
{\bkmkstart AAAAAAACLS}
{\bkmkend AAAAAAACLS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 78 of file task.h.}\par
}
{\xe \v cwd\:task}
{\xe \v task\:cwd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b inode_t}* task::cwd}}
\par
{\bkmkstart AAAAAAACLT}
{\bkmkend AAAAAAACLT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 85 of file task.h.}\par
}
{\xe \v env\:task}
{\xe \v task\:env}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
task_env_t* task::env}}
\par
{\bkmkstart AAAAAAACLU}
{\bkmkend AAAAAAACLU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 76 of file task.h.}\par
}
{\xe \v envp\:task}
{\xe \v task\:envp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char** task::envp}}
\par
{\bkmkstart AAAAAAACLV}
{\bkmkend AAAAAAACLV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 100 of file task.h.}\par
}
{\xe \v exe\:task}
{\xe \v task\:exe}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b inode_t}* task::exe}}
\par
{\bkmkstart AAAAAAACLW}
{\bkmkend AAAAAAACLW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 86 of file task.h.}\par
}
{\xe \v exitcode\:task}
{\xe \v task\:exitcode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int task::exitcode}}
\par
{\bkmkstart AAAAAAACLX}
{\bkmkend AAAAAAACLX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 105 of file task.h.}\par
}
{\xe \v fd\:task}
{\xe \v task\:fd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b inode_t}* task::fd[{\b TASK_MAX_FD}]}}
\par
{\bkmkstart AAAAAAACLY}
{\bkmkend AAAAAAACLY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 87 of file task.h.}\par
}
{\xe \v gid\:task}
{\xe \v task\:gid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
gid_t task::gid}}
\par
{\bkmkstart AAAAAAACLZ}
{\bkmkend AAAAAAACLZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 83 of file task.h.}\par
}
{\xe \v image\:task}
{\xe \v task\:image}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct \{ ... \}   task::image}}
\par
{\bkmkstart AAAAAAACMA}
{\bkmkend AAAAAAACMA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v length\:task}
{\xe \v task\:length}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} task::length}}
\par
{\bkmkstart AAAAAAACMB}
{\bkmkend AAAAAAACMB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 92 of file task.h.}\par
}
{\xe \v parent\:task}
{\xe \v task\:parent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b task}* task::parent}}
\par
{\bkmkstart AAAAAAACMC}
{\bkmkend AAAAAAACMC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 108 of file task.h.}\par
}
{\xe \v pid\:task}
{\xe \v task\:pid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
pid_t task::pid}}
\par
{\bkmkstart AAAAAAACMD}
{\bkmkend AAAAAAACMD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 73 of file task.h.}\par
}
{\xe \v priority\:task}
{\xe \v task\:priority}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} task::priority}}
\par
{\bkmkstart AAAAAAACME}
{\bkmkend AAAAAAACME}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 103 of file task.h.}\par
}
{\xe \v ptr\:task}
{\xe \v task\:ptr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} task::ptr}}
\par
{\bkmkstart AAAAAAACMF}
{\bkmkend AAAAAAACMF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 91 of file task.h.}\par
}
{\xe \v signal_handler\:task}
{\xe \v task\:signal_handler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void(* task::signal_handler)(int)}}
\par
{\bkmkstart AAAAAAACMG}
{\bkmkend AAAAAAACMG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 95 of file task.h.}\par
}
{\xe \v signal_sig\:task}
{\xe \v task\:signal_sig}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int task::signal_sig}}
\par
{\bkmkstart AAAAAAACMH}
{\bkmkend AAAAAAACMH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 96 of file task.h.}\par
}
{\xe \v stack\:task}
{\xe \v task\:stack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} task::stack}}
\par
{\bkmkstart AAAAAAACMI}
{\bkmkend AAAAAAACMI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 77 of file task.h.}\par
}
{\xe \v state\:task}
{\xe \v task\:state}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} task::state}}
\par
{\bkmkstart AAAAAAACMJ}
{\bkmkend AAAAAAACMJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 102 of file task.h.}\par
}
{\xe \v uid\:task}
{\xe \v task\:uid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uid_t task::uid}}
\par
{\bkmkstart AAAAAAACMK}
{\bkmkend AAAAAAACMK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 82 of file task.h.}\par
}
{\xe \v vaddr\:task}
{\xe \v task\:vaddr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} task::vaddr}}
\par
{\bkmkstart AAAAAAACML}
{\bkmkend AAAAAAACML}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 90 of file task.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
src/include/aplus/{\b task.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
task_env Struct Reference\par \pard\plain 
{\tc\tcl2 \v task_env}
{\xe \v task_env}
{\bkmkstart AAAAAAACMM}
{\bkmkend AAAAAAACMM}
\par
{
{\f2 #include <task.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b edi}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b esi}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b ebx}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b ecx}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b eax}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b edx}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b eflags}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b ebp}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b eip}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 59 of file task.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v eax\:task_env}
{\xe \v task_env\:eax}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} task_env::eax}}
\par
{\bkmkstart AAAAAAACMN}
{\bkmkend AAAAAAACMN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 64 of file task.h.}\par
}
{\xe \v ebp\:task_env}
{\xe \v task_env\:ebp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} task_env::ebp}}
\par
{\bkmkstart AAAAAAACMO}
{\bkmkend AAAAAAACMO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 67 of file task.h.}\par
}
{\xe \v ebx\:task_env}
{\xe \v task_env\:ebx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} task_env::ebx}}
\par
{\bkmkstart AAAAAAACMP}
{\bkmkend AAAAAAACMP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 62 of file task.h.}\par
}
{\xe \v ecx\:task_env}
{\xe \v task_env\:ecx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} task_env::ecx}}
\par
{\bkmkstart AAAAAAACMQ}
{\bkmkend AAAAAAACMQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 63 of file task.h.}\par
}
{\xe \v edi\:task_env}
{\xe \v task_env\:edi}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} task_env::edi}}
\par
{\bkmkstart AAAAAAACMR}
{\bkmkend AAAAAAACMR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 60 of file task.h.}\par
}
{\xe \v edx\:task_env}
{\xe \v task_env\:edx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} task_env::edx}}
\par
{\bkmkstart AAAAAAACMS}
{\bkmkend AAAAAAACMS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 65 of file task.h.}\par
}
{\xe \v eflags\:task_env}
{\xe \v task_env\:eflags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} task_env::eflags}}
\par
{\bkmkstart AAAAAAACMT}
{\bkmkend AAAAAAACMT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 66 of file task.h.}\par
}
{\xe \v eip\:task_env}
{\xe \v task_env\:eip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} task_env::eip}}
\par
{\bkmkstart AAAAAAACMU}
{\bkmkend AAAAAAACMU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 68 of file task.h.}\par
}
{\xe \v esi\:task_env}
{\xe \v task_env\:esi}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} task_env::esi}}
\par
{\bkmkstart AAAAAAACMV}
{\bkmkend AAAAAAACMV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 61 of file task.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
src/include/aplus/{\b task.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
udp_header Struct Reference\par \pard\plain 
{\tc\tcl2 \v udp_header}
{\xe \v udp_header}
{\bkmkstart AAAAAAACMW}
{\bkmkend AAAAAAACMW}
\par
{
{\f2 #include <udp.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b src_port}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b dst_port}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b length}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b checksum}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 7 of file udp.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v checksum\:udp_header}
{\xe \v udp_header\:checksum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} udp_header::checksum}}
\par
{\bkmkstart AAAAAAACMX}
{\bkmkend AAAAAAACMX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 11 of file udp.h.}\par
}
{\xe \v dst_port\:udp_header}
{\xe \v udp_header\:dst_port}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} udp_header::dst_port}}
\par
{\bkmkstart AAAAAAACMY}
{\bkmkend AAAAAAACMY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9 of file udp.h.}\par
}
{\xe \v length\:udp_header}
{\xe \v udp_header\:length}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} udp_header::length}}
\par
{\bkmkstart AAAAAAACMZ}
{\bkmkend AAAAAAACMZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 10 of file udp.h.}\par
}
{\xe \v src_port\:udp_header}
{\xe \v udp_header\:src_port}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} udp_header::src_port}}
\par
{\bkmkstart AAAAAAACNA}
{\bkmkend AAAAAAACNA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 8 of file udp.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
src/include/aplus/net/{\b udp.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
vesaInfo_t Struct Reference\par \pard\plain 
{\tc\tcl2 \v vesaInfo_t}
{\xe \v vesaInfo_t}
{\bkmkstart AAAAAAACNB}
{\bkmkend AAAAAAACNB}
\par
{
{\f2 #include <grub.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b signature} [4]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b version}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b oem_string_ptr}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b capabilities}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b video_mode_ptr}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b total_memory}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b oem_software_rev}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b oem_vendor_name}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b oem_product_name}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b oem_product_rev}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 26 of file grub.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v capabilities\:vesaInfo_t}
{\xe \v vesaInfo_t\:capabilities}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int vesaInfo_t::capabilities}}
\par
{\bkmkstart AAAAAAACNC}
{\bkmkend AAAAAAACNC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 30 of file grub.h.}\par
}
{\xe \v oem_product_name\:vesaInfo_t}
{\xe \v vesaInfo_t\:oem_product_name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* vesaInfo_t::oem_product_name}}
\par
{\bkmkstart AAAAAAACND}
{\bkmkend AAAAAAACND}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 35 of file grub.h.}\par
}
{\xe \v oem_product_rev\:vesaInfo_t}
{\xe \v vesaInfo_t\:oem_product_rev}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* vesaInfo_t::oem_product_rev}}
\par
{\bkmkstart AAAAAAACNE}
{\bkmkend AAAAAAACNE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 36 of file grub.h.}\par
}
{\xe \v oem_software_rev\:vesaInfo_t}
{\xe \v vesaInfo_t\:oem_software_rev}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int vesaInfo_t::oem_software_rev}}
\par
{\bkmkstart AAAAAAACNF}
{\bkmkend AAAAAAACNF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 33 of file grub.h.}\par
}
{\xe \v oem_string_ptr\:vesaInfo_t}
{\xe \v vesaInfo_t\:oem_string_ptr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int vesaInfo_t::oem_string_ptr}}
\par
{\bkmkstart AAAAAAACNG}
{\bkmkend AAAAAAACNG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 29 of file grub.h.}\par
}
{\xe \v oem_vendor_name\:vesaInfo_t}
{\xe \v vesaInfo_t\:oem_vendor_name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* vesaInfo_t::oem_vendor_name}}
\par
{\bkmkstart AAAAAAACNH}
{\bkmkend AAAAAAACNH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 34 of file grub.h.}\par
}
{\xe \v signature\:vesaInfo_t}
{\xe \v vesaInfo_t\:signature}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char vesaInfo_t::signature[4]}}
\par
{\bkmkstart AAAAAAACNI}
{\bkmkend AAAAAAACNI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 27 of file grub.h.}\par
}
{\xe \v total_memory\:vesaInfo_t}
{\xe \v vesaInfo_t\:total_memory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short vesaInfo_t::total_memory}}
\par
{\bkmkstart AAAAAAACNJ}
{\bkmkend AAAAAAACNJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 32 of file grub.h.}\par
}
{\xe \v version\:vesaInfo_t}
{\xe \v vesaInfo_t\:version}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short vesaInfo_t::version}}
\par
{\bkmkstart AAAAAAACNK}
{\bkmkend AAAAAAACNK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 28 of file grub.h.}\par
}
{\xe \v video_mode_ptr\:vesaInfo_t}
{\xe \v vesaInfo_t\:video_mode_ptr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int vesaInfo_t::video_mode_ptr}}
\par
{\bkmkstart AAAAAAACNL}
{\bkmkend AAAAAAACNL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 31 of file grub.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
src/include/{\b grub.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
vesaModeInfo_t Struct Reference\par \pard\plain 
{\tc\tcl2 \v vesaModeInfo_t}
{\xe \v vesaModeInfo_t}
{\bkmkstart AAAAAAACNM}
{\bkmkend AAAAAAACNM}
\par
{
{\f2 #include <grub.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b attributes}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b winA}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b winB}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b granularity}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b winsize}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b segmentA}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b segmentB}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b realFctPtr}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b pitch}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b Xres}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b Yres}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b Wchar}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b Ychar}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b planes}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b bpp}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b banks}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b memory_model}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b bank_size}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b image_pages}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b reserved0}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b red_mask}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b red_position}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b green_mask}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b green_position}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b blue_mask}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b blue_position}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b rsv_mask}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b rsv_position}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b directcolor_attributes}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b physbase}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b reserved1}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
short {\b reserved2}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 39 of file grub.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v attributes\:vesaModeInfo_t}
{\xe \v vesaModeInfo_t\:attributes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short vesaModeInfo_t::attributes}}
\par
{\bkmkstart AAAAAAACNN}
{\bkmkend AAAAAAACNN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 40 of file grub.h.}\par
}
{\xe \v bank_size\:vesaModeInfo_t}
{\xe \v vesaModeInfo_t\:bank_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char vesaModeInfo_t::bank_size}}
\par
{\bkmkstart AAAAAAACNO}
{\bkmkend AAAAAAACNO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 50 of file grub.h.}\par
}
{\xe \v banks\:vesaModeInfo_t}
{\xe \v vesaModeInfo_t\:banks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char vesaModeInfo_t::banks}}
\par
{\bkmkstart AAAAAAACNP}
{\bkmkend AAAAAAACNP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 49 of file grub.h.}\par
}
{\xe \v blue_mask\:vesaModeInfo_t}
{\xe \v vesaModeInfo_t\:blue_mask}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char vesaModeInfo_t::blue_mask}}
\par
{\bkmkstart AAAAAAACNQ}
{\bkmkend AAAAAAACNQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 55 of file grub.h.}\par
}
{\xe \v blue_position\:vesaModeInfo_t}
{\xe \v vesaModeInfo_t\:blue_position}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char vesaModeInfo_t::blue_position}}
\par
{\bkmkstart AAAAAAACNR}
{\bkmkend AAAAAAACNR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 55 of file grub.h.}\par
}
{\xe \v bpp\:vesaModeInfo_t}
{\xe \v vesaModeInfo_t\:bpp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char vesaModeInfo_t::bpp}}
\par
{\bkmkstart AAAAAAACNS}
{\bkmkend AAAAAAACNS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 49 of file grub.h.}\par
}
{\xe \v directcolor_attributes\:vesaModeInfo_t}
{\xe \v vesaModeInfo_t\:directcolor_attributes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char vesaModeInfo_t::directcolor_attributes}}
\par
{\bkmkstart AAAAAAACNT}
{\bkmkend AAAAAAACNT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 57 of file grub.h.}\par
}
{\xe \v granularity\:vesaModeInfo_t}
{\xe \v vesaModeInfo_t\:granularity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short vesaModeInfo_t::granularity}}
\par
{\bkmkstart AAAAAAACNU}
{\bkmkend AAAAAAACNU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 42 of file grub.h.}\par
}
{\xe \v green_mask\:vesaModeInfo_t}
{\xe \v vesaModeInfo_t\:green_mask}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char vesaModeInfo_t::green_mask}}
\par
{\bkmkstart AAAAAAACNV}
{\bkmkend AAAAAAACNV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 54 of file grub.h.}\par
}
{\xe \v green_position\:vesaModeInfo_t}
{\xe \v vesaModeInfo_t\:green_position}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char vesaModeInfo_t::green_position}}
\par
{\bkmkstart AAAAAAACNW}
{\bkmkend AAAAAAACNW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 54 of file grub.h.}\par
}
{\xe \v image_pages\:vesaModeInfo_t}
{\xe \v vesaModeInfo_t\:image_pages}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char vesaModeInfo_t::image_pages}}
\par
{\bkmkstart AAAAAAACNX}
{\bkmkend AAAAAAACNX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 50 of file grub.h.}\par
}
{\xe \v memory_model\:vesaModeInfo_t}
{\xe \v vesaModeInfo_t\:memory_model}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char vesaModeInfo_t::memory_model}}
\par
{\bkmkstart AAAAAAACNY}
{\bkmkend AAAAAAACNY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 50 of file grub.h.}\par
}
{\xe \v physbase\:vesaModeInfo_t}
{\xe \v vesaModeInfo_t\:physbase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int vesaModeInfo_t::physbase}}
\par
{\bkmkstart AAAAAAACNZ}
{\bkmkend AAAAAAACNZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 59 of file grub.h.}\par
}
{\xe \v pitch\:vesaModeInfo_t}
{\xe \v vesaModeInfo_t\:pitch}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short vesaModeInfo_t::pitch}}
\par
{\bkmkstart AAAAAAACOA}
{\bkmkend AAAAAAACOA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 46 of file grub.h.}\par
}
{\xe \v planes\:vesaModeInfo_t}
{\xe \v vesaModeInfo_t\:planes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char vesaModeInfo_t::planes}}
\par
{\bkmkstart AAAAAAACOB}
{\bkmkend AAAAAAACOB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 49 of file grub.h.}\par
}
{\xe \v realFctPtr\:vesaModeInfo_t}
{\xe \v vesaModeInfo_t\:realFctPtr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int vesaModeInfo_t::realFctPtr}}
\par
{\bkmkstart AAAAAAACOC}
{\bkmkend AAAAAAACOC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 45 of file grub.h.}\par
}
{\xe \v red_mask\:vesaModeInfo_t}
{\xe \v vesaModeInfo_t\:red_mask}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char vesaModeInfo_t::red_mask}}
\par
{\bkmkstart AAAAAAACOD}
{\bkmkend AAAAAAACOD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 53 of file grub.h.}\par
}
{\xe \v red_position\:vesaModeInfo_t}
{\xe \v vesaModeInfo_t\:red_position}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char vesaModeInfo_t::red_position}}
\par
{\bkmkstart AAAAAAACOE}
{\bkmkend AAAAAAACOE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 53 of file grub.h.}\par
}
{\xe \v reserved0\:vesaModeInfo_t}
{\xe \v vesaModeInfo_t\:reserved0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char vesaModeInfo_t::reserved0}}
\par
{\bkmkstart AAAAAAACOF}
{\bkmkend AAAAAAACOF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 51 of file grub.h.}\par
}
{\xe \v reserved1\:vesaModeInfo_t}
{\xe \v vesaModeInfo_t\:reserved1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int vesaModeInfo_t::reserved1}}
\par
{\bkmkstart AAAAAAACOG}
{\bkmkend AAAAAAACOG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 60 of file grub.h.}\par
}
{\xe \v reserved2\:vesaModeInfo_t}
{\xe \v vesaModeInfo_t\:reserved2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
short vesaModeInfo_t::reserved2}}
\par
{\bkmkstart AAAAAAACOH}
{\bkmkend AAAAAAACOH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 61 of file grub.h.}\par
}
{\xe \v rsv_mask\:vesaModeInfo_t}
{\xe \v vesaModeInfo_t\:rsv_mask}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char vesaModeInfo_t::rsv_mask}}
\par
{\bkmkstart AAAAAAACOI}
{\bkmkend AAAAAAACOI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 56 of file grub.h.}\par
}
{\xe \v rsv_position\:vesaModeInfo_t}
{\xe \v vesaModeInfo_t\:rsv_position}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char vesaModeInfo_t::rsv_position}}
\par
{\bkmkstart AAAAAAACOJ}
{\bkmkend AAAAAAACOJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 56 of file grub.h.}\par
}
{\xe \v segmentA\:vesaModeInfo_t}
{\xe \v vesaModeInfo_t\:segmentA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short vesaModeInfo_t::segmentA}}
\par
{\bkmkstart AAAAAAACOK}
{\bkmkend AAAAAAACOK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 44 of file grub.h.}\par
}
{\xe \v segmentB\:vesaModeInfo_t}
{\xe \v vesaModeInfo_t\:segmentB}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short vesaModeInfo_t::segmentB}}
\par
{\bkmkstart AAAAAAACOL}
{\bkmkend AAAAAAACOL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 44 of file grub.h.}\par
}
{\xe \v Wchar\:vesaModeInfo_t}
{\xe \v vesaModeInfo_t\:Wchar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char vesaModeInfo_t::Wchar}}
\par
{\bkmkstart AAAAAAACOM}
{\bkmkend AAAAAAACOM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 49 of file grub.h.}\par
}
{\xe \v winA\:vesaModeInfo_t}
{\xe \v vesaModeInfo_t\:winA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char vesaModeInfo_t::winA}}
\par
{\bkmkstart AAAAAAACON}
{\bkmkend AAAAAAACON}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 41 of file grub.h.}\par
}
{\xe \v winB\:vesaModeInfo_t}
{\xe \v vesaModeInfo_t\:winB}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char vesaModeInfo_t::winB}}
\par
{\bkmkstart AAAAAAACOO}
{\bkmkend AAAAAAACOO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 41 of file grub.h.}\par
}
{\xe \v winsize\:vesaModeInfo_t}
{\xe \v vesaModeInfo_t\:winsize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short vesaModeInfo_t::winsize}}
\par
{\bkmkstart AAAAAAACOP}
{\bkmkend AAAAAAACOP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 43 of file grub.h.}\par
}
{\xe \v Xres\:vesaModeInfo_t}
{\xe \v vesaModeInfo_t\:Xres}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short vesaModeInfo_t::Xres}}
\par
{\bkmkstart AAAAAAACOQ}
{\bkmkend AAAAAAACOQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 48 of file grub.h.}\par
}
{\xe \v Ychar\:vesaModeInfo_t}
{\xe \v vesaModeInfo_t\:Ychar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char vesaModeInfo_t::Ychar}}
\par
{\bkmkstart AAAAAAACOR}
{\bkmkend AAAAAAACOR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 49 of file grub.h.}\par
}
{\xe \v Yres\:vesaModeInfo_t}
{\xe \v vesaModeInfo_t\:Yres}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short vesaModeInfo_t::Yres}}
\par
{\bkmkstart AAAAAAACOS}
{\bkmkend AAAAAAACOS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 48 of file grub.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
src/include/{\b grub.h}\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Documentation{\tc \v File Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
initrd/test.c File Reference\par \pard\plain 
{\tc\tcl2 \v initrd/test.c}
{\xe \v initrd/test.c}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} (int argc, char **argv)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v main\:initrd/test.c}
{\xe \v initrd/test.c\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main (int {\i argc}, char ** {\i argv})}}
\par
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 4 of file test.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4                                 \{\par
5     printf("Hello World");\par
6 \par
7     return 0;\par
8 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/syscall/test.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/syscall/test.c}
{\xe \v src/syscall/test.c}
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <aplus.h>}\par
{\f2 #include <aplus/syscall.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sys_test} (int p0, int p1)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSCALL} ({\b sys_test}, 1000)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v sys_test\:src/syscall/test.c}
{\xe \v src/syscall/test.c\:sys_test}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int sys_test (int {\i p0}, int {\i p1})}}
\par
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 4 of file test.c.}\par
{
References kprintf().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4                              \{\par
5     kprintf("sys_test called with (p0: %d; p1: %d)\\n", p0, p1);\par
6 \par
7     return 255;\par
8 \}\par
}
}
{\xe \v SYSCALL\:src/syscall/test.c}
{\xe \v src/syscall/test.c\:SYSCALL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SYSCALL ({\b sys_test} , 1000 )}}
\par
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
README.md File Reference\par \pard\plain 
{\tc\tcl2 \v README.md}
{\xe \v README.md}
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
usr/src/libposix/README.md File Reference\par \pard\plain 
{\tc\tcl2 \v usr/src/libposix/README.md}
{\xe \v usr/src/libposix/README.md}
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
usr/src/libpthread/README.md File Reference\par \pard\plain 
{\tc\tcl2 \v usr/src/libpthread/README.md}
{\xe \v usr/src/libpthread/README.md}
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/arch/desc.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/arch/desc.c}
{\xe \v src/arch/desc.c}
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <aplus.h>}\par
{\f2 #include <aplus/spinlock.h>}\par
{\f2 #include <aplus/mm.h>}\par
{\f2 #include <grub.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <errno.h>}\par
{\f2 #include <time.h>}\par
{\f2 #include <sys/times.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b gdt_entry}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b FAULT_MASK}\~ 0x3FFFFFE3\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PIT_FREQ}\~ (CLOCKS_PER_SEC)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b gdt_set}(n, b, l, a, g)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b idt_set}(i, b, s, f)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _i}(n)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _i}(n)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BCD2BIN}(bcd)\~ ((((bcd) & 0x0F) + ((bcd) / 16) * 10))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BCD2BIN2}(bcd)\~ (((((bcd) & 0x0F) + ((bcd & 0x70) / 16) * 10)) | (bcd & 0x80))\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b gdt_entry} {\b __attribute__} ((packed))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b schedule} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Perform a scheduling and check TTL (Time To Live) for current task. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b syscall_handler} (regs_t *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b __asm__} (".section .text		\\n\\
	.global gdt_load	\\n\\
	gdt_load:			\\n\\
	lgdt [{\b gdt_p}]		\\n\\
						\\n\\
	mov ax, 0x10		\\n\\
	mov ds, ax			\\n\\
	mov es, ax			\\n\\
	mov fs, ax			\\n\\
	mov gs, ax			\\n\\
	mov ss, ax			\\n\\
	jmp 0x08:.done		\\n\\
						\\n\\
	.done:				\\n\\
	ret					\\n\\
						\\n\\
						\\n\\
						\\n\\
						\\n\\
	.global idt_load	\\n\\
	idt_load:			\\n\\
	lidt [idt_p]		\\n\\
	ret					\\n\\
						\\n\\
						\\n")\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b isr_handler} (regs_t *r)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b irq_handler} (regs_t *r)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b pit_handler} (regs_t *r)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b pagefault_handler} (regs_t *r)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b desc_init} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b irq_set} (int n, void *handler)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b irq_unset} (int n)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b irq_get} (int n)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b uint8_t} {\b rtc} ({\b uint8_t} addr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b pit_gettime} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b pit_getticks} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b limit_l}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b base_l}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b base_m}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b access}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b granularity}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b base_h}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void * {\b irqs} [16] = \{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static gdt_entry_t {\b gdt_e} [5]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static gdt_ptr_t {\b gdt_p}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static idt_entry_t {\b idt_e} [256]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static idt_ptr_t {\b idt_p}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b uint32_t} {\b pit_ticks}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b uint32_t} {\b pit_seconds}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b uint32_t} {\b pit_days}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b keyboard_ready} = 0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v _i\:desc.c}
{\xe \v desc.c\:_i}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _i( n)}}
\par
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid extern void isr##n();                       \\\par
        idt_set(n, (uint32_t)isr##n, 0x08, 0x8E)\par
}
}
{\xe \v _i\:desc.c}
{\xe \v desc.c\:_i}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _i( n)}}
\par
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid extern void irq##n();                           \\\par
        idt_set(n + 32, (uint32_t)irq##n, 0x08, 0x8E)\par
}
}
{\xe \v BCD2BIN\:desc.c}
{\xe \v desc.c\:BCD2BIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BCD2BIN( bcd)\~ ((((bcd) & 0x0F) + ((bcd) / 16) * 10))}}
\par
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v BCD2BIN2\:desc.c}
{\xe \v desc.c\:BCD2BIN2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BCD2BIN2( bcd)\~ (((((bcd) & 0x0F) + ((bcd & 0x70) / 16) * 10)) | (bcd & 0x80))}}
\par
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v FAULT_MASK\:desc.c}
{\xe \v desc.c\:FAULT_MASK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define FAULT_MASK\~ 0x3FFFFFE3}}
\par
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 37 of file desc.c.}\par
}
{\xe \v gdt_set\:desc.c}
{\xe \v desc.c\:gdt_set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define gdt_set( n,  b,  l,  a,  g)}}
\par
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid gdt_e[n].base_l = (b & 0xFFFF);             \\\par
        gdt_e[n].base_m = (b >> 16) & 0xFF;         \\\par
        gdt_e[n].base_h = (b >> 24) & 0xFF;         \\\par
        gdt_e[n].limit_l = (l & 0xFFFF);            \\\par
        gdt_e[n].granularity = (l >> 16) & 0x0F;    \\\par
        gdt_e[n].granularity |= g & 0xF0;           \\\par
        gdt_e[n].access = a\par
}
}
{\xe \v idt_set\:desc.c}
{\xe \v desc.c\:idt_set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define idt_set( i,  b,  s,  f)}}
\par
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid idt_e[i].base_l = b & 0xFFFF;               \\\par
        idt_e[i].base_h = (b >> 16) & 0xFFFF;       \\\par
        idt_e[i].sel = s;                           \\\par
        idt_e[i].null = 0;                          \\\par
        idt_e[i].flags = f\par
}
}
{\xe \v PIT_FREQ\:desc.c}
{\xe \v desc.c\:PIT_FREQ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PIT_FREQ\~ (CLOCKS_PER_SEC)}}
\par
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 38 of file desc.c.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v __asm__\:desc.c}
{\xe \v desc.c\:__asm__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__asm__ (".section .text \\n\\ .global gdt_load \\n\\ gdt_load: \\n\\ lgdt  \\n\\ \\n\\ mov {\i ax}[gdt_p], 0x10\\n\\mov {\i ds}, ax\\n\\mov {\i es}, ax\\n\\mov {\i fs}, ax\\n\\mov {\i gs}, ax\\n\\mov {\i ss}, ax\\n\\jmp 0x08:.done\\n\\\\n\\.done:\\n\\ret\\n\\\\n\\\\n\\\\n\\\\n\\.global idt_load\\n\\idt_load:\\n\\lidt\\n\\ret\\n\\\\n\\\\n" [idt_p])}}
\par
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v __attribute__\:desc.c}
{\xe \v desc.c\:__attribute__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b iso9660_dir} __attribute__ ((packed) )}}
\par
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 44 of file desc.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 46                        \{\par
47     uint16_t limit;\par
48     uint32_t base;\par
49 \} __attribute__((packed)) gdt_ptr_t;\par
}
}
{\xe \v desc_init\:desc.c}
{\xe \v desc.c\:desc_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int desc_init ()}}
\par
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 195 of file desc.c.}\par
{
References __asm__(), _i, gdt_set, irq_set(), PIT_FREQ, pit_handler(), uint32_t, and uint8_t.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 195                 \{\par
196 \par
197     __asm__ ("cli");\par
198     \par
199 \par
200     #define gdt_set(n, b, l, a, g)                  \\\par
201         gdt_e[n].base_l = (b & 0xFFFF);             \\\par
202         gdt_e[n].base_m = (b >> 16) & 0xFF;         \\\par
203         gdt_e[n].base_h = (b >> 24) & 0xFF;         \\\par
204         gdt_e[n].limit_l = (l & 0xFFFF);            \\\par
205         gdt_e[n].granularity = (l >> 16) & 0x0F;    \\\par
206         gdt_e[n].granularity |= g & 0xF0;           \\\par
207         gdt_e[n].access = a\par
208                 \par
209     \par
210     memset(&gdt_e, 0, sizeof(gdt_entry_t) * 5);\par
211         \par
212     gdt_p.limit = sizeof(gdt_entry_t) * 5 - 1;\par
213     gdt_p.base = (uint32_t) gdt_e;\par
214         \par
215     gdt_set(0, 0, 0, 0, 0);\par
216     gdt_set(1, 0, 0xFFFFFFFF, 0x9A, 0xCF);\par
217     gdt_set(2, 0, 0xFFFFFFFF, 0x92, 0xCF);\par
218     gdt_set(3, 0, 0xFFFFFFFF, 0xFA, 0xCF);\par
219     gdt_set(4, 0, 0xFFFFFFFF, 0XF2, 0xCF);\par
220 \par
221     \par
222 \par
223     gdt_load();\par
224     \par
225     \par
226     idt_p.limit = sizeof(idt_entry_t) * 256 - 1;\par
227     idt_p.base = (uint32_t) idt_e;\par
228     \par
229     memset(idt_e, 0, sizeof(idt_entry_t) * 256);\par
230     \par
231     \par
232     #define idt_set(i, b, s, f)                     \\\par
233         idt_e[i].base_l = b & 0xFFFF;               \\\par
234         idt_e[i].base_h = (b >> 16) & 0xFFFF;       \\\par
235         idt_e[i].sel = s;                           \\\par
236         idt_e[i].null = 0;                          \\\par
237         idt_e[i].flags = f\par
238     \par
239     \par
240     #define _i(n)                                   \\\par
241         extern void isr##n();                       \\\par
242         idt_set(n, (uint32_t)isr##n, 0x08, 0x8E)\par
243         \par
244     _i(0);\par
245     _i(1);\par
246     _i(2);\par
247     _i(3);\par
248     _i(4);\par
249     _i(5);\par
250     _i(6);\par
251     _i(7);\par
252     _i(8);\par
253     _i(9);\par
254     _i(10);\par
255     _i(11);\par
256     _i(12);\par
257     _i(13);\par
258     _i(14);\par
259     _i(15);\par
260     _i(16);\par
261     _i(17);\par
262     _i(18);\par
263     _i(19);\par
264     _i(20);\par
265     _i(21);\par
266     _i(22);\par
267     _i(23);\par
268     _i(24);\par
269     _i(25);\par
270     _i(26);\par
271     _i(27);\par
272     _i(28);\par
273     _i(29);\par
274     _i(30);\par
275     _i(31);\par
276     _i(0x80);\par
277 \par
278     \par
279     idt_load();\par
280 \par
281     \par
282     #ifdef _i\par
283     #undef _i\par
284     #endif\par
285     \par
286     #define _i(n)                                       \\\par
287         extern void irq##n();                           \\\par
288         idt_set(n + 32, (uint32_t)irq##n, 0x08, 0x8E)\par
289         \par
290     \par
291     outb(0x20, 0x11);\par
292     outb(0xA0, 0x11);\par
293     outb(0x21, 0x20);\par
294     outb(0xA1, 0x28);\par
295     outb(0x21, 0x04);\par
296     outb(0xA1, 0x02);\par
297     outb(0x21, 0x01);\par
298     outb(0xA1, 0x01);\par
299     outb(0x21, 0x00);\par
300     outb(0xA1, 0x00);\par
301     \par
302     _i(0);\par
303     _i(1);\par
304     _i(2);\par
305     _i(3);\par
306     _i(4);\par
307     _i(5);\par
308     _i(6);\par
309     _i(7);\par
310     _i(8);\par
311     _i(9);\par
312     _i(10);\par
313     _i(11);\par
314     _i(12);\par
315     _i(13);\par
316     _i(14);\par
317     _i(15);\par
318     \par
319     \par
320     uint32_t freq = 1193180 / PIT_FREQ;\par
321     outb(0x43, 0x36);\par
322     outb(0x40, (uint8_t) (freq & 0xFF));\par
323     outb(0x40, (uint8_t) ((freq >> 8) & 0xFF));\par
324     \par
325     irq_set(0, (void*) pit_handler);\par
326     \par
327     __asm__ ("sti");\par
328 \par
329     return 0;\par
330 \}\par
}
}
{\xe \v irq_get\:desc.c}
{\xe \v desc.c\:irq_get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* irq_get (int {\i n})}}
\par
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 354 of file desc.c.}\par
{
References errno.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 354                      \{\par
355     if(n > 16) \{\par
356         errno = EINVAL;\par
357         return NULL;\par
358     \}\par
359     \par
360     return irqs[n];\par
361 \}\par
}
}
{\xe \v irq_handler\:desc.c}
{\xe \v desc.c\:irq_handler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void irq_handler (regs_t * {\i r})}}
\par
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 155 of file desc.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 155                             \{\par
156 \par
157     if(irqs[r->int_no - 32])\par
158         ((void (*)(regs_t*)) irqs[r->int_no - 32]) (r);\par
159 \par
160     if(r->int_no >= 40)\par
161         outb(0xA0, 0x20);\par
162         \par
163     outb(0x20, 0x20);\par
164 \}\par
}
}
{\xe \v irq_set\:desc.c}
{\xe \v desc.c\:irq_set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int irq_set (int {\i n}, void * {\i handler})}}
\par
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 334 of file desc.c.}\par
{
References errno.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 334                                   \{\par
335     if(n > 16) \{\par
336         errno = EINVAL;\par
337         return -1;\par
338     \}\par
339     \par
340     irqs[n] = handler;\par
341     return 0;\par
342 \}\par
}
}
{\xe \v irq_unset\:desc.c}
{\xe \v desc.c\:irq_unset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int irq_unset (int {\i n})}}
\par
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 344 of file desc.c.}\par
{
References errno.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 344                      \{\par
345     if(n > 16) \{\par
346         errno = EINVAL;\par
347         return -1;\par
348     \}\par
349     \par
350     irqs[n] = 0;\par
351     return 0;\par
352 \}\par
}
}
{\xe \v isr_handler\:desc.c}
{\xe \v desc.c\:isr_handler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void isr_handler (regs_t * {\i r})}}
\par
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 151 of file desc.c.}\par
{
References panic().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 151                             \{\par
152     panic(exception_messages[r->int_no]);\par
153 \}\par
}
}
{\xe \v pagefault_handler\:desc.c}
{\xe \v desc.c\:pagefault_handler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void pagefault_handler (regs_t * {\i r})}}
\par
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 183 of file desc.c.}\par
{
References __asm__(), kprintf(), panic(), and uint32_t.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 183                                   \{\par
184     uint32_t faultaddr;\par
185     __asm__ __volatile__("mov eax, cr2" : "=a"(faultaddr));\par
186 \par
187     kprintf("Page fault at address: 0x%x\\n", faultaddr);\par
188     panic("Page Fault");\par
189 \}\par
}
}
{\xe \v pit_getticks\:desc.c}
{\xe \v desc.c\:pit_getticks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} pit_getticks ()}}
\par
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 393 of file desc.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 393                         \{\par
394     return ((pit_days * 86400) * 1000) + (pit_seconds * 1000) + pit_ticks;\par
395 \}\par
}
}
{\xe \v pit_gettime\:desc.c}
{\xe \v desc.c\:pit_gettime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} pit_gettime ()}}
\par
{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 373 of file desc.c.}\par
{
References BCD2BIN, BCD2BIN2, rtc(), and uint32_t.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 373                        \{\par
374 \par
375     #define BCD2BIN(bcd)    ((((bcd) & 0x0F) + ((bcd) / 16) * 10))\par
376     #define BCD2BIN2(bcd)   (((((bcd) & 0x0F) + ((bcd & 0x70) / 16) * 10)) | (bcd & 0x80))\par
377 \par
378     \par
379     static struct tm t;\par
380     t.tm_sec = BCD2BIN(rtc(0));\par
381     t.tm_min = BCD2BIN(rtc(2));\par
382     t.tm_hour = BCD2BIN2(rtc(4)) + 2;\par
383     t.tm_mday = BCD2BIN(rtc(7));\par
384     t.tm_mon = BCD2BIN(rtc(8)) - 1;\par
385     t.tm_year = (BCD2BIN(rtc(9)) + 100);\par
386     t.tm_wday = 0;\par
387     t.tm_yday = 0;\par
388     t.tm_isdst = 0;\par
389     \par
390     return (uint32_t) mktime(&t);\par
391 \}\par
}
}
{\xe \v pit_handler\:desc.c}
{\xe \v desc.c\:pit_handler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void pit_handler (regs_t * {\i r})}}
\par
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 166 of file desc.c.}\par
{
References PIT_FREQ, and schedule().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 166                             \{\par
167     pit_ticks += (1000 / PIT_FREQ);\par
168     \par
169     if(pit_ticks >= 1000) \{\par
170         pit_ticks = 0;\par
171         pit_seconds += 1;\par
172     \}\par
173     \par
174     if(pit_seconds >= 86400) \{\par
175         pit_seconds = 0;\par
176         pit_days += 1;\par
177     \}\par
178     \par
179     schedule();\par
180 \}\par
}
}
{\xe \v rtc\:desc.c}
{\xe \v desc.c\:rtc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b uint8_t} rtc ({\b uint8_t} {\i addr}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 365 of file desc.c.}\par
{
References __asm__(), and uint8_t.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 365                                  \{\par
366     outb(0x70, addr);\par
367     \par
368     uint8_t r = 0;\par
369     __asm__("inb 0x71" : "=a"(r));\par
370     return r;\par
371 \}\par
}
}
{\xe \v schedule\:desc.c}
{\xe \v desc.c\:schedule}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void schedule ()}}
\par
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Perform a scheduling and check TTL (Time To Live) for current task. }}\par
{
Definition at line 133 of file sched.c.}\par
{
References task::clock, list_empty(), task::priority, sched_enabled, schedule_next(), and task_switch().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 133                 \{\par
134     if(sched_enabled == 0)\par
135         return;\par
136         \par
137     if(list_empty(task_queue))\par
138         return;\par
139 \par
140         \par
141     current_task->clock += 1;\par
142     \par
143     if(current_task->clock % current_task->priority)\par
144         return;\par
145         \par
146     task_switch(schedule_next());\par
147 \}\par
}
}
{\xe \v syscall_handler\:desc.c}
{\xe \v desc.c\:syscall_handler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void syscall_handler (regs_t * )}}
\par
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 53 of file syscall.c.}\par
{
References syscall_handlers, and syscall_invoke().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 53                                \{\par
54     return syscall_invoke(syscall_handlers[r->eax], r->ebx, r->ecx, r->edx, r->esi, r->edi);\par
55 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v access\:desc.c}
{\xe \v desc.c\:access}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} access}}
\par
{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 6 of file desc.c.}\par
}
{\xe \v base_h\:desc.c}
{\xe \v desc.c\:base_h}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} base_h}}
\par
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 6 of file desc.c.}\par
}
{\xe \v base_l\:desc.c}
{\xe \v desc.c\:base_l}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} base_l}}
\par
{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 5 of file desc.c.}\par
}
{\xe \v base_m\:desc.c}
{\xe \v desc.c\:base_m}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} base_m}}
\par
{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 6 of file desc.c.}\par
}
{\xe \v gdt_e\:desc.c}
{\xe \v desc.c\:gdt_e}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
gdt_entry_t gdt_e[5]{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 104 of file desc.c.}\par
}
{\xe \v gdt_p\:desc.c}
{\xe \v desc.c\:gdt_p}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
gdt_ptr_t gdt_p{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 105 of file desc.c.}\par
}
{\xe \v granularity\:desc.c}
{\xe \v desc.c\:granularity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} granularity}}
\par
{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 6 of file desc.c.}\par
}
{\xe \v idt_e\:desc.c}
{\xe \v desc.c\:idt_e}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
idt_entry_t idt_e[256]{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 107 of file desc.c.}\par
}
{\xe \v idt_p\:desc.c}
{\xe \v desc.c\:idt_p}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
idt_ptr_t idt_p{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 108 of file desc.c.}\par
}
{\xe \v irqs\:desc.c}
{\xe \v desc.c\:irqs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* irqs[16] = \{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 \}{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 102 of file desc.c.}\par
}
{\xe \v keyboard_ready\:desc.c}
{\xe \v desc.c\:keyboard_ready}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} keyboard_ready = 0}}
\par
{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 115 of file desc.c.}\par
}
{\xe \v limit_l\:desc.c}
{\xe \v desc.c\:limit_l}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} limit_l}}
\par
{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 5 of file desc.c.}\par
}
{\xe \v pit_days\:desc.c}
{\xe \v desc.c\:pit_days}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} pit_days{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 113 of file desc.c.}\par
}
{\xe \v pit_seconds\:desc.c}
{\xe \v desc.c\:pit_seconds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} pit_seconds{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 112 of file desc.c.}\par
}
{\xe \v pit_ticks\:desc.c}
{\xe \v desc.c\:pit_ticks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} pit_ticks{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 111 of file desc.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/arch/pci.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/arch/pci.c}
{\xe \v src/arch/pci.c}
{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <aplus.h>}\par
{\f2 #include <aplus/pci.h>}\par
{\f2 #include <aplus/mm.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <errno.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PCI_CONFIG_ADDRESS}\~ 0x0CF8\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PCI_CONFIG_DATA}\~ 0x0CFC\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PCI_MAX_DEVICES}\~ 65536\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PCI_MAX_BUS}\~ 255\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PCI_MAX_DEV}\~ 32\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PCI_MAX_FUNC}\~ 8\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b pci_get_address} ({\b uint8_t} bus, {\b uint8_t} dev, {\b uint8_t} func, {\b uint8_t} {\b offset})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b uint32_t} {\b pci_config_read} ({\b uint8_t} bus, {\b uint8_t} dev, {\b uint8_t} func, {\b uint8_t} {\b offset})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b uint32_t} {\b pci_get_device_id} ({\b pci_device_t} *device)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b uint32_t} {\b pci_get_vendor_id} ({\b pci_device_t} *device)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b uint32_t} {\b pci_get_intr_pin} ({\b pci_device_t} *device)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b uint32_t} {\b pci_get_intr_line} ({\b pci_device_t} *device)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b uint32_t} {\b pci_get_revision} ({\b pci_device_t} *device)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b uint32_t} {\b pci_get_class} ({\b pci_device_t} *device)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b uint32_t} {\b pci_get_header_type} ({\b pci_device_t} *device)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b uint32_t} {\b pci_get_bar} ({\b pci_device_t} *device, {\b uint8_t} bar)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b uint32_t} {\b pci_get_iobase} ({\b pci_device_t} *device)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b uint32_t} {\b pci_get_membase} ({\b pci_device_t} *device)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b pci_load_device} ({\b pci_device_t} *device, {\b uint8_t} bus, {\b uint8_t} dev, {\b uint8_t} func)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b pci_device_t} * {\b pci_find_by_id} ({\b uint32_t} vendorID, {\b uint32_t} deviceID)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pci_find_by_class} ({\b pci_device_t} **rdevs, {\b uint32_t} class, {\b uint32_t} {\b length})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pci_init} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b pci_device_t} * {\b pci_devices} = NULL\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v PCI_CONFIG_ADDRESS\:pci.c}
{\xe \v pci.c\:PCI_CONFIG_ADDRESS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PCI_CONFIG_ADDRESS\~ 0x0CF8}}
\par
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 11 of file pci.c.}\par
}
{\xe \v PCI_CONFIG_DATA\:pci.c}
{\xe \v pci.c\:PCI_CONFIG_DATA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PCI_CONFIG_DATA\~ 0x0CFC}}
\par
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 12 of file pci.c.}\par
}
{\xe \v PCI_MAX_BUS\:pci.c}
{\xe \v pci.c\:PCI_MAX_BUS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PCI_MAX_BUS\~ 255}}
\par
{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 14 of file pci.c.}\par
}
{\xe \v PCI_MAX_DEV\:pci.c}
{\xe \v pci.c\:PCI_MAX_DEV}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PCI_MAX_DEV\~ 32}}
\par
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 15 of file pci.c.}\par
}
{\xe \v PCI_MAX_DEVICES\:pci.c}
{\xe \v pci.c\:PCI_MAX_DEVICES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PCI_MAX_DEVICES\~ 65536}}
\par
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 13 of file pci.c.}\par
}
{\xe \v PCI_MAX_FUNC\:pci.c}
{\xe \v pci.c\:PCI_MAX_FUNC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PCI_MAX_FUNC\~ 8}}
\par
{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 16 of file pci.c.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v pci_config_read\:pci.c}
{\xe \v pci.c\:pci_config_read}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b uint32_t} pci_config_read ({\b uint8_t} {\i bus}, {\b uint8_t} {\i dev}, {\b uint8_t} {\i func}, {\b uint8_t} {\i offset}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 26 of file pci.c.}\par
{
References PCI_CONFIG_ADDRESS, PCI_CONFIG_DATA, and pci_get_address().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 26                                                                                         \{\par
27     outl(PCI_CONFIG_ADDRESS, pci_get_address(bus, dev, func, offset));\par
28     \par
29     if(offset % 4 == 0)\par
30         return inl(PCI_CONFIG_DATA);\par
31 \par
32     return (inl(PCI_CONFIG_DATA) >> ((offset % 4) * 8));\par
33 \}\par
}
}
{\xe \v pci_find_by_class\:pci.c}
{\xe \v pci.c\:pci_find_by_class}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pci_find_by_class ({\b pci_device_t} ** {\i rdevs}, {\b uint32_t} {\i class}, {\b uint32_t} {\i length})}}
\par
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 131 of file pci.c.}\par
{
References length, and PCI_MAX_DEVICES.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 131                                                                              \{\par
132     int j = 0;  \par
133     for(int i = 0; i < PCI_MAX_DEVICES && j < length; i++) \{\par
134         if(pci_devices[i].pci_class != class)\par
135             continue;\par
136 \par
137         rdevs[j++] = &pci_devices[i];\par
138     \}\par
139 \par
140     return j;\par
141 \}\par
}
}
{\xe \v pci_find_by_id\:pci.c}
{\xe \v pci.c\:pci_find_by_id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b pci_device_t}* pci_find_by_id ({\b uint32_t} {\i vendorID}, {\b uint32_t} {\i deviceID})}}
\par
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 120 of file pci.c.}\par
{
References PCI_MAX_DEVICES.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 120                                                                    \{\par
121     for(int i = 0; i < PCI_MAX_DEVICES; i++) \{\par
122         if(pci_devices[i].vendorID != vendorID && pci_devices[i].deviceID != deviceID)\par
123             continue;\par
124 \par
125         return &pci_devices[i];\par
126     \}\par
127 \par
128     return NULL;\par
129 \}\par
}
}
{\xe \v pci_get_address\:pci.c}
{\xe \v pci.c\:pci_get_address}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int pci_get_address ({\b uint8_t} {\i bus}, {\b uint8_t} {\i dev}, {\b uint8_t} {\i func}, {\b uint8_t} {\i offset}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 22 of file pci.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 22                                                                                    \{\par
23     return 0x80000000 | (bus << 16) | (dev << 11) | (func << 8) | (offset & 0xFC);\par
24 \}\par
}
}
{\xe \v pci_get_bar\:pci.c}
{\xe \v pci.c\:pci_get_bar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b uint32_t} pci_get_bar ({\b pci_device_t} * {\i device}, {\b uint8_t} {\i bar}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 65 of file pci.c.}\par
{
References pci_device::bus, pci_device::dev, pci_device::func, pci_config_read(), pci_get_header_type(), and uint8_t.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 65                                                                \{\par
66     if(bar >= 6)\par
67         return 0;\par
68 \par
69     uint8_t header = pci_get_header_type(device);\par
70     if(header == 0x02 || (header == 0x01 && bar < 2))\par
71         return 0;\par
72 \par
73     uint8_t reg = 0x10 + (0x04 * bar);\par
74     return pci_config_read(device->bus, device->dev, device->func, reg);\par
75 \}\par
}
}
{\xe \v pci_get_class\:pci.c}
{\xe \v pci.c\:pci_get_class}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b uint32_t} pci_get_class ({\b pci_device_t} * {\i device}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 56 of file pci.c.}\par
{
References pci_device::bus, pci_device::dev, pci_device::func, and pci_config_read().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 56                                                     \{\par
57     return pci_config_read(device->bus, device->dev, device->func, 0x0B) & 0xFF;\par
58 \}\par
}
}
{\xe \v pci_get_device_id\:pci.c}
{\xe \v pci.c\:pci_get_device_id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b uint32_t} pci_get_device_id ({\b pci_device_t} * {\i device}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 36 of file pci.c.}\par
{
References pci_device::bus, pci_device::dev, pci_device::func, and pci_config_read().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 36                                                         \{\par
37     return pci_config_read(device->bus, device->dev, device->func, 2) & 0xFFFF;\par
38 \}\par
}
}
{\xe \v pci_get_header_type\:pci.c}
{\xe \v pci.c\:pci_get_header_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b uint32_t} pci_get_header_type ({\b pci_device_t} * {\i device}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 60 of file pci.c.}\par
{
References pci_device::bus, pci_device::dev, pci_device::func, and pci_config_read().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 60                                                           \{\par
61     return pci_config_read(device->bus, device->dev, device->func, 0x0E) & 0x7F;\par
62 \}\par
}
}
{\xe \v pci_get_intr_line\:pci.c}
{\xe \v pci.c\:pci_get_intr_line}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b uint32_t} pci_get_intr_line ({\b pci_device_t} * {\i device}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 48 of file pci.c.}\par
{
References pci_device::bus, pci_device::dev, pci_device::func, and pci_config_read().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 48                                                         \{\par
49     return pci_config_read(device->bus, device->dev, device->func, 0x3C) & 0xFF;\par
50 \}\par
}
}
{\xe \v pci_get_intr_pin\:pci.c}
{\xe \v pci.c\:pci_get_intr_pin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b uint32_t} pci_get_intr_pin ({\b pci_device_t} * {\i device}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 44 of file pci.c.}\par
{
References pci_device::bus, pci_device::dev, pci_device::func, and pci_config_read().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 44                                                        \{\par
45     return pci_config_read(device->bus, device->dev, device->func, 0x3D) & 0xFF;\par
46 \}\par
}
}
{\xe \v pci_get_iobase\:pci.c}
{\xe \v pci.c\:pci_get_iobase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b uint32_t} pci_get_iobase ({\b pci_device_t} * {\i device}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 77 of file pci.c.}\par
{
References pci_get_bar(), pci_get_header_type(), uint32_t, and uint8_t.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 77                                                      \{\par
78     uint8_t bars = 6 - pci_get_header_type(device) * 4;\par
79     uint8_t i = 0;\par
80 \par
81     while(i < bars) \{\par
82         uint32_t bar = pci_get_bar(device, i++);\par
83         if(bar & 0x01)\par
84             return bar & 0xFFFFFFFC;\par
85     \}\par
86 \par
87     return 0;\par
88 \}\par
}
}
{\xe \v pci_get_membase\:pci.c}
{\xe \v pci.c\:pci_get_membase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b uint32_t} pci_get_membase ({\b pci_device_t} * {\i device}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 90 of file pci.c.}\par
{
References pci_get_bar(), pci_get_header_type(), uint32_t, and uint8_t.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 90                                                       \{\par
91     uint8_t bars = 6 - pci_get_header_type(device) * 4;\par
92     uint8_t i = 0;\par
93 \par
94     while(i < bars) \{\par
95         uint32_t bar = pci_get_bar(device, i++);\par
96         if((bar & 0x01) == 0)\par
97             return bar & 0xFFFFFFF0;\par
98     \}\par
99 \par
100     return 0;\par
101 \}\par
}
}
{\xe \v pci_get_revision\:pci.c}
{\xe \v pci.c\:pci_get_revision}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b uint32_t} pci_get_revision ({\b pci_device_t} * {\i device}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 52 of file pci.c.}\par
{
References pci_device::bus, pci_device::dev, pci_device::func, and pci_config_read().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 52                                                        \{\par
53     return pci_config_read(device->bus, device->dev, device->func, 0x08) & 0xFF;\par
54 \}\par
}
}
{\xe \v pci_get_vendor_id\:pci.c}
{\xe \v pci.c\:pci_get_vendor_id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b uint32_t} pci_get_vendor_id ({\b pci_device_t} * {\i device}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 40 of file pci.c.}\par
{
References pci_device::bus, pci_device::dev, pci_device::func, and pci_config_read().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 40                                                         \{\par
41     return pci_config_read(device->bus, device->dev, device->func, 0) & 0xFFFF;\par
42 \}\par
}
}
{\xe \v pci_init\:pci.c}
{\xe \v pci.c\:pci_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pci_init ()}}
\par
{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 144 of file pci.c.}\par
{
References kmalloc(), kprintf(), pci_config_read(), pci_load_device(), PCI_MAX_BUS, PCI_MAX_DEV, PCI_MAX_DEVICES, PCI_MAX_FUNC, and uint32_t.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 144                \{\par
145     pci_devices = (pci_device_t*) kmalloc(PCI_MAX_DEVICES * sizeof(pci_device_t));\par
146     memset(pci_devices, 0xFF, PCI_MAX_DEVICES * sizeof(pci_device_t));\par
147 \par
148     int i = 0;\par
149     for(int bus = 0; bus < PCI_MAX_BUS; bus++) \{\par
150         for(int dev = 0; dev < PCI_MAX_DEV; dev++) \{\par
151             for(int func = 0; func < PCI_MAX_FUNC; func++) \{\par
152                 uint32_t vendor = pci_config_read(bus, dev, func, 0) & 0xFFFF;\par
153 \par
154                 if(vendor == 0xFFFF || vendor == 0)\par
155                     continue;\par
156 \par
157                 pci_load_device(&pci_devices[i], bus, dev, func);\par
158 \par
159 #if 1\par
160                 kprintf("pci: %d:%d.%d: [%x:%x] (rev %x class %x iobase %x mmio %x type %x int %d pin %d)\\n",\par
161                             pci_devices[i].bus,\par
162                             pci_devices[i].dev,\par
163                             pci_devices[i].func,\par
164                             pci_devices[i].vendorID,\par
165                             pci_devices[i].deviceID,\par
166                             pci_devices[i].revision,\par
167                             pci_devices[i].pci_class,\par
168                             pci_devices[i].iobase,\par
169                             pci_devices[i].membase,\par
170                             pci_devices[i].header,\par
171                             pci_devices[i].intr_line,\par
172                             pci_devices[i].intr_pin);\par
173 #endif\par
174 \par
175                 i++;\par
176             \}\par
177         \}\par
178     \}\par
179 \par
180 \par
181     kprintf("pci: loaded %d devices\\n", i);\par
182 \par
183     return 0;\par
184 \}\par
}
}
{\xe \v pci_load_device\:pci.c}
{\xe \v pci.c\:pci_load_device}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void pci_load_device ({\b pci_device_t} * {\i device}, {\b uint8_t} {\i bus}, {\b uint8_t} {\i dev}, {\b uint8_t} {\i func}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 103 of file pci.c.}\par
{
References pci_device::bus, pci_device::dev, pci_device::deviceID, pci_device::func, pci_device::header, pci_device::intr_line, pci_device::intr_pin, pci_device::iobase, pci_device::membase, pci_device::pci_class, pci_get_class(), pci_get_device_id(), pci_get_header_type(), pci_get_intr_line(), pci_get_intr_pin(), pci_get_iobase(), pci_get_membase(), pci_get_revision(), pci_get_vendor_id(), pci_device::revision, and pci_device::vendorID.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 103                                                                                           \{\par
104     device->bus = bus;\par
105     device->dev = dev;\par
106     device->func = func;\par
107 \par
108     device->vendorID = pci_get_vendor_id(device);\par
109     device->deviceID = pci_get_device_id(device);\par
110     device->revision = pci_get_revision(device);\par
111     device->pci_class = pci_get_class(device);\par
112     device->iobase = pci_get_iobase(device);\par
113     device->membase = pci_get_membase(device);\par
114     device->header = pci_get_header_type(device);\par
115     device->intr_pin = pci_get_intr_pin(device);\par
116     device->intr_line = pci_get_intr_line(device);\par
117 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v pci_devices\:pci.c}
{\xe \v pci.c\:pci_devices}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b pci_device_t}* pci_devices = NULL}}
\par
{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 19 of file pci.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/arch/serial.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/arch/serial.c}
{\xe \v src/arch/serial.c}
{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <aplus.h>}\par
{\f2 #include <aplus/spinlock.h>}\par
{\f2 #include <stdint.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b serial_send} ({\b uint8_t} port, {\b uint8_t} {\b value})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b serial_recv} ({\b uint8_t} port)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b serial_init} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b uint16_t} {\b serial} []\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v serial_init\:serial.c}
{\xe \v serial.c\:serial_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int serial_init ()}}
\par
{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 22 of file serial.c.}\par
{
References serial.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 22                   \{\par
23     for(int i = 0; i < sizeof(serial); i++) \{\par
24         outb(serial[i] + 1, 0x00);\par
25         outb(serial[i] + 3, 0x80);\par
26         outb(serial[i] + 0, 0x03);\par
27         outb(serial[i] + 1, 0x00);\par
28         outb(serial[i] + 3, 0x03);\par
29         outb(serial[i] + 2, 0xC7);\par
30         outb(serial[i] + 4, 0x0B);\par
31     \}\par
32 \par
33     return 0;\par
34 \}\par
}
}
{\xe \v serial_recv\:serial.c}
{\xe \v serial.c\:serial_recv}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} serial_recv ({\b uint8_t} {\i port})}}
\par
{\bkmkstart AAAAAAAACU}
{\bkmkend AAAAAAAACU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 16 of file serial.c.}\par
{
References fastlock_waiton, and serial.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 16                                   \{\par
17     fastlock_waiton((inb(serial[port] + 5) & 1) == 0);\par
18     \par
19     return inb(serial[port]);\par
20 \}\par
}
}
{\xe \v serial_send\:serial.c}
{\xe \v serial.c\:serial_send}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void serial_send ({\b uint8_t} {\i port}, {\b uint8_t} {\i value})}}
\par
{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 11 of file serial.c.}\par
{
References fastlock_waiton, and serial.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11                                               \{\par
12     fastlock_waiton(((inb(serial[port] + 5) & 32) == 0));\par
13     outb(serial[port], value);\par
14 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v serial\:serial.c}
{\xe \v serial.c\:serial}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} serial[]{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    0x3F8, 0x2F8, 0x3E8, 0x2E8\par
\}\par
}
{
Definition at line 7 of file serial.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/arch/syscall.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/arch/syscall.c}
{\xe \v src/arch/syscall.c}
{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <aplus.h>}\par
{\f2 #include <aplus/spinlock.h>}\par
{\f2 #include <aplus/syscall.h>}\par
{\f2 #include <aplus/attribute.h>}\par
{\f2 #include <errno.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b syscall_init} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b syscall_invoke} (void *handler, int p0, int p1, int p2, int p3, int p4)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b syscall_handler} (regs_t *r)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void ** {\b syscall_handlers} = NULL\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v syscall_handler\:syscall.c}
{\xe \v syscall.c\:syscall_handler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int syscall_handler (regs_t * {\i r})}}
\par
{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 53 of file syscall.c.}\par
{
References syscall_handlers, and syscall_invoke().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 53                                \{\par
54     return syscall_invoke(syscall_handlers[r->eax], r->ebx, r->ecx, r->edx, r->esi, r->edi);\par
55 \}\par
}
}
{\xe \v syscall_init\:syscall.c}
{\xe \v syscall.c\:syscall_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int syscall_init ()}}
\par
{\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 11 of file syscall.c.}\par
{
References attribute(), __syscall::handler, kmalloc(), kprintf(), list_destroy, list_foreach, __syscall::number, list::size, syscall_handlers, and value.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11                    \{\par
12     list_t* syslist = attribute("syscall");\par
13 \par
14     syscall_handlers = (void**) kmalloc(sizeof(void*) * syslist->size);\par
15     memset(syscall_handlers, 0, sizeof(void*) * syslist->size);\par
16 \par
17     list_foreach(value, syslist) \{\par
18         syscall_t* sys = (syscall_t*) value;\par
19 \par
20         syscall_handlers[sys->number] = sys->handler;\par
21     \}\par
22 \par
23     kprintf("syscall: loaded %d handlers\\n", syslist->size);\par
24     list_destroy(syslist);\par
25     return 0;\par
26 \}\par
}
}
{\xe \v syscall_invoke\:syscall.c}
{\xe \v syscall.c\:syscall_invoke}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int syscall_invoke (void * {\i handler}, int {\i p0}, int {\i p1}, int {\i p2}, int {\i p3}, int {\i p4})}}
\par
{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 28 of file syscall.c.}\par
{
References __asm__(), and errno.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28                                                                           \{\par
29     if(handler == NULL) \{\par
30         errno = ENOSYS;\par
31         return -1;\par
32     \}\par
33 \par
34 \par
35     int r = 0;\par
36 \par
37     __asm__ (\par
38         "push ebx           \\n"\par
39         "push ecx           \\n"\par
40         "push edx           \\n"\par
41         "push esi           \\n"\par
42         "push edi           \\n"\par
43         "call eax           \\n"\par
44         "add esp, 20        \\n"\par
45         : "=a"(r) \par
46         : "a"(handler), "b"(p4), "c"(p3), "d"(p2), "S"(p1), "D"(p0)\par
47     );\par
48 \par
49     return r;\par
50 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v syscall_handlers\:syscall.c}
{\xe \v syscall.c\:syscall_handlers}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void** syscall_handlers = NULL{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9 of file syscall.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/arch/task.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/arch/task.c}
{\xe \v src/arch/task.c}
{\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <aplus.h>}\par
{\f2 #include <aplus/spinlock.h>}\par
{\f2 #include <aplus/task.h>}\par
{\f2 #include <aplus/mm.h>}\par
{\f2 #include <aplus/list.h>}\par
{\f2 #include <aplus/fs.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b __asm__} (".global {\b task_context_switch}		\\n""task_context_switch:				\\n""	push {\b ebp}						\\n""	mov {\b ebp}, {\b esp}					\\n""	pushf							\\n""	push {\b edx}						\\n""	push {\b eax}						\\n""	push {\b ecx}						\\n""	push {\b ebx}						\\n""	push {\b esi}						\\n""	push {\b edi}						\\n""	mov {\b eax}, [{\b ebp} + 8]				\\n""	mov {\b edx}, [{\b ebp} + 12]				\\n""	mov [{\b eax}], {\b esp}					\\n""	mov {\b esp}, [{\b edx}]					\\n""	pop {\b edi}							\\n""	pop {\b esi}							\\n""	pop {\b ebx}							\\n""	pop {\b ecx}							\\n""	pop {\b eax}							\\n""	pop {\b edx}							\\n""	popf							\\n""	pop {\b ebp}							\\n""	sti								\\n""ret								\\n")\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b task_context_switch} (task_env_t **old, task_env_t **new)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b task_t} * {\b task_fork} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b task_t} * {\b task_clone} (void *entry, void *arg, void *stack)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b task_switch} ({\b task_t} *newtask)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b task_init} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b task_t} * {\b current_task}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current task address. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b task_t} * {\b kernel_task}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Kernel task address. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b list_t} * {\b task_queue}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
List of all Task. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} * {\b kernel_vmm}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} * {\b current_vmm}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile {\b inode_t} * {\b vfs_root}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v __asm__\:task.c}
{\xe \v task.c\:__asm__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__asm__ (".global {\b task_context_switch} \\n""task_context_switch: \\n"" push {\b ebp} \\n"" mov {\i ebp}, esp\\n""pushf\\n""push edx\\n""push eax\\n""push ecx\\n""push ebx\\n""push esi\\n""push edi\\n""mov {\i eax}, [ebp + 8] \\n""mov {\i edx}, [ebp + 12] \\n"" {\i mov}[eax], esp\\n""mov {\i esp}, [edx] \\n""pop edi\\n""pop esi\\n""pop ebx\\n""pop ecx\\n""pop eax\\n""pop edx\\n""popf\\n""pop ebp\\n""sti\\n""ret\\n" )}}
\par
{\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v task_clone\:task.c}
{\xe \v task.c\:task_clone}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b task_t}* task_clone (void * {\i entry}, void * {\i arg}, void * {\i stack})}}
\par
{\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 115 of file task.c.}\par
{
References task::clock, task::context, task::cr3, current_task, task::cwd, task::env, task::exe, task::fd, task::gid, task::image, kmalloc(), task::length, list_add(), mm_align(), task::parent, task::pid, task::priority, task::ptr, schedule_nextpid(), task::signal_handler, task::signal_sig, task::stack, task::state, TASK_MAX_FD, TASK_STACKSIZE, TASK_STATE_ALIVE, task::uid, uint32_t, and task::vaddr.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 115                                                         \{\par
116     if(entry == NULL)\par
117         return NULL;\par
118 \par
119     if(stack == NULL)\par
120         stack = (void*) ((int) mm_align(kmalloc(TASK_STACKSIZE * 2)) + TASK_STACKSIZE);\par
121 \par
122     memset(stack, 0, TASK_STACKSIZE);\par
123 \par
124 \par
125     task_t* child = (task_t*) kmalloc(sizeof(task_t));\par
126     memset(child, 0, sizeof(task_t));\par
127 \par
128     child->pid = schedule_nextpid();\par
129     child->cwd = current_task->cwd;\par
130     child->exe = current_task->exe;\par
131     child->uid = current_task->uid;\par
132     child->gid = current_task->gid;\par
133     \par
134     child->state = TASK_STATE_ALIVE;\par
135     child->priority = current_task->priority;\par
136     child->clock = 0;\par
137     child->parent = current_task;\par
138 \par
139     child->signal_handler = current_task->signal_handler;\par
140     child->signal_sig = current_task->signal_sig;\par
141 \par
142     child->image.vaddr = current_task->image.vaddr;\par
143     child->image.length = current_task->image.length;\par
144     child->image.ptr = current_task->image.ptr;\par
145         \par
146     \par
147     child->context.cr3 = current_task->context.cr3;\par
148     child->context.stack = (uint32_t) stack - TASK_STACKSIZE;\par
149     child->context.env = (task_env_t*) ((uint32_t) stack - sizeof(task_env_t));\par
150 \par
151     child->context.env->eax = (uint32_t) arg;\par
152     child->context.env->eip = (uint32_t) entry;\par
153     child->context.env->ebp = (uint32_t) child->context.env; \par
154 \par
155     \par
156     for(int i = 0; i < TASK_MAX_FD; i++)\par
157         child->fd[i] = current_task->fd[i];\par
158 \par
159 \par
160     list_add(task_queue, (listval_t) child);\par
161     return child;\par
162 \}\par
}
}
{\xe \v task_context_switch\:task.c}
{\xe \v task.c\:task_context_switch}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void task_context_switch (task_env_t ** {\i old}, task_env_t ** {\i new})}}
\par
{\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v task_fork\:task.c}
{\xe \v task.c\:task_fork}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b task_t}* task_fork ()}}
\par
{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 49 of file task.c.}\par
{
References task::clock, task::context, task::cr3, current_task, task::cwd, task::env, task::exe, task::fd, task::gid, task::image, kmalloc(), task::length, list_add(), mm_align(), mm_paddr(), task::parent, task::pid, task::priority, task::ptr, schedule_nextpid(), task::signal_handler, task::signal_sig, task::stack, task::state, TASK_MAX_FD, TASK_STACKSIZE, TASK_STATE_ALIVE, task::uid, uint32_t, task::vaddr, vmm_create(), VMM_FLAGS_DEFAULT, VMM_FLAGS_USER, vmm_map(), vmm_mapkernel(), and vmm_umap().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 49                     \{\par
50     if(!current_task)\par
51         return NULL;\par
52 \par
53     task_t* child = (task_t*) kmalloc(sizeof(task_t));\par
54     memset(child, 0, sizeof(task_t));\par
55 \par
56     child->pid = schedule_nextpid();\par
57     child->cwd = current_task->cwd;\par
58     child->exe = current_task->exe;\par
59     child->uid = current_task->uid;\par
60     child->gid = current_task->gid;\par
61     \par
62     child->state = TASK_STATE_ALIVE;\par
63     child->priority = current_task->priority;\par
64     child->clock = 0;\par
65     child->parent = current_task;\par
66 \par
67     child->signal_handler = current_task->signal_handler;\par
68     child->signal_sig = current_task->signal_sig;\par
69 \par
70     \par
71     for(int i = 0; i < TASK_MAX_FD; i++)\par
72         child->fd[i] = current_task->fd[i];\par
73 \par
74 \par
75     child->context.cr3 = vmm_create();\par
76     vmm_mapkernel(child->context.cr3);\par
77 \par
78 \par
79     child->image.vaddr = current_task->image.vaddr;\par
80     child->image.length = current_task->image.length;\par
81 \par
82     \par
83     if(current_task->image.ptr) \{\par
84         void* addr = (void*) kmalloc(child->image.length);\par
85         memcpy(addr, (void*) child->image.vaddr, child->image.length);\par
86 \par
87         vmm_map(child->context.cr3, mm_paddr(addr), child->image.vaddr, child->image.length);\par
88         child->image.ptr = (uint32_t) mm_paddr(addr);\par
89     \}\par
90 \par
91     \par
92     \par
93     child->context.stack = current_task->context.stack;\par
94     child->context.env = current_task->context.env;\par
95 \par
96     void* stack = (void*) mm_align(kmalloc(TASK_STACKSIZE * 2));\par
97     memcpy(stack, (void*) child->context.stack, TASK_STACKSIZE);\par
98 \par
99     vmm_umap(child->context.cr3, child->context.stack, TASK_STACKSIZE);\par
100     vmm_map(child->context.cr3, mm_paddr(stack), child->context.stack, TASK_STACKSIZE, VMM_FLAGS_DEFAULT | VMM_FLAGS_USER);\par
101     \par
102 \par
103     /* TODO: Set EIP for child */\par
104     \par
105     if(current_task == child)\par
106         return 0;\par
107     \par
108 \par
109     list_add(task_queue, (listval_t) child);\par
110     return child;\par
111 \}\par
}
}
{\xe \v task_init\:task.c}
{\xe \v task.c\:task_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int task_init ()}}
\par
{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 179 of file task.c.}\par
{
References task::context, task::cr3, task::cwd, task::env, task::gid, kernel_vmm, kmalloc(), list_add(), task::parent, task::pid, task::priority, schedule_nextpid(), task::stack, task::state, TASK_PRIORITY_REGULAR, TASK_STATE_ALIVE, task_switch(), task::uid, and uint32_t.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 179                 \{\par
180 \par
181     extern uint32_t kernel_stack;\par
182     \par
183     kernel_task = current_task = (task_t*) kmalloc(sizeof(task_t));\par
184     memset(current_task, 0, sizeof(task_t));\par
185     \par
186     \par
187     current_task->context.env = (task_env_t*) 0;\par
188     current_task->context.cr3 = (uint32_t) kernel_vmm;\par
189     current_task->context.stack = (uint32_t) &kernel_stack;\par
190     \par
191     \par
192     current_task->pid = schedule_nextpid();\par
193     current_task->cwd = (inode_t*) vfs_root;\par
194     current_task->uid = (uid_t) 0;\par
195     current_task->gid = (gid_t) 0;\par
196     \par
197     current_task->state = TASK_STATE_ALIVE;\par
198     current_task->priority = TASK_PRIORITY_REGULAR;\par
199     current_task->parent = NULL;\par
200 \par
201 \par
202     list_add(task_queue, (listval_t) current_task);\par
203     task_switch(current_task);\par
204 \par
205 \par
206     return 0;\par
207 \}\par
}
}
{\xe \v task_switch\:task.c}
{\xe \v task.c\:task_switch}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void task_switch ({\b task_t} * {\i newtask})}}
\par
{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 165 of file task.c.}\par
{
References task::context, task::cr3, current_task, task::env, task_context_switch(), and vmm_switch().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 165                                   \{\par
166     \par
167     task_t* old = current_task;\par
168     current_task = newtask;\par
169 \par
170 \par
171     vmm_switch(current_task->context.cr3);\par
172     outb(0x20, 0x20);\par
173 \par
174     task_context_switch(&old->context.env, &current_task->context.env);\par
175 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v current_task\:task.c}
{\xe \v task.c\:current_task}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b task_t}* current_task}}
\par
{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current task address. }}\par
{
Definition at line 35 of file sched.c.}\par
}
{\xe \v current_vmm\:task.c}
{\xe \v task.c\:current_vmm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t}* current_vmm}}
\par
{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 46 of file paging.c.}\par
}
{\xe \v kernel_task\:task.c}
{\xe \v task.c\:kernel_task}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b task_t}* kernel_task}}
\par
{\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Kernel task address. }}\par
{
Definition at line 40 of file sched.c.}\par
}
{\xe \v kernel_vmm\:task.c}
{\xe \v task.c\:kernel_vmm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t}* kernel_vmm}}
\par
{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 47 of file paging.c.}\par
}
{\xe \v task_queue\:task.c}
{\xe \v task.c\:task_queue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b list_t}* task_queue}}
\par
{\bkmkstart AAAAAAAADN}
{\bkmkend AAAAAAAADN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
List of all Task. }}\par
{
Definition at line 46 of file sched.c.}\par
}
{\xe \v vfs_root\:task.c}
{\xe \v task.c\:vfs_root}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile {\b inode_t}* vfs_root}}
\par
{\bkmkstart AAAAAAAADO}
{\bkmkend AAAAAAAADO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 19 of file vfs.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/bufio.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/bufio.c}
{\xe \v src/bufio.c}
{\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <aplus.h>}\par
{\f2 #include <aplus/list.h>}\par
{\f2 #include <aplus/spinlock.h>}\par
{\f2 #include <aplus/mm.h>}\par
{\f2 #include <aplus/bufio.h>}\par
{\f2 #include <aplus/task.h>}\par
{\f2 #include <stddef.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <sys/types.h>}\par
{\f2 #include <stdio.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b bufio_init} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
BufIO initialization. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b bufio_free_unused} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Free al unused buffers. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bufio_t} * {\b bufio_alloc} (size_t {\b size})\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Alloc new buffer for current task. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bufio_t} * {\b bufio_alloc_raw} (void *raw, size_t {\b size})\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create new buffer from allocated data for current task. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b bufio_free} ({\b bufio_t} *buf)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Free and remove buffer. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b bufio_seek} ({\b bufio_t} *buf, off_t {\b offset}, int dir)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the position indicator associated with the bufio descriptor to a new position. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b bufio_tell} ({\b bufio_t} *buf)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the current value of the position indicator of the stream.\par
. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b bufio_clear} ({\b bufio_t} *buf)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clear entire stream of the buffer descriptor. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b bufio_read} ({\b bufio_t} *buf, void *ptr, size_t len)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function shall attempt to read nbyte bytes from the stream associated with the bufio descriptor, buf, into the buffer pointed to by ptr. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b bufio_write} ({\b bufio_t} *buf, void *ptr, size_t len)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function shall attempt to write nbyte bytes into the stream associated with the bufio descriptor, buf, from the buffer pointed to by ptr. }{
}\par
}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b list_t} * {\b list_buffers}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
List of allocated buffers. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static uint64_t {\b buffers_length}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Allocated RAM of all buffers. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b task_t} * {\b current_task}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current task address. }{
}\par
}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v bufio_alloc\:bufio.c}
{\xe \v bufio.c\:bufio_alloc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bufio_t}* bufio_alloc (size_t {\i size})}}
\par
{\bkmkstart AAAAAAAADQ}
{\bkmkend AAAAAAAADQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Alloc new buffer for current task. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i size} \cell }{Size in Bytes of data. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid bufio descriptor. \par
}}{
Definition at line 63 of file bufio.c.}\par
{
References buffers_length, current_task, kmalloc(), list_add(), lock, bufio::offset, bufio::raw, bufio::size, size, bufio::task, bufio::type, and unlock.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 63                                   \{\par
64     void* addr = (void*) kmalloc(size);\par
65     if(!addr)\par
66         return 0;\par
67         \par
68     lock(); \par
69     buffers_length += size;\par
70 \par
71 \par
72     bufio_t* buf = (bufio_t*) kmalloc(size);\par
73     buf->raw = addr;\par
74     buf->size = size;\par
75     buf->type = 0;\par
76     buf->offset = (off_t) 0;\par
77     buf->task = current_task;\par
78 \par
79 \par
80     list_add(list_buffers, (listval_t) buf);\par
81 \par
82     unlock();\par
83     return buf;\par
84 \}\par
}
}
{\xe \v bufio_alloc_raw\:bufio.c}
{\xe \v bufio.c\:bufio_alloc_raw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bufio_t}* bufio_alloc_raw (void * {\i raw}, size_t {\i size})}}
\par
{\bkmkstart AAAAAAAADR}
{\bkmkend AAAAAAAADR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create new buffer from allocated data for current task. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i raw} \cell }{Buffer allocated address. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i size} \cell }{Size in Bytes of data. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid bufio descriptor. \par
}}{
Definition at line 92 of file bufio.c.}\par
{
References buffers_length, current_task, kmalloc(), list_add(), lock, bufio::offset, bufio::raw, bufio::size, size, bufio::task, bufio::type, and unlock.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 92                                                  \{\par
93     if(!raw)\par
94         return 0;\par
95 \par
96     lock(); \par
97 \par
98     buffers_length += size;\par
99 \par
100     bufio_t* buf = (bufio_t*) kmalloc(size);\par
101     buf->raw = raw;\par
102     buf->size = size;\par
103     buf->type = 0;\par
104     buf->offset = (off_t) 0;\par
105     buf->task = current_task;\par
106     \par
107     list_add(list_buffers, (listval_t) buf);\par
108 \par
109     unlock();\par
110     \par
111     return buf;\par
112 \}\par
}
}
{\xe \v bufio_clear\:bufio.c}
{\xe \v bufio.c\:bufio_clear}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void bufio_clear ({\b bufio_t} * {\i buf})}}
\par
{\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clear entire stream of the buffer descriptor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i buf} \cell }{Pointer to a bufio descriptor. \cell }
{\row }
}
}{
Definition at line 186 of file bufio.c.}\par
{
References bufio::lock, bufio::raw, bufio::size, spinlock_lock(), and spinlock_unlock().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 186                                \{\par
187     spinlock_lock(&buf->lock);\par
188     memset(buf->raw, 0, buf->size);\par
189     spinlock_unlock(&buf->lock);\par
190 \}\par
}
}
{\xe \v bufio_free\:bufio.c}
{\xe \v bufio.c\:bufio_free}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void bufio_free ({\b bufio_t} * {\i buf})}}
\par
{\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Free and remove buffer. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i buf} \cell }{bufio descriptor. \cell }
{\row }
}
}{
Definition at line 118 of file bufio.c.}\par
{
References buffers_length, kfree(), list_remove(), lock, bufio::raw, bufio::size, and unlock.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 118                               \{\par
119     lock();\par
120     buffers_length -= buf->size;\par
121     \par
122     kfree(buf->raw);\par
123     kfree(buf);\par
124     \par
125     list_remove(list_buffers, (listval_t) buf);\par
126     \par
127     \par
128     unlock();\par
129 \}\par
}
}
{\xe \v bufio_free_unused\:bufio.c}
{\xe \v bufio.c\:bufio_free_unused}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void bufio_free_unused ()}}
\par
{\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Free al unused buffers. }}\par
{
Definition at line 41 of file bufio.c.}\par
{
References list_clone(), list_destroy, list_foreach, list_init, and value.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 41                          \{\par
42 \par
43     list_t* tmp;\par
44     list_init(tmp);\par
45     list_clone(tmp, list_buffers);\par
46     \par
47     list_foreach(value, tmp) \{\par
48         //bufio_t* value = (bufio_t*) value;\par
49         \par
50         //if(value->task->state == TASK_STATE_DEAD)\par
51         //  bufio_free(value);\par
52     \}\par
53     \par
54     list_destroy(tmp);\par
55 \}\par
}
}
{\xe \v bufio_init\:bufio.c}
{\xe \v bufio.c\:bufio_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int bufio_init ()}}
\par
{\bkmkstart AAAAAAAADV}
{\bkmkend AAAAAAAADV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
BufIO initialization. }}\par
{
Definition at line 31 of file bufio.c.}\par
{
References list_init.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 31                  \{\par
32     list_init(list_buffers);\par
33     \par
34     return 0;\par
35 \}\par
}
}
{\xe \v bufio_read\:bufio.c}
{\xe \v bufio.c\:bufio_read}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int bufio_read ({\b bufio_t} * {\i buf}, void * {\i ptr}, size_t {\i len})}}
\par
{\bkmkstart AAAAAAAADW}
{\bkmkend AAAAAAAADW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function shall attempt to read nbyte bytes from the stream associated with the bufio descriptor, buf, into the buffer pointed to by ptr. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i buf} \cell }{Pointer to a bufio descriptor. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ptr} \cell }{Pointer to output buffer. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i len} \cell }{Size of data to read. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid Upon successful completion, shall return a non-negative integer indicating the number of bytes actually read.\par
 Otherwise, the functions shall return -1 and set errno to indicate the error. \par
}}{
Definition at line 203 of file bufio.c.}\par
{
References bufio::lock, bufio::offset, bufio::raw, bufio::size, spinlock_lock(), and spinlock_unlock().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 203                                                     \{       \par
204     spinlock_lock(&buf->lock);\par
205     \par
206     len = (len + buf->offset > buf->size) ? (buf->size - buf->offset) : len;\par
207     memcpy(ptr, (void*) ((off_t) buf->raw + buf->offset), len);\par
208     \par
209     buf->offset += (off_t) len;\par
210     \par
211     spinlock_unlock(&buf->lock);\par
212     \par
213     return (int) len;\par
214 \}\par
}
}
{\xe \v bufio_seek\:bufio.c}
{\xe \v bufio.c\:bufio_seek}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int bufio_seek ({\b bufio_t} * {\i buf}, off_t {\i offset}, int {\i dir})}}
\par
{\bkmkstart AAAAAAAADX}
{\bkmkend AAAAAAAADX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the position indicator associated with the bufio descriptor to a new position. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i buf} \cell }{Pointer to a bufio descriptor. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i offset} \cell }{Number of bytes to offset from dir. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i dir} \cell }{Position used as reference for the offset\par
{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
SEEK_SET: Beginning of stream.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
SEEK_CUR: Current position of stream.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
SEEK_END: End of stream.\par
\par}
\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid If successful return current position of stream, otherwise, it returns non-zero value. \par
}}{
Definition at line 142 of file bufio.c.}\par
{
References bufio::offset, offset, and bufio::size.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 142                                                     \{\par
143 \par
144     if(offset > buf->size)\par
145         return -1;\par
146         \par
147     if(dir == SEEK_CUR && (offset + buf->offset) > buf->size)\par
148         return -1;\par
149 \par
150     switch(dir) \{\par
151         case SEEK_SET:\par
152             buf->offset = offset;\par
153             break;\par
154             \par
155         case SEEK_END:\par
156             buf->offset = buf->offset - offset;\par
157             break;\par
158             \par
159         case SEEK_CUR:\par
160             buf->offset += offset;\par
161             break;\par
162             \par
163         default:\par
164             return -1;\par
165     \}\par
166     \par
167     return buf->offset;\par
168 \}\par
}
}
{\xe \v bufio_tell\:bufio.c}
{\xe \v bufio.c\:bufio_tell}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int bufio_tell ({\b bufio_t} * {\i buf})}}
\par
{\bkmkstart AAAAAAAADY}
{\bkmkend AAAAAAAADY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the current value of the position indicator of the stream.\par
. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i buf} \cell }{Pointer to a bufio descriptor. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid On success, the current value of the position indicator is returned.\par
 On failure, -1L is returned. \par
}}{
Definition at line 177 of file bufio.c.}\par
{
References bufio_seek().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 177                              \{\par
178     return bufio_seek(buf, 0, SEEK_CUR);\par
179 \}\par
}
}
{\xe \v bufio_write\:bufio.c}
{\xe \v bufio.c\:bufio_write}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int bufio_write ({\b bufio_t} * {\i buf}, void * {\i ptr}, size_t {\i len})}}
\par
{\bkmkstart AAAAAAAADZ}
{\bkmkend AAAAAAAADZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function shall attempt to write nbyte bytes into the stream associated with the bufio descriptor, buf, from the buffer pointed to by ptr. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i buf} \cell }{Pointer to a bufio descriptor. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ptr} \cell }{Pointer to input buffer. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i len} \cell }{Size of data to write. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid Upon successful completion, shall return a non-negative integer indicating the number of bytes actually write.\par
 Otherwise, the functions shall return -1 and set errno to indicate the error. \par
}}{
Definition at line 227 of file bufio.c.}\par
{
References bufio::lock, bufio::offset, bufio::raw, bufio::size, spinlock_lock(), and spinlock_unlock().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 227                                                      \{      \par
228     \par
229     spinlock_lock(&buf->lock);\par
230     \par
231     len = (len + buf->offset > buf->size) ? (buf->size - buf->offset) : len;\par
232     memcpy((void*) ((off_t) buf->raw + buf->offset), ptr, len);\par
233     \par
234     buf->offset += (off_t) len;\par
235     \par
236     spinlock_unlock(&buf->lock);\par
237     \par
238     return (int) len;\par
239 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v buffers_length\:bufio.c}
{\xe \v bufio.c\:buffers_length}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t buffers_length{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAEA}
{\bkmkend AAAAAAAAEA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Allocated RAM of all buffers. }}\par
{
Definition at line 23 of file bufio.c.}\par
}
{\xe \v current_task\:bufio.c}
{\xe \v bufio.c\:current_task}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b task_t}* current_task}}
\par
{\bkmkstart AAAAAAAAEB}
{\bkmkend AAAAAAAAEB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current task address. }}\par
{
Definition at line 35 of file sched.c.}\par
}
{\xe \v list_buffers\:bufio.c}
{\xe \v bufio.c\:list_buffers}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b list_t}* list_buffers{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAEC}
{\bkmkend AAAAAAAAEC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
List of allocated buffers. }}\par
{
Definition at line 18 of file bufio.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/debug.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/debug.c}
{\xe \v src/debug.c}
{\bkmkstart AAAAAAAAED}
{\bkmkend AAAAAAAAED}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <aplus.h>}\par
{\f2 #include <aplus/spinlock.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b debug_putc} (char ch)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Send a character to serial debug port. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b debug_puts} (char *str)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Send a string to serial debug port. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b print_dec} (unsigned int {\b value}, unsigned int width, char *buf, int *ptr)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Print a number in base 10 into buffer. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b print_hex} (unsigned int {\b value}, unsigned int width, char *buf, int *ptr)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Print a number in base 16 into buffer. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b vasprintf} (char *buf, const char *fmt, va_list args)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Print to allocated string.\par
The functions asprintf() and {\b vasprintf()} are analogs of sprintf(3) and vsprintf(3), except that they allocate a string large enough to hold the output including the terminating null byte, and return a pointer to it via the first argument. This pointer should be passed to free(3) to release the allocated storage when it is no longer needed. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b kprintf} (char *fmt,...)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Formatted output conversion and print to Debug Standard Output. }{
}\par
}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v debug_putc\:debug.c}
{\xe \v debug.c\:debug_putc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void debug_putc (char {\i ch})}}
\par
{\bkmkstart AAAAAAAAEE}
{\bkmkend AAAAAAAAEE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Send a character to serial debug port. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ch} \cell }{Character to send. \cell }
{\row }
}
}{
Definition at line 9 of file debug.c.}\par
{
References serial_send().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 9                          \{\par
10     serial_send(0, ch);\par
11 \}\par
}
}
{\xe \v debug_puts\:debug.c}
{\xe \v debug.c\:debug_puts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void debug_puts (char * {\i str})}}
\par
{\bkmkstart AAAAAAAAEF}
{\bkmkend AAAAAAAAEF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Send a string to serial debug port. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i str} \cell }{String to send. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b debug_putc} \par
}}{
Definition at line 19 of file debug.c.}\par
{
References debug_putc(), lock, and unlock.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19                            \{\par
20     lock();\par
21     \par
22     while(*str)\par
23         debug_putc(*str++);\par
24     \par
25     unlock();\par
26 \}\par
}
}
{\xe \v kprintf\:debug.c}
{\xe \v debug.c\:kprintf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void kprintf (char * {\i fmt},  {\i ...})}}
\par
{\bkmkstart AAAAAAAAEG}
{\bkmkend AAAAAAAAEG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Formatted output conversion and print to Debug Standard Output. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fmt} \cell }{Format of string. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ...} \cell }{Arguments. \cell }
{\row }
}
}{
Definition at line 167 of file debug.c.}\par
{
References debug_puts(), and vasprintf().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 167                              \{\par
168     static char __kprintf_buf[1024];\par
169     memset(__kprintf_buf, 0, 1024);\par
170     \par
171     va_list lst;\par
172     va_start(lst, fmt);\par
173     vasprintf(__kprintf_buf, fmt, lst);\par
174     va_end(lst);\par
175     \par
176     debug_puts(__kprintf_buf);\par
177 \}\par
}
}
{\xe \v print_dec\:debug.c}
{\xe \v debug.c\:print_dec}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void print_dec (unsigned int {\i value}, unsigned int {\i width}, char * {\i buf}, int * {\i ptr}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAEH}
{\bkmkend AAAAAAAAEH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Print a number in base 10 into buffer. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i value} \cell }{Number to convert as string. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i width} \cell }{Padding. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i buf} \cell }{Buffer output. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ptr} \cell }{Size of returned string. \cell }
{\row }
}
}{
Definition at line 36 of file debug.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 36                                                                                     \{\par
37     unsigned int n_width = 1;\par
38     unsigned int i = 9;\par
39     while (value > i && i < UINT32_MAX) \{\par
40         n_width += 1;\par
41         i *= 10;\par
42         i += 9;\par
43     \}\par
44 \par
45     int printed = 0;\par
46     while (n_width + printed < width) \{\par
47         buf[*ptr] = '0';\par
48         *ptr += 1;\par
49         printed += 1;\par
50     \}\par
51 \par
52     i = n_width;\par
53     while (i > 0) \{\par
54         unsigned int n = value / 10;\par
55         int r = value % 10;\par
56         buf[*ptr + i - 1] = r + '0';\par
57         i--;\par
58         value = n;\par
59     \}\par
60     *ptr += n_width;\par
61 \}\par
}
}
{\xe \v print_hex\:debug.c}
{\xe \v debug.c\:print_hex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void print_hex (unsigned int {\i value}, unsigned int {\i width}, char * {\i buf}, int * {\i ptr}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAEI}
{\bkmkend AAAAAAAAEI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Print a number in base 16 into buffer. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i value} \cell }{Number to convert as string. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i width} \cell }{Padding. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i buf} \cell }{Buffer output. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ptr} \cell }{Size of returned string. \cell }
{\row }
}
}{
Definition at line 70 of file debug.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 70                                                                                    \{\par
71     int i = width;\par
72 \par
73     if (i == 0) i = 8;\par
74 \par
75     unsigned int n_width = 1;\par
76     unsigned int j = 0x0F;\par
77     while (value > j && j < UINT32_MAX) \{\par
78         n_width += 1;\par
79         j *= 0x10;\par
80         j += 0x0F;\par
81     \}\par
82 \par
83     while (i > (int)n_width) \{\par
84         buf[*ptr] = '0';\par
85         *ptr += 1;\par
86         i--;\par
87     \}\par
88 \par
89     i = (int)n_width;\par
90     while (i-- > 0) \{\par
91         buf[*ptr] = "0123456789abcdef"[(value>>(i*4))&0xF];\par
92         *ptr += + 1;\par
93     \}\par
94 \}\par
}
}
{\xe \v vasprintf\:debug.c}
{\xe \v debug.c\:vasprintf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t vasprintf (char * {\i buf}, const char * {\i fmt}, va_list {\i args})}}
\par
{\bkmkstart AAAAAAAAEJ}
{\bkmkend AAAAAAAAEJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Print to allocated string.\par
The functions asprintf() and {\b vasprintf()} are analogs of sprintf(3) and vsprintf(3), except that they allocate a string large enough to hold the output including the terminating null byte, and return a pointer to it via the first argument. This pointer should be passed to free(3) to release the allocated storage when it is no longer needed. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i buf} \cell }{Output buffer just allocated. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fmt} \cell }{Format of string. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i args} \cell }{Arguments. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid When successful, these functions return the number of bytes printed, just like sprintf(3). If memory allocation wasn't possible, or some other error occurs, these functions will return -1, and the contents of strp is undefined. \par
}}{
Definition at line 110 of file debug.c.}\par
{
References print_dec(), and print_hex().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 110                                                             \{\par
111     int i = 0;\par
112     char *s;\par
113     int ptr = 0;\par
114     int len = strlen(fmt);\par
115     for ( ; i < len && fmt[i]; ++i) \{\par
116         if (fmt[i] != '%') \{\par
117             buf[ptr++] = fmt[i];\par
118             continue;\par
119         \}\par
120         ++i;\par
121         unsigned int arg_width = 0;\par
122         while (fmt[i] >= '0' && fmt[i] <= '9') \{\par
123             arg_width *= 10;\par
124             arg_width += fmt[i] - '0';\par
125             ++i;\par
126         \}\par
127         /* fmt[i] == '%' */\par
128         switch (fmt[i]) \{\par
129             case 's': /* String pointer -> String */\par
130                 s = (char *)va_arg(args, char *);\par
131                 if (s == NULL) \{\par
132                     s = "(null)";\par
133                 \}\par
134                 while (*s) \{\par
135                     buf[ptr++] = *s++;\par
136                 \}\par
137                 break;\par
138             case 'c': /* Single character */\par
139                 buf[ptr++] = (char)va_arg(args, int);\par
140                 break;\par
141             case 'x': /* Hexadecimal number */\par
142                 print_hex((unsigned long)va_arg(args, unsigned long), arg_width, buf, &ptr);\par
143                 break;\par
144             case 'd': /* Decimal number */\par
145                 print_dec((unsigned long)va_arg(args, unsigned long), arg_width, buf, &ptr);\par
146                 break;\par
147             case '%': /* Escape */\par
148                 buf[ptr++] = '%';\par
149                 break;\par
150             default: /* Nothing at all, just dump it */\par
151                 buf[ptr++] = fmt[i];\par
152                 break;\par
153         \}\par
154     \}\par
155     /* Ensure the buffer ends in a null */\par
156     buf[ptr] = '\\0';\par
157     return ptr;\par
158 \par
159 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/exec.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/exec.c}
{\xe \v src/exec.c}
{\bkmkstart AAAAAAAAEK}
{\bkmkend AAAAAAAAEK}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <aplus.h>}\par
{\f2 #include <aplus/mm.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <errno.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b elf32_hdr}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ELF32 Header. }}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b elf32_shdr}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ELF32 Section Header. }}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EI_NIDENT}\~ 16\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EI_MAG0}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EI_MAG1}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EI_MAG2}\~ 2\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EI_MAG3}\~ 3\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EI_CLASS}\~ 4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EI_DATA}\~ 5\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EI_VERSION}\~ 6\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EI_PAD}\~ 7\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ELF_MAG0}\~ 0x7F\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ELF_MAG1}\~ 'E'\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ELF_MAG2}\~ 'L'\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ELF_MAG3}\~ 'F'\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ELF_CLASS_32}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ELF_CLASS_64}\~ 2\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ELF_DATA_LSB}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ELF_DATA_MSB}\~ 2\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SHT_NULL}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SHT_PROGBITS}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SHT_SYMTAB}\~ 2\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SHT_STRTAB}\~ 3\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SHT_RELA}\~ 4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SHT_HASH}\~ 5\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SHT_DYNAMIC}\~ 6\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SHT_NOTE}\~ 7\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SHT_NOBITS}\~ 8\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SHT_REL}\~ 9\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SHT_SHLIB}\~ 10\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SHT_DYNSYM}\~ 11\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SHF_WRITE}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SHF_ALLOC}\~ 2\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SHF_EXECINSTR}\~ 4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SHF_MASK}\~ 0xF0000000\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ELF_DEBUG}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enable or disable debug for ELF. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b check}(cond)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b uint32_t} {\b Elf32_Addr}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b uint16_t} {\b Elf32_Half}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b uint32_t} {\b Elf32_Off}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef int32_t {\b Elf32_Sword}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b uint32_t} {\b Elf32_Word}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b elf32_hdr} {\b elf32_hdr_t}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ELF32 Header. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b elf32_shdr} {\b elf32_shdr_t}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ELF32 Section Header. }{
}\par
}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b elf32_check} ({\b elf32_hdr_t} *hdr)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check for valid ELF32 header. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b elf32_load} (void *image)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Load a ELF32 Executable image. }{
}\par
}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v check\:exec.c}
{\xe \v exec.c\:check}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define check( cond)}}
\par
{\bkmkstart AAAAAAAAEL}
{\bkmkend AAAAAAAAEL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid if(cond) \{                  \\\par
            errno = ENOEXEC;        \\\par
            return -1;              \\\par
        \}\par
}
}
{\xe \v EI_CLASS\:exec.c}
{\xe \v exec.c\:EI_CLASS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EI_CLASS\~ 4}}
\par
{\bkmkstart AAAAAAAAEM}
{\bkmkend AAAAAAAAEM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 20 of file exec.c.}\par
}
{\xe \v EI_DATA\:exec.c}
{\xe \v exec.c\:EI_DATA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EI_DATA\~ 5}}
\par
{\bkmkstart AAAAAAAAEN}
{\bkmkend AAAAAAAAEN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 21 of file exec.c.}\par
}
{\xe \v EI_MAG0\:exec.c}
{\xe \v exec.c\:EI_MAG0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EI_MAG0\~ 0}}
\par
{\bkmkstart AAAAAAAAEO}
{\bkmkend AAAAAAAAEO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 16 of file exec.c.}\par
}
{\xe \v EI_MAG1\:exec.c}
{\xe \v exec.c\:EI_MAG1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EI_MAG1\~ 1}}
\par
{\bkmkstart AAAAAAAAEP}
{\bkmkend AAAAAAAAEP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 17 of file exec.c.}\par
}
{\xe \v EI_MAG2\:exec.c}
{\xe \v exec.c\:EI_MAG2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EI_MAG2\~ 2}}
\par
{\bkmkstart AAAAAAAAEQ}
{\bkmkend AAAAAAAAEQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 18 of file exec.c.}\par
}
{\xe \v EI_MAG3\:exec.c}
{\xe \v exec.c\:EI_MAG3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EI_MAG3\~ 3}}
\par
{\bkmkstart AAAAAAAAER}
{\bkmkend AAAAAAAAER}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 19 of file exec.c.}\par
}
{\xe \v EI_NIDENT\:exec.c}
{\xe \v exec.c\:EI_NIDENT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EI_NIDENT\~ 16}}
\par
{\bkmkstart AAAAAAAAES}
{\bkmkend AAAAAAAAES}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 15 of file exec.c.}\par
}
{\xe \v EI_PAD\:exec.c}
{\xe \v exec.c\:EI_PAD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EI_PAD\~ 7}}
\par
{\bkmkstart AAAAAAAAET}
{\bkmkend AAAAAAAAET}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 23 of file exec.c.}\par
}
{\xe \v EI_VERSION\:exec.c}
{\xe \v exec.c\:EI_VERSION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EI_VERSION\~ 6}}
\par
{\bkmkstart AAAAAAAAEU}
{\bkmkend AAAAAAAAEU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 22 of file exec.c.}\par
}
{\xe \v ELF_CLASS_32\:exec.c}
{\xe \v exec.c\:ELF_CLASS_32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ELF_CLASS_32\~ 1}}
\par
{\bkmkstart AAAAAAAAEV}
{\bkmkend AAAAAAAAEV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 30 of file exec.c.}\par
}
{\xe \v ELF_CLASS_64\:exec.c}
{\xe \v exec.c\:ELF_CLASS_64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ELF_CLASS_64\~ 2}}
\par
{\bkmkstart AAAAAAAAEW}
{\bkmkend AAAAAAAAEW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 31 of file exec.c.}\par
}
{\xe \v ELF_DATA_LSB\:exec.c}
{\xe \v exec.c\:ELF_DATA_LSB}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ELF_DATA_LSB\~ 1}}
\par
{\bkmkstart AAAAAAAAEX}
{\bkmkend AAAAAAAAEX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 33 of file exec.c.}\par
}
{\xe \v ELF_DATA_MSB\:exec.c}
{\xe \v exec.c\:ELF_DATA_MSB}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ELF_DATA_MSB\~ 2}}
\par
{\bkmkstart AAAAAAAAEY}
{\bkmkend AAAAAAAAEY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 34 of file exec.c.}\par
}
{\xe \v ELF_DEBUG\:exec.c}
{\xe \v exec.c\:ELF_DEBUG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ELF_DEBUG}}
\par
{\bkmkstart AAAAAAAAEZ}
{\bkmkend AAAAAAAAEZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enable or disable debug for ELF. }}\par
{
Definition at line 58 of file exec.c.}\par
}
{\xe \v ELF_MAG0\:exec.c}
{\xe \v exec.c\:ELF_MAG0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ELF_MAG0\~ 0x7F}}
\par
{\bkmkstart AAAAAAAAFA}
{\bkmkend AAAAAAAAFA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 25 of file exec.c.}\par
}
{\xe \v ELF_MAG1\:exec.c}
{\xe \v exec.c\:ELF_MAG1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ELF_MAG1\~ 'E'}}
\par
{\bkmkstart AAAAAAAAFB}
{\bkmkend AAAAAAAAFB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 26 of file exec.c.}\par
}
{\xe \v ELF_MAG2\:exec.c}
{\xe \v exec.c\:ELF_MAG2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ELF_MAG2\~ 'L'}}
\par
{\bkmkstart AAAAAAAAFC}
{\bkmkend AAAAAAAAFC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 27 of file exec.c.}\par
}
{\xe \v ELF_MAG3\:exec.c}
{\xe \v exec.c\:ELF_MAG3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ELF_MAG3\~ 'F'}}
\par
{\bkmkstart AAAAAAAAFD}
{\bkmkend AAAAAAAAFD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 28 of file exec.c.}\par
}
{\xe \v SHF_ALLOC\:exec.c}
{\xe \v exec.c\:SHF_ALLOC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SHF_ALLOC\~ 2}}
\par
{\bkmkstart AAAAAAAAFE}
{\bkmkend AAAAAAAAFE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 51 of file exec.c.}\par
}
{\xe \v SHF_EXECINSTR\:exec.c}
{\xe \v exec.c\:SHF_EXECINSTR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SHF_EXECINSTR\~ 4}}
\par
{\bkmkstart AAAAAAAAFF}
{\bkmkend AAAAAAAAFF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 52 of file exec.c.}\par
}
{\xe \v SHF_MASK\:exec.c}
{\xe \v exec.c\:SHF_MASK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SHF_MASK\~ 0xF0000000}}
\par
{\bkmkstart AAAAAAAAFG}
{\bkmkend AAAAAAAAFG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 53 of file exec.c.}\par
}
{\xe \v SHF_WRITE\:exec.c}
{\xe \v exec.c\:SHF_WRITE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SHF_WRITE\~ 1}}
\par
{\bkmkstart AAAAAAAAFH}
{\bkmkend AAAAAAAAFH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 50 of file exec.c.}\par
}
{\xe \v SHT_DYNAMIC\:exec.c}
{\xe \v exec.c\:SHT_DYNAMIC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SHT_DYNAMIC\~ 6}}
\par
{\bkmkstart AAAAAAAAFI}
{\bkmkend AAAAAAAAFI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 43 of file exec.c.}\par
}
{\xe \v SHT_DYNSYM\:exec.c}
{\xe \v exec.c\:SHT_DYNSYM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SHT_DYNSYM\~ 11}}
\par
{\bkmkstart AAAAAAAAFJ}
{\bkmkend AAAAAAAAFJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 48 of file exec.c.}\par
}
{\xe \v SHT_HASH\:exec.c}
{\xe \v exec.c\:SHT_HASH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SHT_HASH\~ 5}}
\par
{\bkmkstart AAAAAAAAFK}
{\bkmkend AAAAAAAAFK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 42 of file exec.c.}\par
}
{\xe \v SHT_NOBITS\:exec.c}
{\xe \v exec.c\:SHT_NOBITS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SHT_NOBITS\~ 8}}
\par
{\bkmkstart AAAAAAAAFL}
{\bkmkend AAAAAAAAFL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 45 of file exec.c.}\par
}
{\xe \v SHT_NOTE\:exec.c}
{\xe \v exec.c\:SHT_NOTE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SHT_NOTE\~ 7}}
\par
{\bkmkstart AAAAAAAAFM}
{\bkmkend AAAAAAAAFM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 44 of file exec.c.}\par
}
{\xe \v SHT_NULL\:exec.c}
{\xe \v exec.c\:SHT_NULL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SHT_NULL\~ 0}}
\par
{\bkmkstart AAAAAAAAFN}
{\bkmkend AAAAAAAAFN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 37 of file exec.c.}\par
}
{\xe \v SHT_PROGBITS\:exec.c}
{\xe \v exec.c\:SHT_PROGBITS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SHT_PROGBITS\~ 1}}
\par
{\bkmkstart AAAAAAAAFO}
{\bkmkend AAAAAAAAFO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 38 of file exec.c.}\par
}
{\xe \v SHT_REL\:exec.c}
{\xe \v exec.c\:SHT_REL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SHT_REL\~ 9}}
\par
{\bkmkstart AAAAAAAAFP}
{\bkmkend AAAAAAAAFP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 46 of file exec.c.}\par
}
{\xe \v SHT_RELA\:exec.c}
{\xe \v exec.c\:SHT_RELA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SHT_RELA\~ 4}}
\par
{\bkmkstart AAAAAAAAFQ}
{\bkmkend AAAAAAAAFQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 41 of file exec.c.}\par
}
{\xe \v SHT_SHLIB\:exec.c}
{\xe \v exec.c\:SHT_SHLIB}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SHT_SHLIB\~ 10}}
\par
{\bkmkstart AAAAAAAAFR}
{\bkmkend AAAAAAAAFR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 47 of file exec.c.}\par
}
{\xe \v SHT_STRTAB\:exec.c}
{\xe \v exec.c\:SHT_STRTAB}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SHT_STRTAB\~ 3}}
\par
{\bkmkstart AAAAAAAAFS}
{\bkmkend AAAAAAAAFS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 40 of file exec.c.}\par
}
{\xe \v SHT_SYMTAB\:exec.c}
{\xe \v exec.c\:SHT_SYMTAB}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SHT_SYMTAB\~ 2}}
\par
{\bkmkstart AAAAAAAAFT}
{\bkmkend AAAAAAAAFT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 39 of file exec.c.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v Elf32_Addr\:exec.c}
{\xe \v exec.c\:Elf32_Addr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b uint32_t} {\b Elf32_Addr}}}
\par
{\bkmkstart AAAAAAAAFU}
{\bkmkend AAAAAAAAFU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 8 of file exec.c.}\par
}
{\xe \v Elf32_Half\:exec.c}
{\xe \v exec.c\:Elf32_Half}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b uint16_t} {\b Elf32_Half}}}
\par
{\bkmkstart AAAAAAAAFV}
{\bkmkend AAAAAAAAFV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9 of file exec.c.}\par
}
{\xe \v elf32_hdr_t\:exec.c}
{\xe \v exec.c\:elf32_hdr_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b elf32_hdr}  {\b elf32_hdr_t}}}
\par
{\bkmkstart AAAAAAAAFW}
{\bkmkend AAAAAAAAFW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ELF32 Header. }}\par
}
{\xe \v Elf32_Off\:exec.c}
{\xe \v exec.c\:Elf32_Off}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b uint32_t} {\b Elf32_Off}}}
\par
{\bkmkstart AAAAAAAAFX}
{\bkmkend AAAAAAAAFX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 10 of file exec.c.}\par
}
{\xe \v elf32_shdr_t\:exec.c}
{\xe \v exec.c\:elf32_shdr_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b elf32_shdr}  {\b elf32_shdr_t}}}
\par
{\bkmkstart AAAAAAAAFY}
{\bkmkend AAAAAAAAFY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ELF32 Section Header. }}\par
}
{\xe \v Elf32_Sword\:exec.c}
{\xe \v exec.c\:Elf32_Sword}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef int32_t {\b Elf32_Sword}}}
\par
{\bkmkstart AAAAAAAAFZ}
{\bkmkend AAAAAAAAFZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 11 of file exec.c.}\par
}
{\xe \v Elf32_Word\:exec.c}
{\xe \v exec.c\:Elf32_Word}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b uint32_t} {\b Elf32_Word}}}
\par
{\bkmkstart AAAAAAAAGA}
{\bkmkend AAAAAAAAGA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 12 of file exec.c.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v elf32_check\:exec.c}
{\xe \v exec.c\:elf32_check}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int elf32_check ({\b elf32_hdr_t} * {\i hdr})}}
\par
{\bkmkstart AAAAAAAAGB}
{\bkmkend AAAAAAAAGB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check for valid ELF32 header. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i hdr} \cell }{ELF32 Header. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid 0 for valid header or -1 in case of errors. \par
}}{
Definition at line 104 of file exec.c.}\par
{
References check, elf32_hdr::e_ident, EI_CLASS, EI_DATA, EI_MAG0, EI_MAG1, EI_MAG2, EI_MAG3, ELF_CLASS_32, ELF_DATA_LSB, ELF_MAG0, ELF_MAG1, ELF_MAG2, and ELF_MAG3.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 104                                   \{\par
105 \par
106     #define check(cond)             \\\par
107         if(cond) \{                  \\\par
108             errno = ENOEXEC;        \\\par
109             return -1;              \\\par
110         \}\par
111 \par
112     check(\par
113         (hdr->e_ident[EI_MAG0] != ELF_MAG0) ||\par
114         (hdr->e_ident[EI_MAG1] != ELF_MAG1) ||\par
115         (hdr->e_ident[EI_MAG2] != ELF_MAG2) ||\par
116         (hdr->e_ident[EI_MAG3] != ELF_MAG3)\par
117     )\par
118 \par
119     check(hdr->e_ident[EI_CLASS] != ELF_CLASS_32)\par
120     check(hdr->e_ident[EI_DATA] != ELF_DATA_LSB)\par
121 \par
122     return 0;\par
123 \}\par
}
}
{\xe \v elf32_load\:exec.c}
{\xe \v exec.c\:elf32_load}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* elf32_load (void * {\i image})}}
\par
{\bkmkstart AAAAAAAAGC}
{\bkmkend AAAAAAAAGC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Load a ELF32 Executable image. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i image} \cell }{pointer to buffer address of a executable loaded in memory. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid Entry Point address. \par
}}{
Definition at line 131 of file exec.c.}\par
{
References elf32_hdr::e_shoff, elf32_check(), errno, kprintf(), MM_UBASE, MM_USIZE, panic(), elf32_shdr::sh_addr, elf32_shdr::sh_offset, elf32_shdr::sh_size, uint32_t, vmm_alloc(), VMM_FLAGS_DEFAULT, and VMM_FLAGS_USER.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 131                               \{\par
132     if(image == NULL) \{\par
133         errno = EINVAL;\par
134         return NULL;\par
135     \}\par
136 \par
137     if(elf32_check(image) < 0)\par
138         return NULL;\par
139 \par
140     elf32_hdr_t* hdr = (elf32_hdr_t*) image;\par
141     elf32_shdr_t* sec = (elf32_shdr_t*) ((uint32_t) hdr->e_shoff + (uint32_t) hdr);\par
142     \par
143     int sn = hdr->e_shnum;\par
144     int ss = hdr->e_shentsize;\par
145      \par
146     for(int i = 0; i < sn; i++) \{\par
147         \par
148         if(sec->sh_addr && sec->sh_offset) \{\par
149 \par
150 #ifdef ELF_DEBUG\par
151             kprintf("elf: copy section to 0x%8x (%d Bytes)\\n", sec->sh_addr, sec->sh_size);\par
152 #endif\par
153 \par
154 \par
155             if((sec->sh_addr + sec->sh_size) < MM_UBASE || (sec->sh_addr + sec->sh_size) > (MM_UBASE + MM_USIZE))\par
156                 panic("elf section overflow");\par
157             \par
158 \par
159             if(vmm_alloc((void*) sec->sh_addr, sec->sh_size, VMM_FLAGS_DEFAULT | VMM_FLAGS_USER))\par
160                 memcpy((void*) sec->sh_addr, (void*) ((uint32_t) hdr + sec->sh_offset), sec->sh_size);\par
161             else\par
162                 panic("elf: cannot allocate memory");\par
163         \}\par
164 \par
165         sec = (elf32_shdr_t*) ((uint32_t) sec + ss);\par
166     \}\par
167 \par
168 #ifdef ELF_DEBUG\par
169     kprintf("elf: entrypoint at 0x%8x\\n", hdr->e_entry);\par
170 #endif\par
171 \par
172     return (void*) hdr->e_entry;\par
173 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/fs/devfs.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/fs/devfs.c}
{\xe \v src/fs/devfs.c}
{\bkmkstart AAAAAAAAGD}
{\bkmkend AAAAAAAAGD}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
{\f2 #include <stddef.h>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <sys/stat.h>}\par
{\f2 #include <sys/types.h>}\par
{\f2 #include <fcntl.h>}\par
{\f2 #include <dirent.h>}\par
{\f2 #include <errno.h>}\par
{\f2 #include <aplus.h>}\par
{\f2 #include <aplus/task.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b inode_t} * {\b devfs_getdevice} (dev_t dev)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b inode} * {\b devfs_creat} (struct {\b inode} *{\b inode}, char *{\b name}, mode_t mode)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b inode_t} * {\b devfs_mount} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b inode_t} * {\b vfs_root}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b task_t} * {\b current_task}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current task address. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b inode_t} * {\b devfs}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v devfs_creat\:devfs.c}
{\xe \v devfs.c\:devfs_creat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b inode}* devfs_creat (struct {\b inode} * {\i inode}, char * {\i name}, mode_t {\i mode})}}
\par
{\bkmkstart AAAAAAAAGE}
{\bkmkend AAAAAAAAGE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 35 of file devfs.c.}\par
{
References inode::atime, inode::chown, inode::creat, inode::ctime, inode::dev, inode::finddir, inode::flush, inode::gid, task::gid, inode::ino, inode::ioctl, kmalloc(), inode::link, inode::mode, inode::mtime, inode::name, inode::nlink, inode::parent, inode::rdev, inode::read, inode::readdir, inode::rename, inode::size, sys_time(), inode::uid, task::uid, inode::unlink, vfs_map(), vfs_mapped(), and inode::write.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 35                                                                          \{\par
36     if((void*) vfs_mapped(inode, name) != NULL)\par
37         return NULL;\par
38         \par
39     inode_t* ino = (inode_t*) kmalloc(sizeof(inode_t));\par
40     strcpy(ino->name, name);\par
41     \par
42     ino->dev = inode->dev;\par
43     ino->ino = 0;\par
44     ino->mode = mode;\par
45     ino->nlink = 0;\par
46     ino->uid = current_task->uid;\par
47     ino->gid = current_task->gid;\par
48     ino->rdev = ino->rdev;\par
49     ino->size = (size_t) 0;\par
50     ino->atime = ino->ctime = ino->mtime = sys_time(NULL);\par
51     ino->parent = inode;\par
52     ino->link = NULL;\par
53     \par
54     ino->read = NULL;\par
55     ino->write = NULL;\par
56     ino->readdir = NULL;\par
57     ino->finddir = NULL;\par
58     ino->creat = NULL;\par
59     ino->rename = NULL;\par
60     ino->unlink = NULL;\par
61     ino->chown = NULL;\par
62     ino->flush = NULL;\par
63     ino->ioctl = NULL;\par
64     \par
65     vfs_map(ino);\par
66     \par
67     return ino;\par
68 \}\par
}
}
{\xe \v devfs_getdevice\:devfs.c}
{\xe \v devfs.c\:devfs_getdevice}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b inode_t}* devfs_getdevice (dev_t {\i dev})}}
\par
{\bkmkstart AAAAAAAAGF}
{\bkmkend AAAAAAAAGF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 23 of file devfs.c.}\par
{
References inode::ino, and vfs_mapped_at_index().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 23                                     \{\par
24     int index = 0;\par
25     inode_t* map = NULL;\par
26 \par
27     while((map = (inode_t*) vfs_mapped_at_index(devfs, index++)) != NULL)\par
28         if(map->ino == dev)\par
29             return map;\par
30     \par
31     return NULL;\par
32 \}\par
}
}
{\xe \v devfs_mount\:devfs.c}
{\xe \v devfs.c\:devfs_mount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b inode_t}* devfs_mount ()}}
\par
{\bkmkstart AAAAAAAAGG}
{\bkmkend AAAAAAAAGG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 71 of file devfs.c.}\par
{
References inode::atime, inode::chown, inode::creat, inode::ctime, inode::dev, devfs, devfs_creat(), inode::finddir, inode::flush, inode::gid, GID_ROOT, inode::ino, inode::ioctl, kmalloc(), inode::link, inode::mode, inode::mtime, inode::name, inode::nlink, inode::parent, inode::rdev, inode::read, inode::readdir, inode::rename, inode::size, sys_time(), inode::uid, UID_ROOT, inode::unlink, vfs_root, and inode::write.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 71                        \{\par
72     \par
73     devfs = (inode_t*) kmalloc(sizeof(inode_t));\par
74     strcpy(devfs->name, "dev");\par
75     \par
76     devfs->dev = (dev_t) 0;\par
77     devfs->ino = (ino_t) 0;\par
78     devfs->mode = S_IFDIR;\par
79     devfs->nlink = 0;\par
80     devfs->uid = UID_ROOT;\par
81     devfs->gid = GID_ROOT;\par
82     devfs->rdev = (dev_t) 0;\par
83     devfs->size = (size_t) 0;\par
84     devfs->atime = devfs->ctime = devfs->mtime = sys_time(NULL);\par
85     devfs->parent = vfs_root;\par
86     devfs->link = NULL;\par
87     \par
88     devfs->read = NULL;\par
89     devfs->write = NULL;\par
90     devfs->readdir = NULL;\par
91     devfs->finddir = NULL;\par
92     devfs->creat = devfs_creat;\par
93     devfs->rename = NULL;\par
94     devfs->unlink = NULL;\par
95     devfs->chown = NULL;\par
96     devfs->flush = NULL;\par
97     devfs->ioctl = NULL;\par
98     \par
99     return devfs;\par
100 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v current_task\:devfs.c}
{\xe \v devfs.c\:current_task}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b task_t}* current_task}}
\par
{\bkmkstart AAAAAAAAGH}
{\bkmkend AAAAAAAAGH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current task address. }}\par
{
Definition at line 35 of file sched.c.}\par
}
{\xe \v devfs\:devfs.c}
{\xe \v devfs.c\:devfs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b inode_t}* devfs}}
\par
{\bkmkstart AAAAAAAAGI}
{\bkmkend AAAAAAAAGI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 20 of file devfs.c.}\par
}
{\xe \v vfs_root\:devfs.c}
{\xe \v devfs.c\:vfs_root}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b inode_t}* vfs_root}}
\par
{\bkmkstart AAAAAAAAGJ}
{\bkmkend AAAAAAAAGJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 19 of file vfs.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/fs/fs.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/fs/fs.c}
{\xe \v src/fs/fs.c}
{\bkmkstart AAAAAAAAGK}
{\bkmkend AAAAAAAAGK}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <aplus.h>}\par
{\f2 #include <aplus/fs.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <stddef.h>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <sys/stat.h>}\par
{\f2 #include <sys/types.h>}\par
{\f2 #include <fcntl.h>}\par
{\f2 #include <dirent.h>}\par
{\f2 #include <errno.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b fs_read} (struct {\b inode} *{\b inode}, char *ptr, int len)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b fs_write} (struct {\b inode} *{\b inode}, char *ptr, int len)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b dirent} * {\b fs_readdir} (struct {\b inode} *{\b inode}, int index)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b inode} * {\b fs_finddir} (struct {\b inode} *{\b inode}, char *{\b name})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b inode} * {\b fs_creat} (struct {\b inode} *{\b inode}, char *{\b name}, mode_t mode)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b fs_rename} (struct {\b inode} *{\b inode}, char *oldname, char *newname)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b fs_unlink} (struct {\b inode} *{\b inode}, char *{\b name})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b fs_chown} (struct {\b inode} *{\b inode}, uid_t owner, gid_t group)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fs_flush} (struct {\b inode} *{\b inode})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b fs_ioctl} (struct {\b inode} *{\b inode}, int req, void *buf)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v fs_chown\:fs.c}
{\xe \v fs.c\:fs_chown}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int fs_chown (struct {\b inode} * {\i inode}, uid_t {\i owner}, gid_t {\i group})}}
\par
{\bkmkstart AAAAAAAAGL}
{\bkmkend AAAAAAAAGL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 93 of file fs.c.}\par
{
References inode::chown, and errno.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 93                                                              \{\par
94     if(inode->chown)\par
95         return inode->chown(inode, owner, group);\par
96         \par
97     errno = ENOSYS; \par
98     return -1;\par
99 \}\par
}
}
{\xe \v fs_creat\:fs.c}
{\xe \v fs.c\:fs_creat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b inode}* fs_creat (struct {\b inode} * {\i inode}, char * {\i name}, mode_t {\i mode})}}
\par
{\bkmkstart AAAAAAAAGM}
{\bkmkend AAAAAAAAGM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 69 of file fs.c.}\par
{
References inode::creat, and errno.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 69                                                                       \{\par
70     if(inode->creat)\par
71         return inode->creat(inode, name, mode);\par
72     \par
73     errno = ENOSYS;     \par
74     return NULL;\par
75 \}\par
}
}
{\xe \v fs_finddir\:fs.c}
{\xe \v fs.c\:fs_finddir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b inode}* fs_finddir (struct {\b inode} * {\i inode}, char * {\i name})}}
\par
{\bkmkstart AAAAAAAAGN}
{\bkmkend AAAAAAAAGN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 50 of file fs.c.}\par
{
References errno, inode::finddir, inode::parent, and vfs_mapped().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 50                                                            \{\par
51 \par
52     if(strcmp(name, ".") == 0)\par
53         return inode;\par
54 \par
55     if(strcmp(name, "..") == 0)\par
56         return inode->parent;\par
57 \par
58     inode_t* map = NULL;\par
59     if((map = (inode_t*) vfs_mapped(inode, name)) != NULL)\par
60         return map;\par
61 \par
62     if(inode->finddir)\par
63         return inode->finddir(inode, name);\par
64         \par
65     errno = ENOSYS; \par
66     return NULL;\par
67 \}\par
}
}
{\xe \v fs_flush\:fs.c}
{\xe \v fs.c\:fs_flush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fs_flush (struct {\b inode} * {\i inode})}}
\par
{\bkmkstart AAAAAAAAGO}
{\bkmkend AAAAAAAAGO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 101 of file fs.c.}\par
{
References errno, and inode::flush.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 101                                    \{\par
102     if(inode->flush)\par
103         inode->flush(inode);\par
104         \par
105     errno = ENOSYS; \par
106     return;\par
107 \}\par
}
}
{\xe \v fs_ioctl\:fs.c}
{\xe \v fs.c\:fs_ioctl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int fs_ioctl (struct {\b inode} * {\i inode}, int {\i req}, void * {\i buf})}}
\par
{\bkmkstart AAAAAAAAGP}
{\bkmkend AAAAAAAAGP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 109 of file fs.c.}\par
{
References errno, and inode::ioctl.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 109                                                       \{\par
110     if(inode->ioctl)\par
111         return inode->ioctl(inode, req, buf);\par
112     \par
113     errno = ENOSYS; \par
114     return -1;\par
115 \}\par
}
}
{\xe \v fs_read\:fs.c}
{\xe \v fs.c\:fs_read}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int fs_read (struct {\b inode} * {\i inode}, char * {\i ptr}, int {\i len})}}
\par
{\bkmkstart AAAAAAAAGQ}
{\bkmkend AAAAAAAAGQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 16 of file fs.c.}\par
{
References errno, and inode::read.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 16                                                       \{\par
17     if(inode->read)\par
18         return inode->read(inode, ptr, len);\par
19     \par
20     errno = ENOSYS;     \par
21     return 0;\par
22 \}\par
}
}
{\xe \v fs_readdir\:fs.c}
{\xe \v fs.c\:fs_readdir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b dirent}* fs_readdir (struct {\b inode} * {\i inode}, int {\i index})}}
\par
{\bkmkstart AAAAAAAAGR}
{\bkmkend AAAAAAAAGR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 32 of file fs.c.}\par
{
References dirent::d_ino, dirent::d_name, errno, inode::ino, kmalloc(), inode::name, inode::readdir, vfs_mapped_at_index(), and vfs_mapped_count().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 32                                                            \{\par
33 \par
34     inode_t* map = NULL;\par
35     if((map = (inode_t*) vfs_mapped_at_index(inode, index)) != NULL) \{\par
36         struct dirent* ent = (struct dirent*) kmalloc(sizeof(struct dirent));\par
37         strcpy(ent->d_name, map->name);\par
38         ent->d_ino = map->ino;\par
39         \par
40         return ent;\par
41     \}\par
42 \par
43     if(inode->readdir)\par
44         return inode->readdir(inode, index - vfs_mapped_count(inode));\par
45         \par
46     errno = ENOSYS; \par
47     return NULL;\par
48 \}\par
}
}
{\xe \v fs_rename\:fs.c}
{\xe \v fs.c\:fs_rename}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int fs_rename (struct {\b inode} * {\i inode}, char * {\i oldname}, char * {\i newname})}}
\par
{\bkmkstart AAAAAAAAGS}
{\bkmkend AAAAAAAAGS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 77 of file fs.c.}\par
{
References errno, and inode::rename.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 77                                                                   \{\par
78     if(inode->rename)\par
79         return inode->rename(inode, oldname, newname);\par
80     \par
81     errno = ENOSYS;     \par
82     return -1;\par
83 \}\par
}
}
{\xe \v fs_unlink\:fs.c}
{\xe \v fs.c\:fs_unlink}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int fs_unlink (struct {\b inode} * {\i inode}, char * {\i name})}}
\par
{\bkmkstart AAAAAAAAGT}
{\bkmkend AAAAAAAAGT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 85 of file fs.c.}\par
{
References errno, and inode::unlink.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 85                                                 \{\par
86     if(inode->unlink)\par
87         return inode->unlink(inode, name);\par
88         \par
89     errno = ENOSYS; \par
90     return -1;\par
91 \}\par
}
}
{\xe \v fs_write\:fs.c}
{\xe \v fs.c\:fs_write}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int fs_write (struct {\b inode} * {\i inode}, char * {\i ptr}, int {\i len})}}
\par
{\bkmkstart AAAAAAAAGU}
{\bkmkend AAAAAAAAGU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 24 of file fs.c.}\par
{
References errno, and inode::write.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 24                                                        \{\par
25     if(inode->write)\par
26         return inode->write(inode, ptr, len);\par
27         \par
28     errno = ENOSYS; \par
29     return 0;\par
30 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/fs/iso9660/iso9660.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/fs/iso9660/iso9660.c}
{\xe \v src/fs/iso9660/iso9660.c}
{\bkmkstart AAAAAAAAGV}
{\bkmkend AAAAAAAAGV}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <aplus.h>}\par
{\f2 #include <aplus/fs.h>}\par
{\f2 #include <aplus/task.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <dirent.h>}\par
{\f2 #include <fcntl.h>}\par
{\f2 #include <sys/types.h>}\par
{\f2 #include "iso9660.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b iso9660_getroot} ({\b inode_t} *dev)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b iso9660_check} ({\b inode_t} *dev)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b iso9660_checkname} (char *{\b name})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b iso9660_getmsb16} ({\b uint32_t} val)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b iso9660_getmsb32} (uint64_t val)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b iso9660_getlsb16} ({\b uint32_t} val)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b iso9660_getlsb32} (uint64_t val)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v iso9660_check\:iso9660.c}
{\xe \v iso9660.c\:iso9660_check}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int iso9660_check ({\b inode_t} * {\i dev})}}
\par
{\bkmkstart AAAAAAAAGW}
{\bkmkend AAAAAAAAGW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 31 of file iso9660.c.}\par
{
References fs_read(), ISO9660_ID, ISO9660_PVD, ISO9660_VOLDESC_SIZE, kfree(), kmalloc(), and inode::position.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 31                                 \{\par
32     iso9660_pvd_t* pvd = (iso9660_pvd_t*) kmalloc(ISO9660_VOLDESC_SIZE);\par
33     memset(pvd, 0, ISO9660_VOLDESC_SIZE);\par
34 \par
35     dev->position = ISO9660_PVD;\par
36     if(fs_read(dev, pvd, ISO9660_VOLDESC_SIZE) != ISO9660_VOLDESC_SIZE) \{\par
37         kfree(pvd);\par
38         return 0;\par
39     \}\par
40 \par
41     int ret = strncmp(pvd->id, ISO9660_ID, 5);\par
42     kfree(pvd);\par
43 \par
44     return ret;\par
45 \}\par
}
}
{\xe \v iso9660_checkname\:iso9660.c}
{\xe \v iso9660.c\:iso9660_checkname}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void iso9660_checkname (char * {\i name})}}
\par
{\bkmkstart AAAAAAAAGX}
{\bkmkend AAAAAAAAGX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 47 of file iso9660.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 47                                    \{\par
48     char* p = strchr(name, ';');\par
49     if(p) \{\par
50         *p-- = 0;\par
51     \par
52         if(*p == '.')\par
53             *p = 0;\par
54     \}\par
55 \par
56     for(int i = 0; i < strlen(name); i++)\par
57         if(name[i] >= 'A' && name[i] <= 'Z')\par
58             name[i] += 32;\par
59 \}\par
}
}
{\xe \v iso9660_getlsb16\:iso9660.c}
{\xe \v iso9660.c\:iso9660_getlsb16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} iso9660_getlsb16 ({\b uint32_t} {\i val})}}
\par
{\bkmkstart AAAAAAAAGY}
{\bkmkend AAAAAAAAGY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 69 of file iso9660.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 69                                         \{\par
70     return (val >> 0) & 0xFFFF;\par
71 \}\par
}
}
{\xe \v iso9660_getlsb32\:iso9660.c}
{\xe \v iso9660.c\:iso9660_getlsb32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} iso9660_getlsb32 (uint64_t {\i val})}}
\par
{\bkmkstart AAAAAAAAGZ}
{\bkmkend AAAAAAAAGZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 73 of file iso9660.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 73                                         \{\par
74     return (val >> 0) & 0xFFFFFFFF;\par
75 \}\par
}
}
{\xe \v iso9660_getmsb16\:iso9660.c}
{\xe \v iso9660.c\:iso9660_getmsb16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} iso9660_getmsb16 ({\b uint32_t} {\i val})}}
\par
{\bkmkstart AAAAAAAAHA}
{\bkmkend AAAAAAAAHA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 61 of file iso9660.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 61                                         \{\par
62     return (val >> 16) & 0xFFFF;\par
63 \}\par
}
}
{\xe \v iso9660_getmsb32\:iso9660.c}
{\xe \v iso9660.c\:iso9660_getmsb32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} iso9660_getmsb32 (uint64_t {\i val})}}
\par
{\bkmkstart AAAAAAAAHB}
{\bkmkend AAAAAAAAHB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 65 of file iso9660.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 65                                         \{\par
66     return (val >> 32) & 0xFFFFFFFF;\par
67 \}\par
}
}
{\xe \v iso9660_getroot\:iso9660.c}
{\xe \v iso9660.c\:iso9660_getroot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} iso9660_getroot ({\b inode_t} * {\i dev})}}
\par
{\bkmkstart AAAAAAAAHC}
{\bkmkend AAAAAAAAHC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 14 of file iso9660.c.}\par
{
References fs_read(), ISO9660_PVD, ISO9660_VOLDESC_SIZE, kfree(), kmalloc(), inode::position, and uint32_t.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14                                        \{\par
15     iso9660_pvd_t* pvd = (iso9660_pvd_t*) kmalloc(ISO9660_VOLDESC_SIZE);\par
16     memset(pvd, 0, ISO9660_VOLDESC_SIZE);\par
17 \par
18     dev->position = ISO9660_PVD;\par
19     if(fs_read(dev, pvd, ISO9660_VOLDESC_SIZE) != ISO9660_VOLDESC_SIZE) \{\par
20         kfree(pvd);\par
21         return 0;\par
22     \}\par
23 \par
24     uint32_t ret = (uint32_t) pvd->rootdir;\par
25     kfree(pvd);\par
26 \par
27     return ret;\par
28 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/fs/iso9660/iso9660.h File Reference\par \pard\plain 
{\tc\tcl2 \v src/fs/iso9660/iso9660.h}
{\xe \v src/fs/iso9660/iso9660.h}
{\bkmkstart AAAAAAAAHD}
{\bkmkend AAAAAAAAHD}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b iso9660_volume_descriptor}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b iso9660_pvd}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b iso9660_dir}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ISO9660_SECTOR_SIZE}\~ 2048\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ISO9660_PVD}\~ (0x10 * ISO9660_SECTOR_SIZE)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ISO9660_ID}\~ "CD001"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ISO9660_VERSION}\~ 0x01\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ISO9660_VOLDESC_BOOTRECORD}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ISO9660_VOLDESC_PRIMARY}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ISO9660_VOLDESC_SUPPLEMENTARY}\~ 2\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ISO9660_VOLDESC_PARTITION}\~ 3\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ISO9660_VOLDESC_TERMINATOR}\~ 255\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ISO9660_VOLDESC_SIZE}\~ {\b ISO9660_SECTOR_SIZE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ISO9660_FLAGS_HIDDEN}\~ (1 << 0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ISO9660_FLAGS_DIRECTORY}\~ (1 << 1)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ISO9660_FLAGS_FILE}\~ (1 << 2)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ISO9660_FLAGS_EXTATTR}\~ (1 << 3)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ISO9660_FLAGS_EXTFLAGS}\~ (1 << 4)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ISO9660_FLAGS_NOTLAST}\~ (1 << 7)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b iso9660_volume_descriptor} {\b __attribute__} ((packed)) iso9660_volume_descriptor_t\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b type}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b id} [5]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b version}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b data} [2041]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b unused}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b sysid} [32]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b volid} [32]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b null0} [8]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b volsize}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b null1} [32]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b volsetsize}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b volnumber}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b logical_blksize}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b path_size}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b path_lba}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b optpath_lba}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b path_lba_msb}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b optpath_lba_msb}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b rootdir} [34]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b volsetid} [128]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b pubid} [128]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b dataid} [128]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b appid} [128]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b copyid} [38]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b abstractfileid} [36]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b bibid} [37]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b cdate} [17]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b mdate} [17]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b edate} [17]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b efdate} [17]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b fileversion}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b unused0}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b null2} [512]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b reserved} [653]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b size}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b exattr}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b lba}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b length}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b date} [7]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b flags}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b unitsize}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b gapsize}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b idlen}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v ISO9660_FLAGS_DIRECTORY\:iso9660.h}
{\xe \v iso9660.h\:ISO9660_FLAGS_DIRECTORY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ISO9660_FLAGS_DIRECTORY\~ (1 << 1)}}
\par
{\bkmkstart AAAAAAAAHE}
{\bkmkend AAAAAAAAHE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 23 of file iso9660.h.}\par
}
{\xe \v ISO9660_FLAGS_EXTATTR\:iso9660.h}
{\xe \v iso9660.h\:ISO9660_FLAGS_EXTATTR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ISO9660_FLAGS_EXTATTR\~ (1 << 3)}}
\par
{\bkmkstart AAAAAAAAHF}
{\bkmkend AAAAAAAAHF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 25 of file iso9660.h.}\par
}
{\xe \v ISO9660_FLAGS_EXTFLAGS\:iso9660.h}
{\xe \v iso9660.h\:ISO9660_FLAGS_EXTFLAGS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ISO9660_FLAGS_EXTFLAGS\~ (1 << 4)}}
\par
{\bkmkstart AAAAAAAAHG}
{\bkmkend AAAAAAAAHG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 26 of file iso9660.h.}\par
}
{\xe \v ISO9660_FLAGS_FILE\:iso9660.h}
{\xe \v iso9660.h\:ISO9660_FLAGS_FILE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ISO9660_FLAGS_FILE\~ (1 << 2)}}
\par
{\bkmkstart AAAAAAAAHH}
{\bkmkend AAAAAAAAHH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 24 of file iso9660.h.}\par
}
{\xe \v ISO9660_FLAGS_HIDDEN\:iso9660.h}
{\xe \v iso9660.h\:ISO9660_FLAGS_HIDDEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ISO9660_FLAGS_HIDDEN\~ (1 << 0)}}
\par
{\bkmkstart AAAAAAAAHI}
{\bkmkend AAAAAAAAHI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 22 of file iso9660.h.}\par
}
{\xe \v ISO9660_FLAGS_NOTLAST\:iso9660.h}
{\xe \v iso9660.h\:ISO9660_FLAGS_NOTLAST}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ISO9660_FLAGS_NOTLAST\~ (1 << 7)}}
\par
{\bkmkstart AAAAAAAAHJ}
{\bkmkend AAAAAAAAHJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 27 of file iso9660.h.}\par
}
{\xe \v ISO9660_ID\:iso9660.h}
{\xe \v iso9660.h\:ISO9660_ID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ISO9660_ID\~ "CD001"}}
\par
{\bkmkstart AAAAAAAAHK}
{\bkmkend AAAAAAAAHK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 10 of file iso9660.h.}\par
}
{\xe \v ISO9660_PVD\:iso9660.h}
{\xe \v iso9660.h\:ISO9660_PVD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ISO9660_PVD\~ (0x10 * ISO9660_SECTOR_SIZE)}}
\par
{\bkmkstart AAAAAAAAHL}
{\bkmkend AAAAAAAAHL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9 of file iso9660.h.}\par
}
{\xe \v ISO9660_SECTOR_SIZE\:iso9660.h}
{\xe \v iso9660.h\:ISO9660_SECTOR_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ISO9660_SECTOR_SIZE\~ 2048}}
\par
{\bkmkstart AAAAAAAAHM}
{\bkmkend AAAAAAAAHM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 7 of file iso9660.h.}\par
}
{\xe \v ISO9660_VERSION\:iso9660.h}
{\xe \v iso9660.h\:ISO9660_VERSION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ISO9660_VERSION\~ 0x01}}
\par
{\bkmkstart AAAAAAAAHN}
{\bkmkend AAAAAAAAHN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 11 of file iso9660.h.}\par
}
{\xe \v ISO9660_VOLDESC_BOOTRECORD\:iso9660.h}
{\xe \v iso9660.h\:ISO9660_VOLDESC_BOOTRECORD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ISO9660_VOLDESC_BOOTRECORD\~ 0}}
\par
{\bkmkstart AAAAAAAAHO}
{\bkmkend AAAAAAAAHO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 13 of file iso9660.h.}\par
}
{\xe \v ISO9660_VOLDESC_PARTITION\:iso9660.h}
{\xe \v iso9660.h\:ISO9660_VOLDESC_PARTITION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ISO9660_VOLDESC_PARTITION\~ 3}}
\par
{\bkmkstart AAAAAAAAHP}
{\bkmkend AAAAAAAAHP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 16 of file iso9660.h.}\par
}
{\xe \v ISO9660_VOLDESC_PRIMARY\:iso9660.h}
{\xe \v iso9660.h\:ISO9660_VOLDESC_PRIMARY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ISO9660_VOLDESC_PRIMARY\~ 1}}
\par
{\bkmkstart AAAAAAAAHQ}
{\bkmkend AAAAAAAAHQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 14 of file iso9660.h.}\par
}
{\xe \v ISO9660_VOLDESC_SIZE\:iso9660.h}
{\xe \v iso9660.h\:ISO9660_VOLDESC_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ISO9660_VOLDESC_SIZE\~ {\b ISO9660_SECTOR_SIZE}}}
\par
{\bkmkstart AAAAAAAAHR}
{\bkmkend AAAAAAAAHR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 19 of file iso9660.h.}\par
}
{\xe \v ISO9660_VOLDESC_SUPPLEMENTARY\:iso9660.h}
{\xe \v iso9660.h\:ISO9660_VOLDESC_SUPPLEMENTARY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ISO9660_VOLDESC_SUPPLEMENTARY\~ 2}}
\par
{\bkmkstart AAAAAAAAHS}
{\bkmkend AAAAAAAAHS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 15 of file iso9660.h.}\par
}
{\xe \v ISO9660_VOLDESC_TERMINATOR\:iso9660.h}
{\xe \v iso9660.h\:ISO9660_VOLDESC_TERMINATOR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ISO9660_VOLDESC_TERMINATOR\~ 255}}
\par
{\bkmkstart AAAAAAAAHT}
{\bkmkend AAAAAAAAHT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 17 of file iso9660.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v __attribute__\:iso9660.h}
{\xe \v iso9660.h\:__attribute__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b iso9660_volume_descriptor} __attribute__ ((packed) )}}
\par
{\bkmkstart AAAAAAAAHU}
{\bkmkend AAAAAAAAHU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 44 of file desc.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 46                        \{\par
47     uint16_t limit;\par
48     uint32_t base;\par
49 \} __attribute__((packed)) gdt_ptr_t;\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v abstractfileid\:iso9660.h}
{\xe \v iso9660.h\:abstractfileid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char abstractfileid[36]}}
\par
{\bkmkstart AAAAAAAAHV}
{\bkmkend AAAAAAAAHV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 102 of file iso9660.h.}\par
}
{\xe \v appid\:iso9660.h}
{\xe \v iso9660.h\:appid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char appid[128]}}
\par
{\bkmkstart AAAAAAAAHW}
{\bkmkend AAAAAAAAHW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 100 of file iso9660.h.}\par
}
{\xe \v bibid\:iso9660.h}
{\xe \v iso9660.h\:bibid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char bibid[37]}}
\par
{\bkmkstart AAAAAAAAHX}
{\bkmkend AAAAAAAAHX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 103 of file iso9660.h.}\par
}
{\xe \v cdate\:iso9660.h}
{\xe \v iso9660.h\:cdate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char cdate[17]}}
\par
{\bkmkstart AAAAAAAAHY}
{\bkmkend AAAAAAAAHY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 104 of file iso9660.h.}\par
}
{\xe \v copyid\:iso9660.h}
{\xe \v iso9660.h\:copyid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char copyid[38]}}
\par
{\bkmkstart AAAAAAAAHZ}
{\bkmkend AAAAAAAAHZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 101 of file iso9660.h.}\par
}
{\xe \v data\:iso9660.h}
{\xe \v iso9660.h\:data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char data[2041]}}
\par
{\bkmkstart AAAAAAAAIA}
{\bkmkend AAAAAAAAIA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 77 of file iso9660.h.}\par
}
{\xe \v dataid\:iso9660.h}
{\xe \v iso9660.h\:dataid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char dataid[128]}}
\par
{\bkmkstart AAAAAAAAIB}
{\bkmkend AAAAAAAAIB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 99 of file iso9660.h.}\par
}
{\xe \v date\:iso9660.h}
{\xe \v iso9660.h\:date}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char date[7]}}
\par
{\bkmkstart AAAAAAAAIC}
{\bkmkend AAAAAAAAIC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 78 of file iso9660.h.}\par
}
{\xe \v edate\:iso9660.h}
{\xe \v iso9660.h\:edate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char edate[17]}}
\par
{\bkmkstart AAAAAAAAID}
{\bkmkend AAAAAAAAID}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 106 of file iso9660.h.}\par
}
{\xe \v efdate\:iso9660.h}
{\xe \v iso9660.h\:efdate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char efdate[17]}}
\par
{\bkmkstart AAAAAAAAIE}
{\bkmkend AAAAAAAAIE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 107 of file iso9660.h.}\par
}
{\xe \v exattr\:iso9660.h}
{\xe \v iso9660.h\:exattr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} exattr}}
\par
{\bkmkstart AAAAAAAAIF}
{\bkmkend AAAAAAAAIF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 75 of file iso9660.h.}\par
}
{\xe \v fileversion\:iso9660.h}
{\xe \v iso9660.h\:fileversion}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t fileversion}}
\par
{\bkmkstart AAAAAAAAIG}
{\bkmkend AAAAAAAAIG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 108 of file iso9660.h.}\par
}
{\xe \v flags\:iso9660.h}
{\xe \v iso9660.h\:flags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} flags}}
\par
{\bkmkstart AAAAAAAAIH}
{\bkmkend AAAAAAAAIH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 79 of file iso9660.h.}\par
}
{\xe \v gapsize\:iso9660.h}
{\xe \v iso9660.h\:gapsize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} gapsize}}
\par
{\bkmkstart AAAAAAAAII}
{\bkmkend AAAAAAAAII}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 81 of file iso9660.h.}\par
}
{\xe \v id\:iso9660.h}
{\xe \v iso9660.h\:id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char id}}
\par
{\bkmkstart AAAAAAAAIJ}
{\bkmkend AAAAAAAAIJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 75 of file iso9660.h.}\par
}
{\xe \v idlen\:iso9660.h}
{\xe \v iso9660.h\:idlen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} idlen}}
\par
{\bkmkstart AAAAAAAAIK}
{\bkmkend AAAAAAAAIK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 83 of file iso9660.h.}\par
}
{\xe \v lba\:iso9660.h}
{\xe \v iso9660.h\:lba}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t lba}}
\par
{\bkmkstart AAAAAAAAIL}
{\bkmkend AAAAAAAAIL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 76 of file iso9660.h.}\par
}
{\xe \v length\:iso9660.h}
{\xe \v iso9660.h\:length}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t length}}
\par
{\bkmkstart AAAAAAAAIM}
{\bkmkend AAAAAAAAIM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 77 of file iso9660.h.}\par
}
{\xe \v logical_blksize\:iso9660.h}
{\xe \v iso9660.h\:logical_blksize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} logical_blksize}}
\par
{\bkmkstart AAAAAAAAIN}
{\bkmkend AAAAAAAAIN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 89 of file iso9660.h.}\par
}
{\xe \v mdate\:iso9660.h}
{\xe \v iso9660.h\:mdate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char mdate[17]}}
\par
{\bkmkstart AAAAAAAAIO}
{\bkmkend AAAAAAAAIO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 105 of file iso9660.h.}\par
}
{\xe \v null0\:iso9660.h}
{\xe \v iso9660.h\:null0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char null0[8]}}
\par
{\bkmkstart AAAAAAAAIP}
{\bkmkend AAAAAAAAIP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 81 of file iso9660.h.}\par
}
{\xe \v null1\:iso9660.h}
{\xe \v iso9660.h\:null1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char null1[32]}}
\par
{\bkmkstart AAAAAAAAIQ}
{\bkmkend AAAAAAAAIQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 85 of file iso9660.h.}\par
}
{\xe \v null2\:iso9660.h}
{\xe \v iso9660.h\:null2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char null2[512]}}
\par
{\bkmkstart AAAAAAAAIR}
{\bkmkend AAAAAAAAIR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 110 of file iso9660.h.}\par
}
{\xe \v optpath_lba\:iso9660.h}
{\xe \v iso9660.h\:optpath_lba}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} optpath_lba}}
\par
{\bkmkstart AAAAAAAAIS}
{\bkmkend AAAAAAAAIS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 92 of file iso9660.h.}\par
}
{\xe \v optpath_lba_msb\:iso9660.h}
{\xe \v iso9660.h\:optpath_lba_msb}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} optpath_lba_msb}}
\par
{\bkmkstart AAAAAAAAIT}
{\bkmkend AAAAAAAAIT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 94 of file iso9660.h.}\par
}
{\xe \v path_lba\:iso9660.h}
{\xe \v iso9660.h\:path_lba}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} path_lba}}
\par
{\bkmkstart AAAAAAAAIU}
{\bkmkend AAAAAAAAIU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 91 of file iso9660.h.}\par
}
{\xe \v path_lba_msb\:iso9660.h}
{\xe \v iso9660.h\:path_lba_msb}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} path_lba_msb}}
\par
{\bkmkstart AAAAAAAAIV}
{\bkmkend AAAAAAAAIV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 93 of file iso9660.h.}\par
}
{\xe \v path_size\:iso9660.h}
{\xe \v iso9660.h\:path_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t path_size}}
\par
{\bkmkstart AAAAAAAAIW}
{\bkmkend AAAAAAAAIW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 90 of file iso9660.h.}\par
}
{\xe \v pubid\:iso9660.h}
{\xe \v iso9660.h\:pubid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char pubid[128]}}
\par
{\bkmkstart AAAAAAAAIX}
{\bkmkend AAAAAAAAIX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 98 of file iso9660.h.}\par
}
{\xe \v reserved\:iso9660.h}
{\xe \v iso9660.h\:reserved}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char reserved}}
\par
{\bkmkstart AAAAAAAAIY}
{\bkmkend AAAAAAAAIY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 111 of file iso9660.h.}\par
}
{\xe \v rootdir\:iso9660.h}
{\xe \v iso9660.h\:rootdir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char rootdir[34]}}
\par
{\bkmkstart AAAAAAAAIZ}
{\bkmkend AAAAAAAAIZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 96 of file iso9660.h.}\par
}
{\xe \v size\:iso9660.h}
{\xe \v iso9660.h\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} size}}
\par
{\bkmkstart AAAAAAAAJA}
{\bkmkend AAAAAAAAJA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 74 of file iso9660.h.}\par
}
{\xe \v sysid\:iso9660.h}
{\xe \v iso9660.h\:sysid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char sysid[32]}}
\par
{\bkmkstart AAAAAAAAJB}
{\bkmkend AAAAAAAAJB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 79 of file iso9660.h.}\par
}
{\xe \v type\:iso9660.h}
{\xe \v iso9660.h\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t type}}
\par
{\bkmkstart AAAAAAAAJC}
{\bkmkend AAAAAAAAJC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 74 of file iso9660.h.}\par
}
{\xe \v unitsize\:iso9660.h}
{\xe \v iso9660.h\:unitsize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} unitsize}}
\par
{\bkmkstart AAAAAAAAJD}
{\bkmkend AAAAAAAAJD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 80 of file iso9660.h.}\par
}
{\xe \v unused\:iso9660.h}
{\xe \v iso9660.h\:unused}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t unused}}
\par
{\bkmkstart AAAAAAAAJE}
{\bkmkend AAAAAAAAJE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 77 of file iso9660.h.}\par
}
{\xe \v unused0\:iso9660.h}
{\xe \v iso9660.h\:unused0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t unused0}}
\par
{\bkmkstart AAAAAAAAJF}
{\bkmkend AAAAAAAAJF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 109 of file iso9660.h.}\par
}
{\xe \v version\:iso9660.h}
{\xe \v iso9660.h\:version}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t version}}
\par
{\bkmkstart AAAAAAAAJG}
{\bkmkend AAAAAAAAJG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 76 of file iso9660.h.}\par
}
{\xe \v volid\:iso9660.h}
{\xe \v iso9660.h\:volid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char volid[32]}}
\par
{\bkmkstart AAAAAAAAJH}
{\bkmkend AAAAAAAAJH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 80 of file iso9660.h.}\par
}
{\xe \v volnumber\:iso9660.h}
{\xe \v iso9660.h\:volnumber}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} volnumber}}
\par
{\bkmkstart AAAAAAAAJI}
{\bkmkend AAAAAAAAJI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 88 of file iso9660.h.}\par
}
{\xe \v volsetid\:iso9660.h}
{\xe \v iso9660.h\:volsetid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char volsetid[128]}}
\par
{\bkmkstart AAAAAAAAJJ}
{\bkmkend AAAAAAAAJJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 97 of file iso9660.h.}\par
}
{\xe \v volsetsize\:iso9660.h}
{\xe \v iso9660.h\:volsetsize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} volsetsize}}
\par
{\bkmkstart AAAAAAAAJK}
{\bkmkend AAAAAAAAJK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 87 of file iso9660.h.}\par
}
{\xe \v volsize\:iso9660.h}
{\xe \v iso9660.h\:volsize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t volsize}}
\par
{\bkmkstart AAAAAAAAJL}
{\bkmkend AAAAAAAAJL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 83 of file iso9660.h.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/fs/iso9660/iso9660_finddir.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/fs/iso9660/iso9660_finddir.c}
{\xe \v src/fs/iso9660/iso9660_finddir.c}
{\bkmkstart AAAAAAAAJM}
{\bkmkend AAAAAAAAJM}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <aplus.h>}\par
{\f2 #include <aplus/fs.h>}\par
{\f2 #include <aplus/task.h>}\par
{\f2 #include <aplus/spinlock.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <dirent.h>}\par
{\f2 #include <fcntl.h>}\par
{\f2 #include <sys/types.h>}\par
{\f2 #include "iso9660.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b iso9660_read} ({\b inode_t} *, char *, int)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b dirent} * {\b iso9660_readdir} ({\b inode_t} *, int)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b inode_t} * {\b iso9660_finddir} ({\b inode_t} *ino, char *{\b name})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v iso9660_finddir\:iso9660_finddir.c}
{\xe \v iso9660_finddir.c\:iso9660_finddir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b inode_t}* iso9660_finddir ({\b inode_t} * {\i ino}, char * {\i name})}}
\par
{\bkmkstart AAAAAAAAJN}
{\bkmkend AAAAAAAAJN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 20 of file iso9660_finddir.c.}\par
{
References inode::atime, inode::chown, inode::creat, inode::ctime, inode::dev, devfs_getdevice(), inode::finddir, inode::flush, fs_read(), inode::gid, inode::ino, inode::ioctl, iso9660_checkname(), iso9660_finddir(), ISO9660_FLAGS_DIRECTORY, iso9660_getlsb32(), iso9660_read(), iso9660_readdir(), ISO9660_SECTOR_SIZE, kfree(), kmalloc(), inode::link, inode::mode, inode::mtime, inode::name, inode::nlink, inode::parent, inode::position, inode::rdev, inode::read, inode::readdir, inode::rename, inode::size, sys_time(), inode::uid, uint32_t, inode::unlink, inode::userdata, and inode::write.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20                                                    \{\par
21     if(!ino)\par
22         return NULL;\par
23         \par
24     if(!ino->dev)\par
25         return NULL;\par
26 \par
27     if(!ino->userdata)\par
28         return NULL;\par
29 \par
30     if(!name || strlen(name) == 0)\par
31         return NULL;\par
32 \par
33 \par
34     inode_t* dev = (inode_t*) devfs_getdevice(ino->dev);\par
35     if(!dev)\par
36         return NULL;\par
37 \par
38     iso9660_dir_t* dir = (iso9660_dir_t*) ino->userdata;\par
39     iso9660_dir_t* nodes = (iso9660_dir_t*) kmalloc(iso9660_getlsb32(dir->length));\par
40     iso9660_dir_t* snodes = nodes;\par
41 \par
42     dev->position = iso9660_getlsb32(dir->lba) * ISO9660_SECTOR_SIZE;\par
43     if(fs_read(dev, nodes, iso9660_getlsb32(dir->length)) != iso9660_getlsb32(dir->length)) \{\par
44         kfree(nodes);\par
45         return NULL;\par
46     \}\par
47 \par
48     for(;;) \{\par
49         if(nodes->size == 0) \{\par
50             kfree(snodes);\par
51             return 0;\par
52         \}\par
53 \par
54         char* nodename = (char*) kmalloc(nodes->idlen);\par
55         memset(nodename, 0, nodes->idlen);\par
56 \par
57         strncpy(nodename, nodes->reserved, nodes->idlen);\par
58         iso9660_checkname(nodename);\par
59 \par
60         if(strcmp(nodename, name) == 0)\par
61             break;\par
62 \par
63         kfree(nodename);\par
64         nodes = (iso9660_dir_t*) ((uint32_t) nodes + nodes->size);\par
65     \}\par
66 \par
67 \par
68     inode_t* f = (inode_t*) kmalloc(sizeof(inode_t));\par
69     memset(f, 0, sizeof(inode_t));\par
70 \par
71     strcpy(f->name, name);\par
72     \par
73     f->dev = ino->dev;\par
74     f->ino = 0;\par
75     f->nlink = 0;\par
76     f->uid = ino->uid;\par
77     f->gid = ino->gid;\par
78     f->rdev = ino->rdev;\par
79     f->size = (size_t) iso9660_getlsb32(nodes->length);\par
80     f->atime = f->ctime = f->mtime = sys_time(NULL);\par
81     f->parent = ino;\par
82     f->link = NULL;\par
83     \par
84     if(nodes->flags & ISO9660_FLAGS_DIRECTORY) \{\par
85         f->readdir = iso9660_readdir;\par
86         f->finddir = iso9660_finddir;\par
87         f->mode = S_IFDIR;\par
88 \par
89         iso9660_dir_t* entry = (iso9660_dir_t*) kmalloc(ISO9660_SECTOR_SIZE);\par
90         memset(entry, 0, ISO9660_SECTOR_SIZE);\par
91 \par
92         dev->position = iso9660_getlsb32(nodes->lba) * ISO9660_SECTOR_SIZE;\par
93         fs_read(dev, entry, ISO9660_SECTOR_SIZE);\par
94 \par
95         f->userdata = (void*) entry;\par
96     \} else \{\par
97         f->read = iso9660_read;\par
98         f->write = NULL;    /* Read Only */\par
99 \par
100         f->mode = S_IFREG;\par
101         f->userdata = (void*) (iso9660_getlsb32(nodes->lba) * ISO9660_SECTOR_SIZE);\par
102     \}\par
103 \par
104 \par
105 \par
106     f->creat = NULL;\par
107     f->rename = NULL;\par
108     f->unlink = NULL;\par
109     f->chown = NULL;\par
110     f->flush = NULL;\par
111     f->ioctl = NULL;\par
112 \par
113     \par
114     kfree(snodes);\par
115     return f;\par
116 \}\par
}
}
{\xe \v iso9660_read\:iso9660_finddir.c}
{\xe \v iso9660_finddir.c\:iso9660_read}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int iso9660_read ({\b inode_t} * , char * , int )}}
\par
{\bkmkstart AAAAAAAAJO}
{\bkmkend AAAAAAAAJO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 16 of file iso9660_read.c.}\par
{
References inode::dev, devfs_getdevice(), fs_read(), ISO9660_SECTOR_SIZE, kfree(), kmalloc(), inode::position, inode::size, size, uint32_t, and inode::userdata.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 16                                                     \{\par
17     if(!ino)\par
18         return 0;\par
19         \par
20     if(!buf)\par
21         return 0;\par
22         \par
23     if(size > ino->size)\par
24         size = ino->size;\par
25         \par
26     if(ino->position > ino->size)\par
27         ino->position = ino->size;\par
28         \par
29     if(ino->position + size > ino->size)\par
30         size = ino->size - ino->position;\par
31         \par
32     if(!size)\par
33         return 0;\par
34 \par
35     inode_t* dev = (inode_t*) devfs_getdevice(ino->dev);\par
36     if(!dev)\par
37         return 0;\par
38 \par
39     void* tbuf = (void*) kmalloc(((size / ISO9660_SECTOR_SIZE) + 1) * ISO9660_SECTOR_SIZE);\par
40     \par
41     dev->position = (off_t) ino->userdata + (ino->position / ISO9660_SECTOR_SIZE);\par
42     fs_read(dev, tbuf, ((size / ISO9660_SECTOR_SIZE) + 1) * ISO9660_SECTOR_SIZE);\par
43 \par
44     memcpy(buf, (void*) ((uint32_t) tbuf + (ino->position % ISO9660_SECTOR_SIZE)), size);\par
45     kfree(tbuf);\par
46 \par
47     return size;\par
48 \}\par
}
}
{\xe \v iso9660_readdir\:iso9660_finddir.c}
{\xe \v iso9660_finddir.c\:iso9660_readdir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b dirent}* iso9660_readdir ({\b inode_t} * , int )}}
\par
{\bkmkstart AAAAAAAAJP}
{\bkmkend AAAAAAAAJP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 15 of file iso9660_readdir.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15                                                         \{\par
16     if(!ino)\par
17         return NULL;\par
18         \par
19     if(!ino->dev)\par
20         return NULL;\par
21 \par
22     if(!ino->userdata)\par
23         return NULL;\par
24 \par
25     inode_t* dev = (inode_t*) devfs_getdevice(ino->dev);\par
26     if(!dev)\par
27         return NULL;\par
28 \par
29     iso9660_dir_t* dir = (iso9660_dir_t*) ino->userdata;\par
30     iso9660_dir_t* nodes = (iso9660_dir_t*) kmalloc(iso9660_getlsb32(dir->length));\par
31     iso9660_dir_t* snodes = nodes;\par
32 \par
33     dev->position = iso9660_getlsb32(dir->lba) * ISO9660_SECTOR_SIZE;\par
34     if(fs_read(dev, nodes, iso9660_getlsb32(dir->length)) != iso9660_getlsb32(dir->length)) \{\par
35         kfree(nodes);\par
36         return NULL;\par
37     \}\par
38 \par
39     /* Skip dots (".", "..") */\par
40     nodes = (iso9660_dir_t*) ((uint32_t) nodes + nodes->size);\par
41     nodes = (iso9660_dir_t*) ((uint32_t) nodes + nodes->size);\par
42 \par
43     for(int i = 0; i < index; i++) \{        \par
44         if(nodes->size == 0) \{      \par
45             kfree(snodes);\par
46             return NULL;\par
47         \}\par
48         \par
49         nodes = (iso9660_dir_t*) ((uint32_t) nodes + nodes->size);\par
50     \}\par
51 \par
52 \par
53     if(nodes->size == 0) \{\par
54         kfree(snodes);\par
55         return NULL;\par
56     \}\par
57 \par
58     struct dirent* ent = (struct dirent*) kmalloc(sizeof(struct dirent));\par
59     memset(ent, 0, sizeof(struct dirent));\par
60     \par
61     strncpy(ent->d_name, nodes->reserved, nodes->idlen);    \par
62     iso9660_checkname(ent->d_name);\par
63 \par
64     ent->d_ino = 0;\par
65 \par
66     kfree(snodes);\par
67     return ent;\par
68 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/fs/iso9660/iso9660_mount.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/fs/iso9660/iso9660_mount.c}
{\xe \v src/fs/iso9660/iso9660_mount.c}
{\bkmkstart AAAAAAAAJQ}
{\bkmkend AAAAAAAAJQ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <aplus.h>}\par
{\f2 #include <aplus/fs.h>}\par
{\f2 #include <aplus/task.h>}\par
{\f2 #include <aplus/spinlock.h>}\par
{\f2 #include <aplus/fsys.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <dirent.h>}\par
{\f2 #include <fcntl.h>}\par
{\f2 #include <sys/types.h>}\par
{\f2 #include "iso9660.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b dirent} * {\b iso9660_readdir} ({\b inode_t} *, int)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b inode_t} * {\b iso9660_finddir} ({\b inode_t} *, char *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b iso9660_mount} ({\b inode_t} *dev, {\b inode_t} *ino, int {\b flags})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FSYS} (iso9660, {\b iso9660_mount})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v FSYS\:iso9660_mount.c}
{\xe \v iso9660_mount.c\:FSYS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
FSYS (iso9660 , {\b iso9660_mount} )}}
\par
{\bkmkstart AAAAAAAAJR}
{\bkmkend AAAAAAAAJR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v iso9660_finddir\:iso9660_mount.c}
{\xe \v iso9660_mount.c\:iso9660_finddir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b inode_t}* iso9660_finddir ({\b inode_t} * , char * )}}
\par
{\bkmkstart AAAAAAAAJS}
{\bkmkend AAAAAAAAJS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 20 of file iso9660_finddir.c.}\par
{
References inode::atime, inode::chown, inode::creat, inode::ctime, inode::dev, devfs_getdevice(), inode::finddir, inode::flush, fs_read(), inode::gid, inode::ino, inode::ioctl, iso9660_checkname(), iso9660_finddir(), ISO9660_FLAGS_DIRECTORY, iso9660_getlsb32(), iso9660_read(), iso9660_readdir(), ISO9660_SECTOR_SIZE, kfree(), kmalloc(), inode::link, inode::mode, inode::mtime, inode::name, inode::nlink, inode::parent, inode::position, inode::rdev, inode::read, inode::readdir, inode::rename, inode::size, sys_time(), inode::uid, uint32_t, inode::unlink, inode::userdata, and inode::write.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20                                                    \{\par
21     if(!ino)\par
22         return NULL;\par
23         \par
24     if(!ino->dev)\par
25         return NULL;\par
26 \par
27     if(!ino->userdata)\par
28         return NULL;\par
29 \par
30     if(!name || strlen(name) == 0)\par
31         return NULL;\par
32 \par
33 \par
34     inode_t* dev = (inode_t*) devfs_getdevice(ino->dev);\par
35     if(!dev)\par
36         return NULL;\par
37 \par
38     iso9660_dir_t* dir = (iso9660_dir_t*) ino->userdata;\par
39     iso9660_dir_t* nodes = (iso9660_dir_t*) kmalloc(iso9660_getlsb32(dir->length));\par
40     iso9660_dir_t* snodes = nodes;\par
41 \par
42     dev->position = iso9660_getlsb32(dir->lba) * ISO9660_SECTOR_SIZE;\par
43     if(fs_read(dev, nodes, iso9660_getlsb32(dir->length)) != iso9660_getlsb32(dir->length)) \{\par
44         kfree(nodes);\par
45         return NULL;\par
46     \}\par
47 \par
48     for(;;) \{\par
49         if(nodes->size == 0) \{\par
50             kfree(snodes);\par
51             return 0;\par
52         \}\par
53 \par
54         char* nodename = (char*) kmalloc(nodes->idlen);\par
55         memset(nodename, 0, nodes->idlen);\par
56 \par
57         strncpy(nodename, nodes->reserved, nodes->idlen);\par
58         iso9660_checkname(nodename);\par
59 \par
60         if(strcmp(nodename, name) == 0)\par
61             break;\par
62 \par
63         kfree(nodename);\par
64         nodes = (iso9660_dir_t*) ((uint32_t) nodes + nodes->size);\par
65     \}\par
66 \par
67 \par
68     inode_t* f = (inode_t*) kmalloc(sizeof(inode_t));\par
69     memset(f, 0, sizeof(inode_t));\par
70 \par
71     strcpy(f->name, name);\par
72     \par
73     f->dev = ino->dev;\par
74     f->ino = 0;\par
75     f->nlink = 0;\par
76     f->uid = ino->uid;\par
77     f->gid = ino->gid;\par
78     f->rdev = ino->rdev;\par
79     f->size = (size_t) iso9660_getlsb32(nodes->length);\par
80     f->atime = f->ctime = f->mtime = sys_time(NULL);\par
81     f->parent = ino;\par
82     f->link = NULL;\par
83     \par
84     if(nodes->flags & ISO9660_FLAGS_DIRECTORY) \{\par
85         f->readdir = iso9660_readdir;\par
86         f->finddir = iso9660_finddir;\par
87         f->mode = S_IFDIR;\par
88 \par
89         iso9660_dir_t* entry = (iso9660_dir_t*) kmalloc(ISO9660_SECTOR_SIZE);\par
90         memset(entry, 0, ISO9660_SECTOR_SIZE);\par
91 \par
92         dev->position = iso9660_getlsb32(nodes->lba) * ISO9660_SECTOR_SIZE;\par
93         fs_read(dev, entry, ISO9660_SECTOR_SIZE);\par
94 \par
95         f->userdata = (void*) entry;\par
96     \} else \{\par
97         f->read = iso9660_read;\par
98         f->write = NULL;    /* Read Only */\par
99 \par
100         f->mode = S_IFREG;\par
101         f->userdata = (void*) (iso9660_getlsb32(nodes->lba) * ISO9660_SECTOR_SIZE);\par
102     \}\par
103 \par
104 \par
105 \par
106     f->creat = NULL;\par
107     f->rename = NULL;\par
108     f->unlink = NULL;\par
109     f->chown = NULL;\par
110     f->flush = NULL;\par
111     f->ioctl = NULL;\par
112 \par
113     \par
114     kfree(snodes);\par
115     return f;\par
116 \}\par
}
}
{\xe \v iso9660_mount\:iso9660_mount.c}
{\xe \v iso9660_mount.c\:iso9660_mount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int iso9660_mount ({\b inode_t} * {\i dev}, {\b inode_t} * {\i ino}, int {\i flags})}}
\par
{\bkmkstart AAAAAAAAJT}
{\bkmkend AAAAAAAAJT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 20 of file iso9660_mount.c.}\par
{
References inode::finddir, iso9660_check(), iso9660_finddir(), iso9660_getroot(), iso9660_readdir(), kprintf(), inode::name, inode::readdir, and inode::userdata.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20                                                          \{\par
21     if(!dev)\par
22         return -1;\par
23         \par
24     if(!ino)\par
25         return -1;\par
26     \par
27     if(iso9660_check(dev) != 0) \{\par
28         kprintf("iso9660: (%s) check failed\\n", dev->name);\par
29         return -1;\par
30     \}\par
31 \par
32     ino->userdata = (void*) iso9660_getroot();\par
33     ino->readdir = iso9660_readdir;\par
34     ino->finddir = iso9660_finddir;\par
35     \par
36     return 0;\par
37 \}\par
}
}
{\xe \v iso9660_readdir\:iso9660_mount.c}
{\xe \v iso9660_mount.c\:iso9660_readdir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b dirent}* iso9660_readdir ({\b inode_t} * , int )}}
\par
{\bkmkstart AAAAAAAAJU}
{\bkmkend AAAAAAAAJU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 15 of file iso9660_readdir.c.}\par
{
References dirent::d_ino, dirent::d_name, inode::dev, devfs_getdevice(), fs_read(), iso9660_checkname(), iso9660_getlsb32(), ISO9660_SECTOR_SIZE, kfree(), kmalloc(), inode::position, uint32_t, and inode::userdata.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15                                                         \{\par
16     if(!ino)\par
17         return NULL;\par
18         \par
19     if(!ino->dev)\par
20         return NULL;\par
21 \par
22     if(!ino->userdata)\par
23         return NULL;\par
24 \par
25     inode_t* dev = (inode_t*) devfs_getdevice(ino->dev);\par
26     if(!dev)\par
27         return NULL;\par
28 \par
29     iso9660_dir_t* dir = (iso9660_dir_t*) ino->userdata;\par
30     iso9660_dir_t* nodes = (iso9660_dir_t*) kmalloc(iso9660_getlsb32(dir->length));\par
31     iso9660_dir_t* snodes = nodes;\par
32 \par
33     dev->position = iso9660_getlsb32(dir->lba) * ISO9660_SECTOR_SIZE;\par
34     if(fs_read(dev, nodes, iso9660_getlsb32(dir->length)) != iso9660_getlsb32(dir->length)) \{\par
35         kfree(nodes);\par
36         return NULL;\par
37     \}\par
38 \par
39     /* Skip dots (".", "..") */\par
40     nodes = (iso9660_dir_t*) ((uint32_t) nodes + nodes->size);\par
41     nodes = (iso9660_dir_t*) ((uint32_t) nodes + nodes->size);\par
42 \par
43     for(int i = 0; i < index; i++) \{        \par
44         if(nodes->size == 0) \{      \par
45             kfree(snodes);\par
46             return NULL;\par
47         \}\par
48         \par
49         nodes = (iso9660_dir_t*) ((uint32_t) nodes + nodes->size);\par
50     \}\par
51 \par
52 \par
53     if(nodes->size == 0) \{\par
54         kfree(snodes);\par
55         return NULL;\par
56     \}\par
57 \par
58     struct dirent* ent = (struct dirent*) kmalloc(sizeof(struct dirent));\par
59     memset(ent, 0, sizeof(struct dirent));\par
60     \par
61     strncpy(ent->d_name, nodes->reserved, nodes->idlen);    \par
62     iso9660_checkname(ent->d_name);\par
63 \par
64     ent->d_ino = 0;\par
65 \par
66     kfree(snodes);\par
67     return ent;\par
68 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/fs/iso9660/iso9660_read.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/fs/iso9660/iso9660_read.c}
{\xe \v src/fs/iso9660/iso9660_read.c}
{\bkmkstart AAAAAAAAJV}
{\bkmkend AAAAAAAAJV}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <aplus.h>}\par
{\f2 #include <aplus/fs.h>}\par
{\f2 #include <aplus/task.h>}\par
{\f2 #include <aplus/spinlock.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <dirent.h>}\par
{\f2 #include <fcntl.h>}\par
{\f2 #include <sys/types.h>}\par
{\f2 #include "iso9660.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b iso9660_read} ({\b inode_t} *ino, char *buf, int {\b size})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v iso9660_read\:iso9660_read.c}
{\xe \v iso9660_read.c\:iso9660_read}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int iso9660_read ({\b inode_t} * {\i ino}, char * {\i buf}, int {\i size})}}
\par
{\bkmkstart AAAAAAAAJW}
{\bkmkend AAAAAAAAJW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 16 of file iso9660_read.c.}\par
{
References inode::dev, devfs_getdevice(), fs_read(), ISO9660_SECTOR_SIZE, kfree(), kmalloc(), inode::position, inode::size, size, uint32_t, and inode::userdata.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 16                                                     \{\par
17     if(!ino)\par
18         return 0;\par
19         \par
20     if(!buf)\par
21         return 0;\par
22         \par
23     if(size > ino->size)\par
24         size = ino->size;\par
25         \par
26     if(ino->position > ino->size)\par
27         ino->position = ino->size;\par
28         \par
29     if(ino->position + size > ino->size)\par
30         size = ino->size - ino->position;\par
31         \par
32     if(!size)\par
33         return 0;\par
34 \par
35     inode_t* dev = (inode_t*) devfs_getdevice(ino->dev);\par
36     if(!dev)\par
37         return 0;\par
38 \par
39     void* tbuf = (void*) kmalloc(((size / ISO9660_SECTOR_SIZE) + 1) * ISO9660_SECTOR_SIZE);\par
40     \par
41     dev->position = (off_t) ino->userdata + (ino->position / ISO9660_SECTOR_SIZE);\par
42     fs_read(dev, tbuf, ((size / ISO9660_SECTOR_SIZE) + 1) * ISO9660_SECTOR_SIZE);\par
43 \par
44     memcpy(buf, (void*) ((uint32_t) tbuf + (ino->position % ISO9660_SECTOR_SIZE)), size);\par
45     kfree(tbuf);\par
46 \par
47     return size;\par
48 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/fs/iso9660/iso9660_readdir.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/fs/iso9660/iso9660_readdir.c}
{\xe \v src/fs/iso9660/iso9660_readdir.c}
{\bkmkstart AAAAAAAAJX}
{\bkmkend AAAAAAAAJX}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <aplus.h>}\par
{\f2 #include <aplus/fs.h>}\par
{\f2 #include <aplus/task.h>}\par
{\f2 #include <aplus/spinlock.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <dirent.h>}\par
{\f2 #include <fcntl.h>}\par
{\f2 #include <sys/types.h>}\par
{\f2 #include "iso9660.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b dirent} * {\b iso9660_readdir} ({\b inode_t} *ino, int index)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v iso9660_readdir\:iso9660_readdir.c}
{\xe \v iso9660_readdir.c\:iso9660_readdir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b dirent}* iso9660_readdir ({\b inode_t} * {\i ino}, int {\i index})}}
\par
{\bkmkstart AAAAAAAAJY}
{\bkmkend AAAAAAAAJY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 15 of file iso9660_readdir.c.}\par
{
References dirent::d_ino, dirent::d_name, inode::dev, devfs_getdevice(), fs_read(), iso9660_checkname(), iso9660_getlsb32(), ISO9660_SECTOR_SIZE, kfree(), kmalloc(), inode::position, uint32_t, and inode::userdata.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15                                                         \{\par
16     if(!ino)\par
17         return NULL;\par
18         \par
19     if(!ino->dev)\par
20         return NULL;\par
21 \par
22     if(!ino->userdata)\par
23         return NULL;\par
24 \par
25     inode_t* dev = (inode_t*) devfs_getdevice(ino->dev);\par
26     if(!dev)\par
27         return NULL;\par
28 \par
29     iso9660_dir_t* dir = (iso9660_dir_t*) ino->userdata;\par
30     iso9660_dir_t* nodes = (iso9660_dir_t*) kmalloc(iso9660_getlsb32(dir->length));\par
31     iso9660_dir_t* snodes = nodes;\par
32 \par
33     dev->position = iso9660_getlsb32(dir->lba) * ISO9660_SECTOR_SIZE;\par
34     if(fs_read(dev, nodes, iso9660_getlsb32(dir->length)) != iso9660_getlsb32(dir->length)) \{\par
35         kfree(nodes);\par
36         return NULL;\par
37     \}\par
38 \par
39     /* Skip dots (".", "..") */\par
40     nodes = (iso9660_dir_t*) ((uint32_t) nodes + nodes->size);\par
41     nodes = (iso9660_dir_t*) ((uint32_t) nodes + nodes->size);\par
42 \par
43     for(int i = 0; i < index; i++) \{        \par
44         if(nodes->size == 0) \{      \par
45             kfree(snodes);\par
46             return NULL;\par
47         \}\par
48         \par
49         nodes = (iso9660_dir_t*) ((uint32_t) nodes + nodes->size);\par
50     \}\par
51 \par
52 \par
53     if(nodes->size == 0) \{\par
54         kfree(snodes);\par
55         return NULL;\par
56     \}\par
57 \par
58     struct dirent* ent = (struct dirent*) kmalloc(sizeof(struct dirent));\par
59     memset(ent, 0, sizeof(struct dirent));\par
60     \par
61     strncpy(ent->d_name, nodes->reserved, nodes->idlen);    \par
62     iso9660_checkname(ent->d_name);\par
63 \par
64     ent->d_ino = 0;\par
65 \par
66     kfree(snodes);\par
67     return ent;\par
68 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/fs/pipe.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/fs/pipe.c}
{\xe \v src/fs/pipe.c}
{\bkmkstart AAAAAAAAJZ}
{\bkmkend AAAAAAAAJZ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <aplus.h>}\par
{\f2 #include <aplus/fs.h>}\par
{\f2 #include <aplus/bufio.h>}\par
{\f2 #include <aplus/mm.h>}\par
{\f2 #include <aplus/spinlock.h>}\par
{\f2 #include <aplus/task.h>}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <stddef.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <fcntl.h>}\par
{\f2 #include <sys/stat.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b pipeinfo}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b pipeinfo} {\b pipeinfo_t}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pipe_read} ({\b inode_t} *{\b inode}, char *ptr, int len)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pipe_write} ({\b inode_t} *{\b inode}, char *ptr, int len)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b pipe_flush} ({\b inode_t} *{\b inode})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pipe_create} ({\b inode_t} inodes[2])\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b task_t} * {\b current_task}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current task address. }{
}\par
}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v pipeinfo_t\:pipe.c}
{\xe \v pipe.c\:pipeinfo_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b pipeinfo}  {\b pipeinfo_t}}}
\par
{\bkmkstart AAAAAAAAKA}
{\bkmkend AAAAAAAAKA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v pipe_create\:pipe.c}
{\xe \v pipe.c\:pipe_create}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pipe_create ({\b inode_t} {\i inodes}[2])}}
\par
{\bkmkstart AAAAAAAAKB}
{\bkmkend AAAAAAAAKB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 63 of file pipe.c.}\par
{
References inode::atime, bufio_alloc(), inode::ctime, inode::flush, inode::gid, task::gid, kmalloc(), inode::mode, inode::mtime, name, pipe_flush(), pipe_read(), pipe_write(), inode::read, pipeinfo::read_offset, inode::size, pipeinfo::stream, sys_time(), inode::uid, task::uid, inode::userdata, inode::write, and pipeinfo::write_offset.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 63                                    \{\par
64 \par
65     pipeinfo_t* pipe = (pipeinfo_t*) kmalloc(sizeof(pipeinfo_t));\par
66     pipe->stream = (bufio_t*) bufio_alloc(BUFSIZ);\par
67     pipe->read_offset = 0;\par
68     pipe->write_offset = 0;\par
69 \par
70 \par
71     for(int i = 0; i < 2; i++) \{\par
72         memset((void*) &inodes[i], 0, sizeof(inode_t));\par
73         \par
74         inodes[i].atime = inodes[i].mtime = inodes[i].ctime = sys_time(NULL);\par
75         inodes[i].read = pipe_read;\par
76         inodes[i].write = pipe_write;\par
77         inodes[i].flush = pipe_flush;\par
78         inodes[i].uid = current_task->uid;\par
79         inodes[i].gid = current_task->gid;\par
80         inodes[i].mode = S_IFIFO;\par
81         inodes[i].userdata = (void*) pipe;\par
82         inodes[i].size = (size_t) BUFSIZ;\par
83     \}\par
84     \par
85     \par
86     strcpy(inodes[0].name, "[pipe:read]");\par
87     strcpy(inodes[1].name, "[pipe:write]");\par
88     \par
89     return 0;\par
90 \}\par
}
}
{\xe \v pipe_flush\:pipe.c}
{\xe \v pipe.c\:pipe_flush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void pipe_flush ({\b inode_t} * {\i inode})}}
\par
{\bkmkstart AAAAAAAAKC}
{\bkmkend AAAAAAAAKC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 54 of file pipe.c.}\par
{
References bufio_free(), kfree(), pipeinfo::stream, and inode::userdata.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 54                                 \{\par
55     pipeinfo_t* pipe = inode->userdata;\par
56     \par
57     bufio_free(pipe->stream);\par
58     kfree(pipe);\par
59 \}\par
}
}
{\xe \v pipe_read\:pipe.c}
{\xe \v pipe.c\:pipe_read}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pipe_read ({\b inode_t} * {\i inode}, char * {\i ptr}, int {\i len})}}
\par
{\bkmkstart AAAAAAAAKD}
{\bkmkend AAAAAAAAKD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 27 of file pipe.c.}\par
{
References bufio_read(), bufio_seek(), bufio_tell(), pipeinfo::read_offset, bufio::size, spinlock_waiton, pipeinfo::stream, inode::userdata, and pipeinfo::write_offset.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 27                                                   \{\par
28     pipeinfo_t* pipe = inode->userdata;\par
29     \par
30     spinlock_waiton(pipe->read_offset + len > pipe->write_offset);\par
31     \par
32     bufio_seek(pipe->stream, pipe->read_offset % pipe->stream->size, SEEK_SET);\par
33     \par
34     size_t tolen = 0;\par
35     while((tolen = bufio_read(pipe->stream, (void*) ((off_t) ptr + (off_t) tolen), len)) < len)\par
36         bufio_seek(pipe->stream, 0, SEEK_SET);\par
37         \par
38     pipe->write_offset = bufio_tell(pipe->stream);\par
39     return (int) len;\par
40 \}\par
}
}
{\xe \v pipe_write\:pipe.c}
{\xe \v pipe.c\:pipe_write}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pipe_write ({\b inode_t} * {\i inode}, char * {\i ptr}, int {\i len})}}
\par
{\bkmkstart AAAAAAAAKE}
{\bkmkend AAAAAAAAKE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 42 of file pipe.c.}\par
{
References bufio_seek(), bufio_tell(), bufio_write(), bufio::size, pipeinfo::stream, inode::userdata, and pipeinfo::write_offset.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 42                                                    \{\par
43     pipeinfo_t* pipe = inode->userdata;\par
44     bufio_seek(pipe->stream, pipe->write_offset % pipe->stream->size, SEEK_SET);\par
45     \par
46     size_t tolen = 0;\par
47     while((tolen = bufio_write(pipe->stream, (void*) ((off_t) ptr + (off_t) tolen), len)) < len)\par
48         bufio_seek(pipe->stream, 0, SEEK_SET);\par
49         \par
50     pipe->write_offset = bufio_tell(pipe->stream);\par
51     return (int) len;\par
52 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v current_task\:pipe.c}
{\xe \v pipe.c\:current_task}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b task_t}* current_task}}
\par
{\bkmkstart AAAAAAAAKF}
{\bkmkend AAAAAAAAKF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current task address. }}\par
{
Definition at line 35 of file sched.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/fs/ramdev.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/fs/ramdev.c}
{\xe \v src/fs/ramdev.c}
{\bkmkstart AAAAAAAAKG}
{\bkmkend AAAAAAAAKG}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <aplus.h>}\par
{\f2 #include <aplus/fs.h>}\par
{\f2 #include <aplus/task.h>}\par
{\f2 #include <aplus/bufio.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <dirent.h>}\par
{\f2 #include <fcntl.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ramdev_read} ({\b inode_t} *ino, char *buf, int {\b size})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ramdev_write} ({\b inode_t} *ino, char *buf, int {\b size})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ramdev_flush} ({\b inode_t} *ino)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b inode_t} * {\b mkramdev} (char *path, {\b uint32_t} addr, {\b uint32_t} {\b size})\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b task_t} * {\b current_task}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current task address. }{
}\par
}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v mkramdev\:ramdev.c}
{\xe \v ramdev.c\:mkramdev}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b inode_t}* mkramdev (char * {\i path}, {\b uint32_t} {\i addr}, {\b uint32_t} {\i size})}}
\par
{\bkmkstart AAAAAAAAKH}
{\bkmkend AAAAAAAAKH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 76 of file ramdev.c.}\par
{
References bufio_alloc_raw(), task::fd, inode::flush, ramdev_flush(), ramdev_read(), ramdev_write(), inode::read, inode::size, size, sys_close(), sys_open(), inode::userdata, and inode::write.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 76                                                             \{\par
77     int fd = sys_open(path, O_CREAT | O_EXCL | O_TRUNC, S_IFCHR);\par
78     if(fd < 0)\par
79         return NULL;\par
80 \par
81     inode_t* ino = (inode_t*) current_task->fd[fd];\par
82     sys_close(fd);\par
83 \par
84     ino->read = ramdev_read;\par
85     ino->write = ramdev_write;\par
86     ino->flush = ramdev_flush;\par
87     ino->userdata = (void*) bufio_alloc_raw((void*) addr, size);\par
88     ino->size = size;\par
89 \par
90 \par
91     return ino;\par
92 \}\par
}
}
{\xe \v ramdev_flush\:ramdev.c}
{\xe \v ramdev.c\:ramdev_flush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ramdev_flush ({\b inode_t} * {\i ino})}}
\par
{\bkmkstart AAAAAAAAKI}
{\bkmkend AAAAAAAAKI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 65 of file ramdev.c.}\par
{
References bufio_free(), and inode::userdata.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 65                                 \{\par
66     if(!ino)\par
67         return;\par
68 \par
69     if(!ino->userdata)\par
70         return;\par
71 \par
72     bufio_free(ino->userdata);\par
73 \}\par
}
}
{\xe \v ramdev_read\:ramdev.c}
{\xe \v ramdev.c\:ramdev_read}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ramdev_read ({\b inode_t} * {\i ino}, char * {\i buf}, int {\i size})}}
\par
{\bkmkstart AAAAAAAAKJ}
{\bkmkend AAAAAAAAKJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 15 of file ramdev.c.}\par
{
References bufio_read(), bufio_seek(), inode::position, inode::size, size, and inode::userdata.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15                                                    \{\par
16     if(!ino)\par
17         return 0;\par
18 \par
19     if(!buf)\par
20         return 0;\par
21 \par
22     if(size > ino->size)\par
23         size = ino->size;\par
24 \par
25     if(ino->position > ino->size)\par
26         ino->position = ino->size;\par
27 \par
28     if(ino->position + size > ino->size)\par
29         size = ino->size - ino->position;\par
30 \par
31     if(!size)\par
32         return 0;\par
33 \par
34     bufio_seek(ino->userdata, ino->position, SEEK_SET);\par
35     size = bufio_read(ino->userdata, buf, size);\par
36     ino->position += size;\par
37     return size;\par
38 \}\par
}
}
{\xe \v ramdev_write\:ramdev.c}
{\xe \v ramdev.c\:ramdev_write}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ramdev_write ({\b inode_t} * {\i ino}, char * {\i buf}, int {\i size})}}
\par
{\bkmkstart AAAAAAAAKK}
{\bkmkend AAAAAAAAKK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 40 of file ramdev.c.}\par
{
References bufio_seek(), bufio_write(), inode::position, inode::size, size, and inode::userdata.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 40                                                     \{\par
41     if(!ino)\par
42         return 0;\par
43 \par
44     if(!buf)\par
45         return 0;\par
46 \par
47     if(size > ino->size)\par
48         size = ino->size;\par
49 \par
50     if(ino->position > ino->size)\par
51         ino->position = ino->size;\par
52 \par
53     if(ino->position + size > ino->size)\par
54         size = ino->size - ino->position;\par
55 \par
56     if(!size)\par
57         return 0;\par
58 \par
59     bufio_seek(ino->userdata, ino->position, SEEK_SET);\par
60     size = bufio_write(ino->userdata, buf, size);\par
61     ino->position += size;\par
62     return size;\par
63 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v current_task\:ramdev.c}
{\xe \v ramdev.c\:current_task}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b task_t}* current_task}}
\par
{\bkmkstart AAAAAAAAKL}
{\bkmkend AAAAAAAAKL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current task address. }}\par
{
Definition at line 35 of file sched.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/fs/vfs.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/fs/vfs.c}
{\xe \v src/fs/vfs.c}
{\bkmkstart AAAAAAAAKM}
{\bkmkend AAAAAAAAKM}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <aplus.h>}\par
{\f2 #include <aplus/fs.h>}\par
{\f2 #include <aplus/list.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <stddef.h>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <sys/stat.h>}\par
{\f2 #include <sys/types.h>}\par
{\f2 #include <fcntl.h>}\par
{\f2 #include <dirent.h>}\par
{\f2 #include <errno.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vfs_map} ({\b inode_t} *{\b inode})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vfs_umap} ({\b inode_t} *{\b inode})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b inode_t} * {\b vfs_mapped} ({\b inode_t} *parent, char *{\b name})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b inode_t} * {\b vfs_mapped_at_index} ({\b inode_t} *parent, int index)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vfs_mapped_count} ({\b inode_t} *parent)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vfs_chroot} ({\b inode_t} *root)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vfs_init} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b list_t} * {\b list_inodes} = 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b uint32_t} {\b nextinode} = 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b inode_t} * {\b vfs_root}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v vfs_chroot\:vfs.c}
{\xe \v vfs.c\:vfs_chroot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vfs_chroot ({\b inode_t} * {\i root})}}
\par
{\bkmkstart AAAAAAAAKN}
{\bkmkend AAAAAAAAKN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 72 of file vfs.c.}\par
{
References inode::parent.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 72                               \{\par
73     vfs_root = root;\par
74     vfs_root->parent = 0;\par
75     \par
76     return 0;\par
77 \}\par
}
}
{\xe \v vfs_init\:vfs.c}
{\xe \v vfs.c\:vfs_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vfs_init ()}}
\par
{\bkmkstart AAAAAAAAKO}
{\bkmkend AAAAAAAAKO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 81 of file vfs.c.}\par
{
References inode::atime, inode::chown, inode::creat, inode::ctime, inode::dev, inode::finddir, inode::flush, inode::gid, GID_ROOT, inode::ino, inode::ioctl, kmalloc(), inode::link, list_add(), list_init, inode::mode, inode::mtime, inode::name, nextinode, inode::nlink, inode::parent, inode::rdev, inode::read, inode::readdir, inode::rename, inode::size, sys_time(), inode::uid, UID_ROOT, inode::unlink, and inode::write.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 81                \{\par
82     list_init(list_inodes);\par
83     \par
84     \par
85     vfs_root = (inode_t*) kmalloc(sizeof(inode_t));\par
86     vfs_root->name[0] = '/';\par
87     vfs_root->name[1] = 0;\par
88     \par
89     vfs_root->dev = (dev_t) 0;\par
90     vfs_root->ino = (ino_t) nextinode++;\par
91     vfs_root->mode = S_IFDIR;\par
92     vfs_root->nlink = 0;\par
93     vfs_root->uid = UID_ROOT;\par
94     vfs_root->gid = GID_ROOT;\par
95     vfs_root->rdev = (dev_t) 0;\par
96     vfs_root->size = (size_t) 0;\par
97     vfs_root->atime = vfs_root->ctime = vfs_root->mtime = sys_time(NULL);\par
98     vfs_root->parent = (inode_t*) NULL;\par
99     vfs_root->link = (inode_t*) NULL;\par
100     \par
101     vfs_root->read = NULL;\par
102     vfs_root->write = NULL;\par
103     vfs_root->readdir = NULL;\par
104     vfs_root->finddir = NULL;\par
105     vfs_root->creat = NULL;\par
106     vfs_root->rename = NULL;\par
107     vfs_root->unlink = NULL;\par
108     vfs_root->chown = NULL;\par
109     vfs_root->flush = NULL;\par
110     vfs_root->ioctl = NULL;\par
111     \par
112     list_add(list_inodes, (listval_t) vfs_root);\par
113     \par
114     return 0;\par
115 \}\par
}
}
{\xe \v vfs_map\:vfs.c}
{\xe \v vfs.c\:vfs_map}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vfs_map ({\b inode_t} * {\i inode})}}
\par
{\bkmkstart AAAAAAAAKP}
{\bkmkend AAAAAAAAKP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 22 of file vfs.c.}\par
{
References inode::ino, list_add(), and nextinode.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 22                              \{\par
23     inode->ino = (ino_t) nextinode++;\par
24     list_add(list_inodes, (listval_t) inode);\par
25 \}\par
}
}
{\xe \v vfs_mapped\:vfs.c}
{\xe \v vfs.c\:vfs_mapped}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b inode_t}* vfs_mapped ({\b inode_t} * {\i parent}, char * {\i name})}}
\par
{\bkmkstart AAAAAAAAKQ}
{\bkmkend AAAAAAAAKQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 32 of file vfs.c.}\par
{
References list_foreach, inode::name, inode::parent, and value.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 32                                                  \{\par
33     list_foreach(tmp, list_inodes) \{\par
34         inode_t* value = (inode_t*) tmp;\par
35         \par
36         if(value->parent == parent)\par
37             if(strcmp(value->name, name) == 0)\par
38                 return value;\par
39     \}\par
40     \par
41     return NULL;\par
42 \}\par
}
}
{\xe \v vfs_mapped_at_index\:vfs.c}
{\xe \v vfs.c\:vfs_mapped_at_index}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b inode_t}* vfs_mapped_at_index ({\b inode_t} * {\i parent}, int {\i index})}}
\par
{\bkmkstart AAAAAAAAKR}
{\bkmkend AAAAAAAAKR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 44 of file vfs.c.}\par
{
References list_foreach, inode::parent, and value.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 44                                                          \{\par
45     list_foreach(tmp, list_inodes) \{\par
46         inode_t* value = (inode_t*) tmp;\par
47         \par
48         if(value->parent == parent)\par
49             index--;\par
50             \par
51         if(index == -1)\par
52             return value;\par
53     \}\par
54     \par
55     return NULL;\par
56 \}\par
}
}
{\xe \v vfs_mapped_count\:vfs.c}
{\xe \v vfs.c\:vfs_mapped_count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vfs_mapped_count ({\b inode_t} * {\i parent})}}
\par
{\bkmkstart AAAAAAAAKS}
{\bkmkend AAAAAAAAKS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 58 of file vfs.c.}\par
{
References list_foreach, inode::parent, and value.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 58                                       \{\par
59     int index = 0;\par
60     \par
61     list_foreach(tmp, list_inodes) \{\par
62         inode_t* value = (inode_t*) tmp;\par
63         \par
64         if(value->parent == parent)\par
65             index++;\par
66     \}\par
67     \par
68     return index;\par
69 \}\par
}
}
{\xe \v vfs_umap\:vfs.c}
{\xe \v vfs.c\:vfs_umap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vfs_umap ({\b inode_t} * {\i inode})}}
\par
{\bkmkstart AAAAAAAAKT}
{\bkmkend AAAAAAAAKT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 27 of file vfs.c.}\par
{
References kfree(), and list_remove().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 27                               \{\par
28     list_remove(list_inodes, (listval_t) inode);\par
29     kfree(inode);\par
30 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v list_inodes\:vfs.c}
{\xe \v vfs.c\:list_inodes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b list_t}* list_inodes = 0{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAKU}
{\bkmkend AAAAAAAAKU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 16 of file vfs.c.}\par
}
{\xe \v nextinode\:vfs.c}
{\xe \v vfs.c\:nextinode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} nextinode = 0{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAKV}
{\bkmkend AAAAAAAAKV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 17 of file vfs.c.}\par
}
{\xe \v vfs_root\:vfs.c}
{\xe \v vfs.c\:vfs_root}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b inode_t}* vfs_root}}
\par
{\bkmkstart AAAAAAAAKW}
{\bkmkend AAAAAAAAKW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 19 of file vfs.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/include/aplus.h File Reference\par \pard\plain 
{\tc\tcl2 \v src/include/aplus.h}
{\xe \v src/include/aplus.h}
{\bkmkstart AAAAAAAAKX}
{\bkmkend AAAAAAAAKX}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
{\f2 #include <stdarg.h>}\par
{\f2 #include <string.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b regs}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b read_reg}(n)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b write_reg}(n)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b outx}(n, t, reg)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b inx}(n, t, reg)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b outsx}(n, t, reg)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b insx}(n, t, reg)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b kprintf}(a, b...)\~ ;\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b read_reg} ({\b eax}) read_reg({\b ebx}) read_reg({\b ecx}) read_reg({\b edx}) read_reg({\b esi}) read_reg({\b edi}) read_reg({\b ebp}) read_reg({\b esp}) read_reg(cr0) read_reg(cr1) read_reg(cr2) read_reg(cr3) read_reg(cr4) read_reg({\b cs}) read_reg({\b ds}) read_reg({\b es}) read_reg({\b fs}) read_reg({\b gs}) static inline {\b uint32_t} read_eflags()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b write_reg} ({\b eax}) write_reg({\b ebx}) write_reg({\b ecx}) write_reg({\b edx}) write_reg({\b esi}) write_reg({\b edi}) write_reg({\b ebp}) write_reg({\b esp}) write_reg(cr0) write_reg(cr1) write_reg(cr2) write_reg(cr3) write_reg(cr4) write_reg({\b cs}) write_reg({\b ds}) write_reg({\b es}) write_reg({\b fs}) write_reg({\b gs}) static inline void write_eflags({\b uint32_t} val)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b outx} (b, {\b uint8_t}, al) outx(w\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ax {\b outx} (l, {\b uint32_t}, {\b eax}) {\b inx}(b\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ax al {\b inx} (w, {\b uint16_t}, ax) inx(l\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b outsx} (b, {\b uint8_t}, al) outsx(w\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ax {\b outsx} (l, {\b uint32_t}, {\b eax}) {\b insx}(b\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ax al {\b insx} (w, {\b uint16_t}, ax) insx(l\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ax al {\b eax} struct {\b regs} {\b __attribute__} ((packed)) regs_t\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ax {\b uint8_t}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ax al {\b uint32_t}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b gs}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b fs}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b es}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b ds}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b edi}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b esi}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b ebp}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b esp}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b ebx}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b edx}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b ecx}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b eax}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b int_no}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b err_code}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b eip}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b cs}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b eflags}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b useresp}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v insx\:aplus.h}
{\xe \v aplus.h\:insx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define insx( n,  t,  reg)}}
\par
{\bkmkstart AAAAAAAAKY}
{\bkmkend AAAAAAAAKY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid static inline t* ins##n(uint16_t p, t* v, uint32_t len) \{       \\\par
        for(int i = 0; i < len; i++)                                \\\par
            v[i] = in##n(p);                                        \\\par
                                                                    \\\par
        return v;                                                   \\\par
    \}\par
}
}
{\xe \v inx\:aplus.h}
{\xe \v aplus.h\:inx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define inx( n,  t,  reg)}}
\par
{\bkmkstart AAAAAAAAKZ}
{\bkmkend AAAAAAAAKZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid static inline t in##n(uint16_t p) \{                             \\\par
        t r;                                                        \\\par
        __asm__ __volatile__ ("in " #reg ", dx" : "=a"(r) : "d"(p));\\\par
        return r;                                                   \\\par
    \}\par
}
}
{\xe \v kprintf\:aplus.h}
{\xe \v aplus.h\:kprintf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define kprintf( a,  b...)\~ ;}}
\par
{\bkmkstart AAAAAAAALA}
{\bkmkend AAAAAAAALA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 147 of file aplus.h.}\par
}
{\xe \v outsx\:aplus.h}
{\xe \v aplus.h\:outsx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define outsx( n,  t,  reg)}}
\par
{\bkmkstart AAAAAAAALB}
{\bkmkend AAAAAAAALB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid static inline void outs##n(uint16_t p, t* v, uint32_t len) \{    \\\par
        for(int i = 0; i < len; i++)                                \\\par
            out##n(p, v[i]);                                        \\\par
    \}\par
}
{
Definition at line 117 of file aplus.h.}\par
}
{\xe \v outx\:aplus.h}
{\xe \v aplus.h\:outx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define outx( n,  t,  reg)}}
\par
{\bkmkstart AAAAAAAALC}
{\bkmkend AAAAAAAALC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid static inline void out##n(uint16_t p, t v) \{                    \\\par
        __asm__ __volatile__ ("out dx, " #reg : : "a"(v), "d"(p));  \\\par
    \}\par
}
{
Definition at line 96 of file aplus.h.}\par
}
{\xe \v read_reg\:aplus.h}
{\xe \v aplus.h\:read_reg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define read_reg( n)}}
\par
{\bkmkstart AAAAAAAALD}
{\bkmkend AAAAAAAALD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid static inline uint32_t read_##n() \{                         \\\par
        uint32_t ret;                                           \\\par
        __asm__ __volatile__ ("mov %0, " #n : "=r"(ret));       \\\par
        return ret;                                             \\\par
    \}\par
}
{
Definition at line 32 of file aplus.h.}\par
}
{\xe \v write_reg\:aplus.h}
{\xe \v aplus.h\:write_reg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define write_reg( n)}}
\par
{\bkmkstart AAAAAAAALE}
{\bkmkend AAAAAAAALE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid static inline void write_##n(uint32_t val) \{                \\\par
        __asm__ __volatile__ ("mov " #n ", %0" : : "r"(val));   \\\par
    \}\par
}
{
Definition at line 66 of file aplus.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v __attribute__\:aplus.h}
{\xe \v aplus.h\:__attribute__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ax al {\b eax} struct {\b regs} __attribute__ ((packed) )}}
\par
{\bkmkstart AAAAAAAALF}
{\bkmkend AAAAAAAALF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 44 of file desc.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 46                        \{\par
47     uint16_t limit;\par
48     uint32_t base;\par
49 \} __attribute__((packed)) gdt_ptr_t;\par
}
}
{\xe \v insx\:aplus.h}
{\xe \v aplus.h\:insx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ax al insx (w , {\b uint16_t} , ax )}}
\par
{\bkmkstart AAAAAAAALG}
{\bkmkend AAAAAAAALG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v inx\:aplus.h}
{\xe \v aplus.h\:inx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ax al inx (w , {\b uint16_t} , ax )}}
\par
{\bkmkstart AAAAAAAALH}
{\bkmkend AAAAAAAALH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v outsx\:aplus.h}
{\xe \v aplus.h\:outsx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
outsx (b , {\b uint8_t} , al )}}
\par
{\bkmkstart AAAAAAAALI}
{\bkmkend AAAAAAAALI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v outsx\:aplus.h}
{\xe \v aplus.h\:outsx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ax outsx (l , {\b uint32_t} , {\b eax} )}}
\par
{\bkmkstart AAAAAAAALJ}
{\bkmkend AAAAAAAALJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v outx\:aplus.h}
{\xe \v aplus.h\:outx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
outx (b , {\b uint8_t} , al )}}
\par
{\bkmkstart AAAAAAAALK}
{\bkmkend AAAAAAAALK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v outx\:aplus.h}
{\xe \v aplus.h\:outx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ax outx (l , {\b uint32_t} , {\b eax} )}}
\par
{\bkmkstart AAAAAAAALL}
{\bkmkend AAAAAAAALL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v read_reg\:aplus.h}
{\xe \v aplus.h\:read_reg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
read_reg ({\b eax} )}}
\par
{\bkmkstart AAAAAAAALM}
{\bkmkend AAAAAAAALM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 39 of file aplus.h.}\par
{
References __asm__(), and uint32_t.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 59                                      \{\par
60     uint32_t ret;\par
61     __asm__ __volatile__("pushfd; pop eax" : "=a"(ret));\par
62     return ret;\par
63 \}\par
}
}
{\xe \v write_reg\:aplus.h}
{\xe \v aplus.h\:write_reg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
write_reg ({\b eax} )}}
\par
{\bkmkstart AAAAAAAALN}
{\bkmkend AAAAAAAALN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 72 of file aplus.h.}\par
{
References __asm__().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 92                                               \{\par
93     __asm__ __volatile__("push eax; popfd" : : "a"(val));\par
94 \}   \par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v cs\:aplus.h}
{\xe \v aplus.h\:cs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} cs}}
\par
{\bkmkstart AAAAAAAALO}
{\bkmkend AAAAAAAALO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 139 of file aplus.h.}\par
}
{\xe \v ds\:aplus.h}
{\xe \v aplus.h\:ds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} ds}}
\par
{\bkmkstart AAAAAAAALP}
{\bkmkend AAAAAAAALP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 139 of file aplus.h.}\par
}
{\xe \v eax\:aplus.h}
{\xe \v aplus.h\:eax}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} eax}}
\par
{\bkmkstart AAAAAAAALQ}
{\bkmkend AAAAAAAALQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 139 of file aplus.h.}\par
}
{\xe \v ebp\:aplus.h}
{\xe \v aplus.h\:ebp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} ebp}}
\par
{\bkmkstart AAAAAAAALR}
{\bkmkend AAAAAAAALR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 139 of file aplus.h.}\par
}
{\xe \v ebx\:aplus.h}
{\xe \v aplus.h\:ebx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} ebx}}
\par
{\bkmkstart AAAAAAAALS}
{\bkmkend AAAAAAAALS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 139 of file aplus.h.}\par
}
{\xe \v ecx\:aplus.h}
{\xe \v aplus.h\:ecx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} ecx}}
\par
{\bkmkstart AAAAAAAALT}
{\bkmkend AAAAAAAALT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 139 of file aplus.h.}\par
}
{\xe \v edi\:aplus.h}
{\xe \v aplus.h\:edi}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} edi}}
\par
{\bkmkstart AAAAAAAALU}
{\bkmkend AAAAAAAALU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 139 of file aplus.h.}\par
}
{\xe \v edx\:aplus.h}
{\xe \v aplus.h\:edx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} edx}}
\par
{\bkmkstart AAAAAAAALV}
{\bkmkend AAAAAAAALV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 139 of file aplus.h.}\par
}
{\xe \v eflags\:aplus.h}
{\xe \v aplus.h\:eflags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} eflags}}
\par
{\bkmkstart AAAAAAAALW}
{\bkmkend AAAAAAAALW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 139 of file aplus.h.}\par
}
{\xe \v eip\:aplus.h}
{\xe \v aplus.h\:eip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} eip}}
\par
{\bkmkstart AAAAAAAALX}
{\bkmkend AAAAAAAALX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 139 of file aplus.h.}\par
}
{\xe \v err_code\:aplus.h}
{\xe \v aplus.h\:err_code}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} err_code}}
\par
{\bkmkstart AAAAAAAALY}
{\bkmkend AAAAAAAALY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 139 of file aplus.h.}\par
}
{\xe \v es\:aplus.h}
{\xe \v aplus.h\:es}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} es}}
\par
{\bkmkstart AAAAAAAALZ}
{\bkmkend AAAAAAAALZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 139 of file aplus.h.}\par
}
{\xe \v esi\:aplus.h}
{\xe \v aplus.h\:esi}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} esi}}
\par
{\bkmkstart AAAAAAAAMA}
{\bkmkend AAAAAAAAMA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 139 of file aplus.h.}\par
}
{\xe \v esp\:aplus.h}
{\xe \v aplus.h\:esp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} esp}}
\par
{\bkmkstart AAAAAAAAMB}
{\bkmkend AAAAAAAAMB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 139 of file aplus.h.}\par
}
{\xe \v fs\:aplus.h}
{\xe \v aplus.h\:fs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} fs}}
\par
{\bkmkstart AAAAAAAAMC}
{\bkmkend AAAAAAAAMC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 139 of file aplus.h.}\par
}
{\xe \v gs\:aplus.h}
{\xe \v aplus.h\:gs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} gs}}
\par
{\bkmkstart AAAAAAAAMD}
{\bkmkend AAAAAAAAMD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 139 of file aplus.h.}\par
}
{\xe \v int_no\:aplus.h}
{\xe \v aplus.h\:int_no}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} int_no}}
\par
{\bkmkstart AAAAAAAAME}
{\bkmkend AAAAAAAAME}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 139 of file aplus.h.}\par
}
{\xe \v uint16_t\:aplus.h}
{\xe \v aplus.h\:uint16_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t}}
\par
{\bkmkstart AAAAAAAAMF}
{\bkmkend AAAAAAAAMF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 102 of file aplus.h.}\par
}
{\xe \v uint32_t\:aplus.h}
{\xe \v aplus.h\:uint32_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ax al uint32_t}}
\par
{\bkmkstart AAAAAAAAMG}
{\bkmkend AAAAAAAAMG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 115 of file aplus.h.}\par
}
{\xe \v uint8_t\:aplus.h}
{\xe \v aplus.h\:uint8_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ax uint8_t}}
\par
{\bkmkstart AAAAAAAAMH}
{\bkmkend AAAAAAAAMH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 113 of file aplus.h.}\par
}
{\xe \v useresp\:aplus.h}
{\xe \v aplus.h\:useresp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} useresp}}
\par
{\bkmkstart AAAAAAAAMI}
{\bkmkend AAAAAAAAMI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 139 of file aplus.h.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/include/aplus/attribute.h File Reference\par \pard\plain 
{\tc\tcl2 \v src/include/aplus/attribute.h}
{\xe \v src/include/aplus/attribute.h}
{\bkmkstart AAAAAAAAMJ}
{\bkmkend AAAAAAAAMJ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <aplus.h>}\par
{\f2 #include <aplus/list.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <sys/types.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b attribute}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b __UNION2}(x, y, z)\~ x ## y ## z\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b __UNION}(x, y, z)\~ {\b __UNION2}(x, y, z)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ATTRIBUTE}({\b name}, {\b value})\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b attribute} {\b __attribute__} ((aligned(0x100))) attribute_t\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b list_t} * {\b attribute} (const char *{\b name})\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b name} [0x80]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b value}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v __UNION\:attribute.h}
{\xe \v attribute.h\:__UNION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define __UNION( x,  y,  z)\~ {\b __UNION2}(x, y, z)}}
\par
{\bkmkstart AAAAAAAAMK}
{\bkmkend AAAAAAAAMK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 15 of file attribute.h.}\par
}
{\xe \v __UNION2\:attribute.h}
{\xe \v attribute.h\:__UNION2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define __UNION2( x,  y,  z)\~ x ## y ## z}}
\par
{\bkmkstart AAAAAAAAML}
{\bkmkend AAAAAAAAML}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 12 of file attribute.h.}\par
}
{\xe \v ATTRIBUTE\:attribute.h}
{\xe \v attribute.h\:ATTRIBUTE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ATTRIBUTE( {\b name},  {\b value})}}
\par
{\bkmkstart AAAAAAAAMM}
{\bkmkend AAAAAAAAMM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid attribute_t __UNION(attribute_, value, __COUNTER__) __attribute__((section(".attribute"))) = \{  \\\par
        name, (uint32_t) &value                                                                     \\\par
    \}                                                                                               \\\par
}
{
Definition at line 18 of file attribute.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v __attribute__\:attribute.h}
{\xe \v attribute.h\:__attribute__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b attribute} __attribute__ ((aligned(0x100)) )}}
\par
{\bkmkstart AAAAAAAAMN}
{\bkmkend AAAAAAAAMN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v attribute\:attribute.h}
{\xe \v attribute.h\:attribute}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b list_t}* {\b attribute} (const char * {\i name}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAMO}
{\bkmkend AAAAAAAAMO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 31 of file attribute.h.}\par
{
References list_add(), list_init, and uint32_t.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 31                                                   \{\par
32     extern int attribute_start;\par
33     extern int attribute_end;\par
34     \par
35     uint32_t attr_s = (uint32_t) &attribute_start;\par
36     uint32_t attr_e = (uint32_t) &attribute_end;\par
37     \par
38     list_t* tmp;\par
39     list_init(tmp);\par
40     \par
41     while(attr_s < attr_e) \{\par
42         attribute_t* attr = (attribute_t*) attr_s;\par
43 \par
44         if(strcmp(attr->name, name) == 0)\par
45             list_add(tmp, (listval_t) attr->value);\par
46             \par
47         attr_s += sizeof(attribute_t);\par
48     \}\par
49     \par
50     return tmp;\par
51 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v name\:attribute.h}
{\xe \v attribute.h\:name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char name[0x80]}}
\par
{\bkmkstart AAAAAAAAMP}
{\bkmkend AAAAAAAAMP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 82 of file attribute.h.}\par
}
{\xe \v value\:attribute.h}
{\xe \v attribute.h\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} value}}
\par
{\bkmkstart AAAAAAAAMQ}
{\bkmkend AAAAAAAAMQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 83 of file attribute.h.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/include/aplus/bufio.h File Reference\par \pard\plain 
{\tc\tcl2 \v src/include/aplus/bufio.h}
{\xe \v src/include/aplus/bufio.h}
{\bkmkstart AAAAAAAAMR}
{\bkmkend AAAAAAAAMR}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
{\f2 #include <stddef.h>}\par
{\f2 #include <sys/types.h>}\par
{\f2 #include <aplus/spinlock.h>}\par
{\f2 #include <aplus/task.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b bufio}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b bufio} {\b bufio_t}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v bufio_t\:bufio.h}
{\xe \v bufio.h\:bufio_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b bufio}  {\b bufio_t}}}
\par
{\bkmkstart AAAAAAAAMS}
{\bkmkend AAAAAAAAMS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/include/aplus/fs.h File Reference\par \pard\plain 
{\tc\tcl2 \v src/include/aplus/fs.h}
{\xe \v src/include/aplus/fs.h}
{\bkmkstart AAAAAAAAMT}
{\bkmkend AAAAAAAAMT}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
{\f2 #include <stddef.h>}\par
{\f2 #include <sys/types.h>}\par
{\f2 #include <sys/stat.h>}\par
{\f2 #include <sys/dirent.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b inode}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UID_ROOT}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GID_ROOT}\~ 0\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b inode} {\b inode_t}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v GID_ROOT\:fs.h}
{\xe \v fs.h\:GID_ROOT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GID_ROOT\~ 0}}
\par
{\bkmkstart AAAAAAAAMU}
{\bkmkend AAAAAAAAMU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 27 of file fs.h.}\par
}
{\xe \v UID_ROOT\:fs.h}
{\xe \v fs.h\:UID_ROOT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UID_ROOT\~ 0}}
\par
{\bkmkstart AAAAAAAAMV}
{\bkmkend AAAAAAAAMV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 26 of file fs.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v inode_t\:fs.h}
{\xe \v fs.h\:inode_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b inode}  {\b inode_t}}}
\par
{\bkmkstart AAAAAAAAMW}
{\bkmkend AAAAAAAAMW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/include/aplus/fsys.h File Reference\par \pard\plain 
{\tc\tcl2 \v src/include/aplus/fsys.h}
{\xe \v src/include/aplus/fsys.h}
{\bkmkstart AAAAAAAAMX}
{\bkmkend AAAAAAAAMX}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <aplus.h>}\par
{\f2 #include <aplus/attribute.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b fsys}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b FSYS}({\b name}, mount)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b fsys} {\b fsys_t}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v FSYS\:fsys.h}
{\xe \v fsys.h\:FSYS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define FSYS( {\b name},  mount)}}
\par
{\bkmkstart AAAAAAAAMY}
{\bkmkend AAAAAAAAMY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid static fsys_t fs_##name = \{                                             \\\par
        #name, mount                                                        \\\par
    \}; ATTRIBUTE("fs", fs_##name)\par
}
{
Definition at line 12 of file fsys.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v fsys_t\:fsys.h}
{\xe \v fsys.h\:fsys_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b fsys}  {\b fsys_t}}}
\par
{\bkmkstart AAAAAAAAMZ}
{\bkmkend AAAAAAAAMZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/include/aplus/list.h File Reference\par \pard\plain 
{\tc\tcl2 \v src/include/aplus/list.h}
{\xe \v src/include/aplus/list.h}
{\bkmkstart AAAAAAAANA}
{\bkmkend AAAAAAAANA}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stddef.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <sys/types.h>}\par
{\f2 #include <aplus/spinlock.h>}\par
{\f2 #include <aplus/mm.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b list_body}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b list}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b list_safe_begin}({\b list})\~ {\b spinlock_lock}(&{\b list}->{\b lock})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b list_safe_end}({\b list})\~ {\b spinlock_unlock}(&{\b list}->{\b lock})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b list_foreach}({\b value}, {\b list})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b list_foreach_inverse}({\b value}, {\b list})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b list_init}({\b list})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b list_destroy}({\b list})\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b uint32_t} {\b listval_t}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b list_body} {\b list_body_t}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b list} {\b list_t}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b list_empty} ({\b list_t} *{\b list})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b list_add} ({\b list_t} *{\b list}, {\b listval_t} v)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b list_remove} ({\b list_t} *{\b list}, {\b listval_t} v)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b list_clear} ({\b list_t} *{\b list})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b list_clone} ({\b list_t} *{\b dest}, {\b list_t} *src)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b listval_t} {\b list_prev} ({\b list_t} *{\b list}, {\b listval_t} val)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b listval_t} {\b list_next} ({\b list_t} *{\b list}, {\b listval_t} val)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b listval_t} {\b list_tail} ({\b list_t} *{\b list})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b listval_t} {\b list_head} ({\b list_t} *{\b list})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v list_destroy\:list.h}
{\xe \v list.h\:list_destroy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define list_destroy( {\b list})}}
\par
{\bkmkstart AAAAAAAANB}
{\bkmkend AAAAAAAANB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid list_clear(list);                                       \\\par
    kfree(list)\par
}
{
Definition at line 193 of file list.h.}\par
}
{\xe \v list_foreach\:list.h}
{\xe \v list.h\:list_foreach}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define list_foreach( {\b value},  {\b list})}}
\par
{\bkmkstart AAAAAAAANC}
{\bkmkend AAAAAAAANC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid for(listval_t value = list_head(list);                  \\\par
        value;                                              \\\par
        value = list_next(list, value)                      \\\par
        )\par
}
{
Definition at line 175 of file list.h.}\par
}
{\xe \v list_foreach_inverse\:list.h}
{\xe \v list.h\:list_foreach_inverse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define list_foreach_inverse( {\b value},  {\b list})}}
\par
{\bkmkstart AAAAAAAAND}
{\bkmkend AAAAAAAAND}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid for(listval_t value = list_tail(list);                  \\\par
        value;                                              \\\par
        value = list_prev(list, value)                      \\\par
        )\par
}
{
Definition at line 181 of file list.h.}\par
}
{\xe \v list_init\:list.h}
{\xe \v list.h\:list_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define list_init( {\b list})}}
\par
{\bkmkstart AAAAAAAANE}
{\bkmkend AAAAAAAANE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid list = (list_t*) kmalloc(sizeof(list_t));               \\\par
    list->body = 0;                                         \\\par
    list->size = 0;                                         \\\par
    list->lock = 0\par
}
{
Definition at line 187 of file list.h.}\par
}
{\xe \v list_safe_begin\:list.h}
{\xe \v list.h\:list_safe_begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define list_safe_begin( {\b list})\~ {\b spinlock_lock}(&{\b list}->{\b lock})}}
\par
{\bkmkstart AAAAAAAANF}
{\bkmkend AAAAAAAANF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 169 of file list.h.}\par
}
{\xe \v list_safe_end\:list.h}
{\xe \v list.h\:list_safe_end}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define list_safe_end( {\b list})\~ {\b spinlock_unlock}(&{\b list}->{\b lock})}}
\par
{\bkmkstart AAAAAAAANG}
{\bkmkend AAAAAAAANG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 172 of file list.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v list_body_t\:list.h}
{\xe \v list.h\:list_body_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b list_body}  {\b list_body_t}}}
\par
{\bkmkstart AAAAAAAANH}
{\bkmkend AAAAAAAANH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v list_t\:list.h}
{\xe \v list.h\:list_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b list}  {\b list_t}}}
\par
{\bkmkstart AAAAAAAANI}
{\bkmkend AAAAAAAANI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v listval_t\:list.h}
{\xe \v list.h\:listval_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b uint32_t} {\b listval_t}}}
\par
{\bkmkstart AAAAAAAANJ}
{\bkmkend AAAAAAAANJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 33 of file list.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v list_add\:list.h}
{\xe \v list.h\:list_add}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int list_add ({\b list_t} * {\i list}, {\b listval_t} {\i v}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAANK}
{\bkmkend AAAAAAAANK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 56 of file list.h.}\par
{
References list::body, kmalloc(), list::lock, list_body::next, list::size, spinlock_lock(), spinlock_unlock(), and list_body::value.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 56                                                       \{\par
57     list_body_t* val = (list_body_t*) kmalloc(sizeof(list_body_t));\par
58     if(!val)\par
59         return -1;\par
60         \par
61     spinlock_lock(&list->lock);\par
62         \par
63     val->value = v;\par
64     val->next = list->body;\par
65     \par
66     list->body = val;\par
67     list->size += 1;\par
68     \par
69     spinlock_unlock(&list->lock);\par
70     return 0;\par
71 \}\par
}
}
{\xe \v list_clear\:list.h}
{\xe \v list.h\:list_clear}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int list_clear ({\b list_t} * {\i list}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAANL}
{\bkmkend AAAAAAAANL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 99 of file list.h.}\par
{
References list::body, kfree(), list::lock, list_body::next, list::size, spinlock_lock(), and spinlock_unlock().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 99                                            \{\par
100     spinlock_lock(&list->lock);\par
101     \par
102     list_body_t* body = list->body;\par
103     list_body_t* tmp = list->body;\par
104     \par
105     while(body) \{\par
106         tmp = body->next;\par
107         kfree(body);\par
108         body = tmp;\par
109     \}\par
110     \par
111     list->body = 0;\par
112     list->size = 0;\par
113     \par
114     spinlock_unlock(&list->lock);\par
115     return 0;\par
116 \}\par
}
}
{\xe \v list_clone\:list.h}
{\xe \v list.h\:list_clone}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void list_clone ({\b list_t} * {\i dest}, {\b list_t} * {\i src}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAANM}
{\bkmkend AAAAAAAANM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 119 of file list.h.}\par
{
References list::body, list_add(), list::lock, list_body::next, spinlock_lock(), and spinlock_unlock().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 119                                                          \{\par
120     spinlock_lock(&src->lock);\par
121     \par
122     for(list_body_t* i = src->body; i; i = i->next) \{\par
123         list_add(dest, i->value);\par
124     \}\par
125     \par
126     spinlock_unlock(&src->lock);\par
127 \}\par
}
}
{\xe \v list_empty\:list.h}
{\xe \v list.h\:list_empty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int list_empty ({\b list_t} * {\i list}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAANN}
{\bkmkend AAAAAAAANN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 49 of file list.h.}\par
{
References list::size.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 49                                            \{\par
50     if(list)\par
51         return list->size == 0;\par
52     else\par
53         return 1;   /* empty */\par
54 \}\par
}
}
{\xe \v list_head\:list.h}
{\xe \v list.h\:list_head}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b listval_t} list_head ({\b list_t} * {\i list}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAANO}
{\bkmkend AAAAAAAANO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 156 of file list.h.}\par
{
References list::body, list_body::next, and list_body::value.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 156                                                 \{\par
157 \par
158     if(!list->body)\par
159         return (listval_t) NULL;\par
160     \par
161     list_body_t* tmp = list->body;\par
162     while(tmp->next)\par
163         tmp = tmp->next;\par
164         \par
165     return (listval_t) tmp->value;\par
166 \}\par
}
}
{\xe \v list_next\:list.h}
{\xe \v list.h\:list_next}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b listval_t} list_next ({\b list_t} * {\i list}, {\b listval_t} {\i val}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAANP}
{\bkmkend AAAAAAAANP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 139 of file list.h.}\par
{
References list::body, and list_body::next.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 139                                                                \{\par
140     for(list_body_t* i = list->body; i; i = i->next) \{\par
141         if(i->next)\par
142             if(i->next->value == val)\par
143                 return i->value;\par
144     \}\par
145     \par
146     return (listval_t) NULL;\par
147 \}\par
}
}
{\xe \v list_prev\:list.h}
{\xe \v list.h\:list_prev}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b listval_t} list_prev ({\b list_t} * {\i list}, {\b listval_t} {\i val}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAANQ}
{\bkmkend AAAAAAAANQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 129 of file list.h.}\par
{
References list::body, and list_body::next.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 129                                                                \{\par
130     for(list_body_t* i = list->body; i; i = i->next) \{\par
131         if(i->value == val)\par
132             if(i->next)\par
133                 return i->next->value;\par
134     \}\par
135     \par
136     return (listval_t) NULL;\par
137 \}\par
}
}
{\xe \v list_remove\:list.h}
{\xe \v list.h\:list_remove}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int list_remove ({\b list_t} * {\i list}, {\b listval_t} {\i v}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAANR}
{\bkmkend AAAAAAAANR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 73 of file list.h.}\par
{
References list::body, kfree(), list::lock, list_body::next, spinlock_lock(), spinlock_unlock(), and list_body::value.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 73                                                          \{\par
74     spinlock_lock(&list->lock);\par
75     \par
76     list_body_t* body = list->body;\par
77     list_body_t* prev = 0;\par
78     \par
79     while(body) \{\par
80         if(body->value == v) \{\par
81             if(prev)\par
82                 prev->next = body->next;\par
83             else\par
84                 list->body = body->next;\par
85                 \par
86             body->value = 0;\par
87             kfree(body);\par
88             break;\par
89         \}\par
90         \par
91         prev = body;\par
92         body = body->next;\par
93     \}\par
94     \par
95     spinlock_unlock(&list->lock);\par
96     return 0;\par
97 \}\par
}
}
{\xe \v list_tail\:list.h}
{\xe \v list.h\:list_tail}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b listval_t} list_tail ({\b list_t} * {\i list}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAANS}
{\bkmkend AAAAAAAANS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 149 of file list.h.}\par
{
References list::body, and list_body::value.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 149                                                 \{\par
150     if(list->body)\par
151         return list->body->value;\par
152         \par
153     return (listval_t) NULL;\par
154 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/include/aplus/mm.h File Reference\par \pard\plain 
{\tc\tcl2 \v src/include/aplus/mm.h}
{\xe \v src/include/aplus/mm.h}
{\bkmkstart AAAAAAAANT}
{\bkmkend AAAAAAAANT}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
{\f2 #include <aplus/task.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b heap}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MM_VBASE}\~ 0x40000000\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MM_VSIZE}\~ (0xFFFFFFFF - MM_VBASE)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MM_LBASE}\~ 0x00000000\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MM_LSIZE}\~ 0x00800000\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MM_UBASE}\~ 0x00A00000\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MM_USIZE}\~ ({\b MM_VBASE} - {\b MM_UBASE})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b VMM_FLAGS_PRESENT}\~ 0x01\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b VMM_FLAGS_RDWR}\~ 0x02\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b VMM_FLAGS_USER}\~ 0x04\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b VMM_FLAGS_DEFAULT}\~ ({\b VMM_FLAGS_PRESENT} | {\b VMM_FLAGS_RDWR})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b VMM_MAX_MEMORY}\~ (0xFFFFFFFF - MM_VBASE)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BLKSIZE}\~ 0x1000\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BLKMAGIC}\~ 0x1234\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b heap} {\b heap_t}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void * {\b mm_paddr} (void *vaddr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void * {\b mm_vaddr} (void *paddr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void * {\b mm_align} (void *vaddr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b kmalloc} (size_t)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b kfree} (void *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b krealloc} (void *, size_t)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v BLKMAGIC\:mm.h}
{\xe \v mm.h\:BLKMAGIC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BLKMAGIC\~ 0x1234}}
\par
{\bkmkstart AAAAAAAANU}
{\bkmkend AAAAAAAANU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 58 of file mm.h.}\par
}
{\xe \v BLKSIZE\:mm.h}
{\xe \v mm.h\:BLKSIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BLKSIZE\~ 0x1000}}
\par
{\bkmkstart AAAAAAAANV}
{\bkmkend AAAAAAAANV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 57 of file mm.h.}\par
}
{\xe \v MM_LBASE\:mm.h}
{\xe \v mm.h\:MM_LBASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MM_LBASE\~ 0x00000000}}
\par
{\bkmkstart AAAAAAAANW}
{\bkmkend AAAAAAAANW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 41 of file mm.h.}\par
}
{\xe \v MM_LSIZE\:mm.h}
{\xe \v mm.h\:MM_LSIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MM_LSIZE\~ 0x00800000}}
\par
{\bkmkstart AAAAAAAANX}
{\bkmkend AAAAAAAANX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 42 of file mm.h.}\par
}
{\xe \v MM_UBASE\:mm.h}
{\xe \v mm.h\:MM_UBASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MM_UBASE\~ 0x00A00000}}
\par
{\bkmkstart AAAAAAAANY}
{\bkmkend AAAAAAAANY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 44 of file mm.h.}\par
}
{\xe \v MM_USIZE\:mm.h}
{\xe \v mm.h\:MM_USIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MM_USIZE\~ ({\b MM_VBASE} - {\b MM_UBASE})}}
\par
{\bkmkstart AAAAAAAANZ}
{\bkmkend AAAAAAAANZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 45 of file mm.h.}\par
}
{\xe \v MM_VBASE\:mm.h}
{\xe \v mm.h\:MM_VBASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MM_VBASE\~ 0x40000000}}
\par
{\bkmkstart AAAAAAAAOA}
{\bkmkend AAAAAAAAOA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 38 of file mm.h.}\par
}
{\xe \v MM_VSIZE\:mm.h}
{\xe \v mm.h\:MM_VSIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MM_VSIZE\~ (0xFFFFFFFF - MM_VBASE)}}
\par
{\bkmkstart AAAAAAAAOB}
{\bkmkend AAAAAAAAOB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 39 of file mm.h.}\par
}
{\xe \v VMM_FLAGS_DEFAULT\:mm.h}
{\xe \v mm.h\:VMM_FLAGS_DEFAULT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define VMM_FLAGS_DEFAULT\~ ({\b VMM_FLAGS_PRESENT} | {\b VMM_FLAGS_RDWR})}}
\par
{\bkmkstart AAAAAAAAOC}
{\bkmkend AAAAAAAAOC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 52 of file mm.h.}\par
}
{\xe \v VMM_FLAGS_PRESENT\:mm.h}
{\xe \v mm.h\:VMM_FLAGS_PRESENT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define VMM_FLAGS_PRESENT\~ 0x01}}
\par
{\bkmkstart AAAAAAAAOD}
{\bkmkend AAAAAAAAOD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 49 of file mm.h.}\par
}
{\xe \v VMM_FLAGS_RDWR\:mm.h}
{\xe \v mm.h\:VMM_FLAGS_RDWR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define VMM_FLAGS_RDWR\~ 0x02}}
\par
{\bkmkstart AAAAAAAAOE}
{\bkmkend AAAAAAAAOE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 50 of file mm.h.}\par
}
{\xe \v VMM_FLAGS_USER\:mm.h}
{\xe \v mm.h\:VMM_FLAGS_USER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define VMM_FLAGS_USER\~ 0x04}}
\par
{\bkmkstart AAAAAAAAOF}
{\bkmkend AAAAAAAAOF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 51 of file mm.h.}\par
}
{\xe \v VMM_MAX_MEMORY\:mm.h}
{\xe \v mm.h\:VMM_MAX_MEMORY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define VMM_MAX_MEMORY\~ (0xFFFFFFFF - MM_VBASE)}}
\par
{\bkmkstart AAAAAAAAOG}
{\bkmkend AAAAAAAAOG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 54 of file mm.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v heap_t\:mm.h}
{\xe \v mm.h\:heap_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b heap}  {\b heap_t}}}
\par
{\bkmkstart AAAAAAAAOH}
{\bkmkend AAAAAAAAOH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v kfree\:mm.h}
{\xe \v mm.h\:kfree}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void kfree (void * )}}
\par
{\bkmkstart AAAAAAAAOI}
{\bkmkend AAAAAAAAOI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 66 of file mm.c.}\par
{
References BLKMAGIC, hfree(), mm_align(), mm_paddr(), and size.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 66                       \{\par
67     if(!ptr)\par
68         return;\par
69         \par
70     \par
71     block_t* block = (block_t*) ptr;\par
72     if(block->magic != BLKMAGIC)\par
73         return;\par
74         \par
75     size_t size = block->size;\par
76     block->size = 0;\par
77     block->magic = 0;\par
78     \par
79     \par
80     hfree(current_heap, mm_paddr(mm_align(ptr)), size);\par
81 \}\par
}
}
{\xe \v kmalloc\:mm.h}
{\xe \v mm.h\:kmalloc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* kmalloc (size_t )}}
\par
{\bkmkstart AAAAAAAAOJ}
{\bkmkend AAAAAAAAOJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v krealloc\:mm.h}
{\xe \v mm.h\:krealloc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* krealloc (void * , size_t )}}
\par
{\bkmkstart AAAAAAAAOK}
{\bkmkend AAAAAAAAOK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 84 of file mm.c.}\par
{
References BLKMAGIC, kfree(), and kmalloc().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 84                                        \{\par
85     if(ptr == NULL)\par
86         return kmalloc(size);\par
87         \par
88     if(size == 0) \{\par
89         kfree(ptr);\par
90         return NULL;\par
91     \}   \par
92 \par
93     block_t* block = (block_t*) ptr;\par
94     if(block->magic != BLKMAGIC)\par
95         return NULL;\par
96         \par
97     void* newptr = kmalloc(size);\par
98     if(!newptr)\par
99         return NULL;\par
100         \par
101     if(size > block->size)\par
102         size = block->size;\par
103         \par
104     memcpy(newptr, ptr, size);\par
105     kfree(ptr);\par
106     \par
107     return newptr;\par
108 \}\par
}
}
{\xe \v mm_align\:mm.h}
{\xe \v mm.h\:mm_align}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void* mm_align (void * {\i vaddr}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAOL}
{\bkmkend AAAAAAAAOL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 85 of file mm.h.}\par
{
References uint32_t.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 85                                           \{\par
86     return (void*) ((uint32_t) vaddr & ~0xFFF);\par
87 \}\par
}
}
{\xe \v mm_paddr\:mm.h}
{\xe \v mm.h\:mm_paddr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void* mm_paddr (void * {\i vaddr}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAOM}
{\bkmkend AAAAAAAAOM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 71 of file mm.h.}\par
{
References MM_VBASE, and uint32_t.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 71                                           \{\par
72     if((uint32_t) vaddr > MM_VBASE)\par
73         vaddr = (void*) ((uint32_t) vaddr - MM_VBASE);\par
74         \par
75     return vaddr;\par
76 \}\par
}
}
{\xe \v mm_vaddr\:mm.h}
{\xe \v mm.h\:mm_vaddr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void* mm_vaddr (void * {\i paddr}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAON}
{\bkmkend AAAAAAAAON}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 78 of file mm.h.}\par
{
References MM_VBASE, and uint32_t.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 78                                           \{\par
79     if((uint32_t) paddr < MM_VBASE)\par
80         paddr = (void*) ((uint32_t) paddr + MM_VBASE);\par
81         \par
82     return paddr;\par
83 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/include/aplus/net/arp.h File Reference\par \pard\plain 
{\tc\tcl2 \v src/include/aplus/net/arp.h}
{\xe \v src/include/aplus/net/arp.h}
{\bkmkstart AAAAAAAAOO}
{\bkmkend AAAAAAAAOO}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
{\f2 #include <aplus/netif.h>}\par
{\f2 #include <aplus/net/eth.h>}\par
{\f2 #include <time.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b arp_header}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b arp_cache_entry}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ARP_PRTYPE}\~ {\b ETH_TYPE_IPV4}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ARP_PRLEN}\~ 4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ARP_HWTYPE}\~ 0x0001\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ARP_HWLEN}\~ 6\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ARP_OPERATION_REQUEST}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ARP_OPERATION_REPLY}\~ 2\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ARP_TTL}\~ 600		/* 10min */\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b arp_cache_entry} {\b arp_cache_entry_t}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b arp_header} {\b __attribute__} ((packed)) arp_header_t\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b hwtype}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b prtype}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b hwlen}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b prlen}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b operation}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b macaddr_t} {\b sha}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ipv4_t} {\b spa}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b macaddr_t} {\b tha}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ipv4_t} {\b tpa}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v ARP_HWLEN\:arp.h}
{\xe \v arp.h\:ARP_HWLEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ARP_HWLEN\~ 6}}
\par
{\bkmkstart AAAAAAAAOP}
{\bkmkend AAAAAAAAOP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 16 of file arp.h.}\par
}
{\xe \v ARP_HWTYPE\:arp.h}
{\xe \v arp.h\:ARP_HWTYPE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ARP_HWTYPE\~ 0x0001}}
\par
{\bkmkstart AAAAAAAAOQ}
{\bkmkend AAAAAAAAOQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 15 of file arp.h.}\par
}
{\xe \v ARP_OPERATION_REPLY\:arp.h}
{\xe \v arp.h\:ARP_OPERATION_REPLY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ARP_OPERATION_REPLY\~ 2}}
\par
{\bkmkstart AAAAAAAAOR}
{\bkmkend AAAAAAAAOR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 19 of file arp.h.}\par
}
{\xe \v ARP_OPERATION_REQUEST\:arp.h}
{\xe \v arp.h\:ARP_OPERATION_REQUEST}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ARP_OPERATION_REQUEST\~ 1}}
\par
{\bkmkstart AAAAAAAAOS}
{\bkmkend AAAAAAAAOS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 18 of file arp.h.}\par
}
{\xe \v ARP_PRLEN\:arp.h}
{\xe \v arp.h\:ARP_PRLEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ARP_PRLEN\~ 4}}
\par
{\bkmkstart AAAAAAAAOT}
{\bkmkend AAAAAAAAOT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 13 of file arp.h.}\par
}
{\xe \v ARP_PRTYPE\:arp.h}
{\xe \v arp.h\:ARP_PRTYPE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ARP_PRTYPE\~ {\b ETH_TYPE_IPV4}}}
\par
{\bkmkstart AAAAAAAAOU}
{\bkmkend AAAAAAAAOU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 12 of file arp.h.}\par
}
{\xe \v ARP_TTL\:arp.h}
{\xe \v arp.h\:ARP_TTL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ARP_TTL\~ 600		/* 10min */}}
\par
{\bkmkstart AAAAAAAAOV}
{\bkmkend AAAAAAAAOV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 21 of file arp.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v arp_cache_entry_t\:arp.h}
{\xe \v arp.h\:arp_cache_entry_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b arp_cache_entry}  {\b arp_cache_entry_t}}}
\par
{\bkmkstart AAAAAAAAOW}
{\bkmkend AAAAAAAAOW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v __attribute__\:arp.h}
{\xe \v arp.h\:__attribute__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b arp_header} __attribute__ ((packed) )}}
\par
{\bkmkstart AAAAAAAAOX}
{\bkmkend AAAAAAAAOX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 44 of file desc.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 46                        \{\par
47     uint16_t limit;\par
48     uint32_t base;\par
49 \} __attribute__((packed)) gdt_ptr_t;\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v hwlen\:arp.h}
{\xe \v arp.h\:hwlen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} hwlen}}
\par
{\bkmkstart AAAAAAAAOY}
{\bkmkend AAAAAAAAOY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 71 of file arp.h.}\par
}
{\xe \v hwtype\:arp.h}
{\xe \v arp.h\:hwtype}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} hwtype}}
\par
{\bkmkstart AAAAAAAAOZ}
{\bkmkend AAAAAAAAOZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 69 of file arp.h.}\par
}
{\xe \v operation\:arp.h}
{\xe \v arp.h\:operation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} operation}}
\par
{\bkmkstart AAAAAAAAPA}
{\bkmkend AAAAAAAAPA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 73 of file arp.h.}\par
}
{\xe \v prlen\:arp.h}
{\xe \v arp.h\:prlen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} prlen}}
\par
{\bkmkstart AAAAAAAAPB}
{\bkmkend AAAAAAAAPB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 72 of file arp.h.}\par
}
{\xe \v prtype\:arp.h}
{\xe \v arp.h\:prtype}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} prtype}}
\par
{\bkmkstart AAAAAAAAPC}
{\bkmkend AAAAAAAAPC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 70 of file arp.h.}\par
}
{\xe \v sha\:arp.h}
{\xe \v arp.h\:sha}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b macaddr_t} sha}}
\par
{\bkmkstart AAAAAAAAPD}
{\bkmkend AAAAAAAAPD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 74 of file arp.h.}\par
}
{\xe \v spa\:arp.h}
{\xe \v arp.h\:spa}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ipv4_t} spa}}
\par
{\bkmkstart AAAAAAAAPE}
{\bkmkend AAAAAAAAPE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 75 of file arp.h.}\par
}
{\xe \v tha\:arp.h}
{\xe \v arp.h\:tha}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b macaddr_t} tha}}
\par
{\bkmkstart AAAAAAAAPF}
{\bkmkend AAAAAAAAPF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 76 of file arp.h.}\par
}
{\xe \v tpa\:arp.h}
{\xe \v arp.h\:tpa}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ipv4_t} tpa}}
\par
{\bkmkstart AAAAAAAAPG}
{\bkmkend AAAAAAAAPG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 77 of file arp.h.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/include/aplus/net/eth.h File Reference\par \pard\plain 
{\tc\tcl2 \v src/include/aplus/net/eth.h}
{\xe \v src/include/aplus/net/eth.h}
{\bkmkstart AAAAAAAAPH}
{\bkmkend AAAAAAAAPH}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
{\f2 #include <aplus/netif.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b eth_header}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ETH_TYPE_IPV4}\~ 0x0800\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ETH_TYPE_ARP}\~ 0x0806\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ETH_TYPE_IPV6}\~ 0x86DD\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ETH_TYPE_WAKEONLAN}\~ 0x0842\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ETH_TYPE_RARP}\~ 0x8035\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ETH_TYPE_RAW}\~ 0xFFFF\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b eth_header} {\b __attribute__} ((packed)) eth_header_t\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b macaddr_t} {\b dest}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b macaddr_t} {\b source}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b type}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v ETH_TYPE_ARP\:eth.h}
{\xe \v eth.h\:ETH_TYPE_ARP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ETH_TYPE_ARP\~ 0x0806}}
\par
{\bkmkstart AAAAAAAAPI}
{\bkmkend AAAAAAAAPI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 13 of file eth.h.}\par
}
{\xe \v ETH_TYPE_IPV4\:eth.h}
{\xe \v eth.h\:ETH_TYPE_IPV4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ETH_TYPE_IPV4\~ 0x0800}}
\par
{\bkmkstart AAAAAAAAPJ}
{\bkmkend AAAAAAAAPJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 12 of file eth.h.}\par
}
{\xe \v ETH_TYPE_IPV6\:eth.h}
{\xe \v eth.h\:ETH_TYPE_IPV6}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ETH_TYPE_IPV6\~ 0x86DD}}
\par
{\bkmkstart AAAAAAAAPK}
{\bkmkend AAAAAAAAPK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 14 of file eth.h.}\par
}
{\xe \v ETH_TYPE_RARP\:eth.h}
{\xe \v eth.h\:ETH_TYPE_RARP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ETH_TYPE_RARP\~ 0x8035}}
\par
{\bkmkstart AAAAAAAAPL}
{\bkmkend AAAAAAAAPL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 16 of file eth.h.}\par
}
{\xe \v ETH_TYPE_RAW\:eth.h}
{\xe \v eth.h\:ETH_TYPE_RAW}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ETH_TYPE_RAW\~ 0xFFFF}}
\par
{\bkmkstart AAAAAAAAPM}
{\bkmkend AAAAAAAAPM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 17 of file eth.h.}\par
}
{\xe \v ETH_TYPE_WAKEONLAN\:eth.h}
{\xe \v eth.h\:ETH_TYPE_WAKEONLAN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ETH_TYPE_WAKEONLAN\~ 0x0842}}
\par
{\bkmkstart AAAAAAAAPN}
{\bkmkend AAAAAAAAPN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 15 of file eth.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v __attribute__\:eth.h}
{\xe \v eth.h\:__attribute__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b eth_header} __attribute__ ((packed) )}}
\par
{\bkmkstart AAAAAAAAPO}
{\bkmkend AAAAAAAAPO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 44 of file desc.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 46                        \{\par
47     uint16_t limit;\par
48     uint32_t base;\par
49 \} __attribute__((packed)) gdt_ptr_t;\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v dest\:eth.h}
{\xe \v eth.h\:dest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b macaddr_t} dest}}
\par
{\bkmkstart AAAAAAAAPP}
{\bkmkend AAAAAAAAPP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 44 of file eth.h.}\par
}
{\xe \v source\:eth.h}
{\xe \v eth.h\:source}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b macaddr_t} source}}
\par
{\bkmkstart AAAAAAAAPQ}
{\bkmkend AAAAAAAAPQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 45 of file eth.h.}\par
}
{\xe \v type\:eth.h}
{\xe \v eth.h\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} type}}
\par
{\bkmkstart AAAAAAAAPR}
{\bkmkend AAAAAAAAPR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 46 of file eth.h.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/include/aplus/net/ipv4.h File Reference\par \pard\plain 
{\tc\tcl2 \v src/include/aplus/net/ipv4.h}
{\xe \v src/include/aplus/net/ipv4.h}
{\bkmkstart AAAAAAAAPS}
{\bkmkend AAAAAAAAPS}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
{\f2 #include <aplus/netif.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ipv4_header}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _IPV4_h}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b IPV4_FLAGS_DF}\~ 0x01	/* Don't fragment */\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b IPV4_FLAGS_MF}\~ 0x02	/* More fragment */\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b IPV4_CHECK_VERSION}(head)\~ ((head->{\b info} & 0x0F) == 4)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b IPV4_HEADER_LENGTH}(head)\~ (((head->{\b info} & 0xF0) >> 4) * 4)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b IPV4_FLAGS}(head)\~ (head->{\b offset} & 3)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b IPV4_OFFSET}(head)\~ ((head->{\b offset} >> 2) * 8)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b IPV4_TOS_PRIORITY}({\b tos})\~ ({\b tos} & 3)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b IPV4_TOS_LATENCY}({\b tos})\~ (({\b tos} >> 2) & 1)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b IPV4_TOS_TROUGHPUT}({\b tos})\~ (({\b tos} >> 3) & 1)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b IPV4_TOS_RELIABILITY}({\b tos})\~ (({\b tos} >> 4) & 1)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b IPV4_PROTO_RAW}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b IPV4_PROTO_ICMP}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b IPV4_PROTO_TCP}\~ 6\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b IPV4_PROTO_UDP}\~ 17\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b IPV4_MAX_LENGTH}\~ 65536\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ipv4_header} {\b __attribute__} ((packed)) ipv4_header_t\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b info}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b tos}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b length}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b id}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b offset}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b ttl}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b protocol}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b checksum}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ipv4_t} {\b source}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ipv4_t} {\b dest}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v _IPV4_h\:ipv4.h}
{\xe \v ipv4.h\:_IPV4_h}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _IPV4_h}}
\par
{\bkmkstart AAAAAAAAPT}
{\bkmkend AAAAAAAAPT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 2 of file ipv4.h.}\par
}
{\xe \v IPV4_CHECK_VERSION\:ipv4.h}
{\xe \v ipv4.h\:IPV4_CHECK_VERSION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define IPV4_CHECK_VERSION( head)\~ ((head->{\b info} & 0x0F) == 4)}}
\par
{\bkmkstart AAAAAAAAPU}
{\bkmkend AAAAAAAAPU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 11 of file ipv4.h.}\par
}
{\xe \v IPV4_FLAGS\:ipv4.h}
{\xe \v ipv4.h\:IPV4_FLAGS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define IPV4_FLAGS( head)\~ (head->{\b offset} & 3)}}
\par
{\bkmkstart AAAAAAAAPV}
{\bkmkend AAAAAAAAPV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 13 of file ipv4.h.}\par
}
{\xe \v IPV4_FLAGS_DF\:ipv4.h}
{\xe \v ipv4.h\:IPV4_FLAGS_DF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define IPV4_FLAGS_DF\~ 0x01	/* Don't fragment */}}
\par
{\bkmkstart AAAAAAAAPW}
{\bkmkend AAAAAAAAPW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 8 of file ipv4.h.}\par
}
{\xe \v IPV4_FLAGS_MF\:ipv4.h}
{\xe \v ipv4.h\:IPV4_FLAGS_MF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define IPV4_FLAGS_MF\~ 0x02	/* More fragment */}}
\par
{\bkmkstart AAAAAAAAPX}
{\bkmkend AAAAAAAAPX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9 of file ipv4.h.}\par
}
{\xe \v IPV4_HEADER_LENGTH\:ipv4.h}
{\xe \v ipv4.h\:IPV4_HEADER_LENGTH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define IPV4_HEADER_LENGTH( head)\~ (((head->{\b info} & 0xF0) >> 4) * 4)}}
\par
{\bkmkstart AAAAAAAAPY}
{\bkmkend AAAAAAAAPY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 12 of file ipv4.h.}\par
}
{\xe \v IPV4_MAX_LENGTH\:ipv4.h}
{\xe \v ipv4.h\:IPV4_MAX_LENGTH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define IPV4_MAX_LENGTH\~ 65536}}
\par
{\bkmkstart AAAAAAAAPZ}
{\bkmkend AAAAAAAAPZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 27 of file ipv4.h.}\par
}
{\xe \v IPV4_OFFSET\:ipv4.h}
{\xe \v ipv4.h\:IPV4_OFFSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define IPV4_OFFSET( head)\~ ((head->{\b offset} >> 2) * 8)}}
\par
{\bkmkstart AAAAAAAAQA}
{\bkmkend AAAAAAAAQA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 14 of file ipv4.h.}\par
}
{\xe \v IPV4_PROTO_ICMP\:ipv4.h}
{\xe \v ipv4.h\:IPV4_PROTO_ICMP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define IPV4_PROTO_ICMP\~ 1}}
\par
{\bkmkstart AAAAAAAAQB}
{\bkmkend AAAAAAAAQB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 23 of file ipv4.h.}\par
}
{\xe \v IPV4_PROTO_RAW\:ipv4.h}
{\xe \v ipv4.h\:IPV4_PROTO_RAW}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define IPV4_PROTO_RAW\~ 0}}
\par
{\bkmkstart AAAAAAAAQC}
{\bkmkend AAAAAAAAQC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 22 of file ipv4.h.}\par
}
{\xe \v IPV4_PROTO_TCP\:ipv4.h}
{\xe \v ipv4.h\:IPV4_PROTO_TCP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define IPV4_PROTO_TCP\~ 6}}
\par
{\bkmkstart AAAAAAAAQD}
{\bkmkend AAAAAAAAQD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 24 of file ipv4.h.}\par
}
{\xe \v IPV4_PROTO_UDP\:ipv4.h}
{\xe \v ipv4.h\:IPV4_PROTO_UDP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define IPV4_PROTO_UDP\~ 17}}
\par
{\bkmkstart AAAAAAAAQE}
{\bkmkend AAAAAAAAQE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 25 of file ipv4.h.}\par
}
{\xe \v IPV4_TOS_LATENCY\:ipv4.h}
{\xe \v ipv4.h\:IPV4_TOS_LATENCY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define IPV4_TOS_LATENCY( {\b tos})\~ (({\b tos} >> 2) & 1)}}
\par
{\bkmkstart AAAAAAAAQF}
{\bkmkend AAAAAAAAQF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 17 of file ipv4.h.}\par
}
{\xe \v IPV4_TOS_PRIORITY\:ipv4.h}
{\xe \v ipv4.h\:IPV4_TOS_PRIORITY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define IPV4_TOS_PRIORITY( {\b tos})\~ ({\b tos} & 3)}}
\par
{\bkmkstart AAAAAAAAQG}
{\bkmkend AAAAAAAAQG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 16 of file ipv4.h.}\par
}
{\xe \v IPV4_TOS_RELIABILITY\:ipv4.h}
{\xe \v ipv4.h\:IPV4_TOS_RELIABILITY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define IPV4_TOS_RELIABILITY( {\b tos})\~ (({\b tos} >> 4) & 1)}}
\par
{\bkmkstart AAAAAAAAQH}
{\bkmkend AAAAAAAAQH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 19 of file ipv4.h.}\par
}
{\xe \v IPV4_TOS_TROUGHPUT\:ipv4.h}
{\xe \v ipv4.h\:IPV4_TOS_TROUGHPUT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define IPV4_TOS_TROUGHPUT( {\b tos})\~ (({\b tos} >> 3) & 1)}}
\par
{\bkmkstart AAAAAAAAQI}
{\bkmkend AAAAAAAAQI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 18 of file ipv4.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v __attribute__\:ipv4.h}
{\xe \v ipv4.h\:__attribute__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b ipv4_header} __attribute__ ((packed) )}}
\par
{\bkmkstart AAAAAAAAQJ}
{\bkmkend AAAAAAAAQJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 44 of file desc.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 46                        \{\par
47     uint16_t limit;\par
48     uint32_t base;\par
49 \} __attribute__((packed)) gdt_ptr_t;\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v checksum\:ipv4.h}
{\xe \v ipv4.h\:checksum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} checksum}}
\par
{\bkmkstart AAAAAAAAQK}
{\bkmkend AAAAAAAAQK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 54 of file ipv4.h.}\par
}
{\xe \v dest\:ipv4.h}
{\xe \v ipv4.h\:dest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ipv4_t} dest}}
\par
{\bkmkstart AAAAAAAAQL}
{\bkmkend AAAAAAAAQL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 57 of file ipv4.h.}\par
}
{\xe \v id\:ipv4.h}
{\xe \v ipv4.h\:id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} id}}
\par
{\bkmkstart AAAAAAAAQM}
{\bkmkend AAAAAAAAQM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 50 of file ipv4.h.}\par
}
{\xe \v info\:ipv4.h}
{\xe \v ipv4.h\:info}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} info}}
\par
{\bkmkstart AAAAAAAAQN}
{\bkmkend AAAAAAAAQN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 47 of file ipv4.h.}\par
}
{\xe \v length\:ipv4.h}
{\xe \v ipv4.h\:length}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} length}}
\par
{\bkmkstart AAAAAAAAQO}
{\bkmkend AAAAAAAAQO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 49 of file ipv4.h.}\par
}
{\xe \v offset\:ipv4.h}
{\xe \v ipv4.h\:offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} offset}}
\par
{\bkmkstart AAAAAAAAQP}
{\bkmkend AAAAAAAAQP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 51 of file ipv4.h.}\par
}
{\xe \v protocol\:ipv4.h}
{\xe \v ipv4.h\:protocol}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} protocol}}
\par
{\bkmkstart AAAAAAAAQQ}
{\bkmkend AAAAAAAAQQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 53 of file ipv4.h.}\par
}
{\xe \v source\:ipv4.h}
{\xe \v ipv4.h\:source}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ipv4_t} source}}
\par
{\bkmkstart AAAAAAAAQR}
{\bkmkend AAAAAAAAQR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 56 of file ipv4.h.}\par
}
{\xe \v tos\:ipv4.h}
{\xe \v ipv4.h\:tos}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} tos}}
\par
{\bkmkstart AAAAAAAAQS}
{\bkmkend AAAAAAAAQS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 48 of file ipv4.h.}\par
}
{\xe \v ttl\:ipv4.h}
{\xe \v ipv4.h\:ttl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} ttl}}
\par
{\bkmkstart AAAAAAAAQT}
{\bkmkend AAAAAAAAQT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 52 of file ipv4.h.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/include/aplus/net/ipv6.h File Reference\par \pard\plain 
{\tc\tcl2 \v src/include/aplus/net/ipv6.h}
{\xe \v src/include/aplus/net/ipv6.h}
{\bkmkstart AAAAAAAAQU}
{\bkmkend AAAAAAAAQU}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
{\f2 #include <aplus/netif.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ipv6_header}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b IPV6_CHECK_VERSION}(head)\~ (head->{\b version} == 6)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b IPV6_PROTO_RAW}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b IPV6_PROTO_ICMP}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b IPV6_PROTO_TCP}\~ 6\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b IPV6_PROTO_UDP}\~ 17\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ipv6_header} {\b __attribute__} ((packed)) ipv6_header_t\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b version}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b traffic}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b flow}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b length}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b protocol}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b ttl}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ipv6_t} {\b source}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ipv6_t} {\b dest}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v IPV6_CHECK_VERSION\:ipv6.h}
{\xe \v ipv6.h\:IPV6_CHECK_VERSION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define IPV6_CHECK_VERSION( head)\~ (head->{\b version} == 6)}}
\par
{\bkmkstart AAAAAAAAQV}
{\bkmkend AAAAAAAAQV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 8 of file ipv6.h.}\par
}
{\xe \v IPV6_PROTO_ICMP\:ipv6.h}
{\xe \v ipv6.h\:IPV6_PROTO_ICMP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define IPV6_PROTO_ICMP\~ 1}}
\par
{\bkmkstart AAAAAAAAQW}
{\bkmkend AAAAAAAAQW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 11 of file ipv6.h.}\par
}
{\xe \v IPV6_PROTO_RAW\:ipv6.h}
{\xe \v ipv6.h\:IPV6_PROTO_RAW}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define IPV6_PROTO_RAW\~ 0}}
\par
{\bkmkstart AAAAAAAAQX}
{\bkmkend AAAAAAAAQX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 10 of file ipv6.h.}\par
}
{\xe \v IPV6_PROTO_TCP\:ipv6.h}
{\xe \v ipv6.h\:IPV6_PROTO_TCP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define IPV6_PROTO_TCP\~ 6}}
\par
{\bkmkstart AAAAAAAAQY}
{\bkmkend AAAAAAAAQY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 12 of file ipv6.h.}\par
}
{\xe \v IPV6_PROTO_UDP\:ipv6.h}
{\xe \v ipv6.h\:IPV6_PROTO_UDP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define IPV6_PROTO_UDP\~ 17}}
\par
{\bkmkstart AAAAAAAAQZ}
{\bkmkend AAAAAAAAQZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 13 of file ipv6.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v __attribute__\:ipv6.h}
{\xe \v ipv6.h\:__attribute__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b ipv6_header} __attribute__ ((packed) )}}
\par
{\bkmkstart AAAAAAAARA}
{\bkmkend AAAAAAAARA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 44 of file desc.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 46                        \{\par
47     uint16_t limit;\par
48     uint32_t base;\par
49 \} __attribute__((packed)) gdt_ptr_t;\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v dest\:ipv6.h}
{\xe \v ipv6.h\:dest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ipv6_t} dest}}
\par
{\bkmkstart AAAAAAAARB}
{\bkmkend AAAAAAAARB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 67 of file ipv6.h.}\par
}
{\xe \v flow\:ipv6.h}
{\xe \v ipv6.h\:flow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} flow}}
\par
{\bkmkstart AAAAAAAARC}
{\bkmkend AAAAAAAARC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 60 of file ipv6.h.}\par
}
{\xe \v length\:ipv6.h}
{\xe \v ipv6.h\:length}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} length}}
\par
{\bkmkstart AAAAAAAARD}
{\bkmkend AAAAAAAARD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 62 of file ipv6.h.}\par
}
{\xe \v protocol\:ipv6.h}
{\xe \v ipv6.h\:protocol}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} protocol}}
\par
{\bkmkstart AAAAAAAARE}
{\bkmkend AAAAAAAARE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 63 of file ipv6.h.}\par
}
{\xe \v source\:ipv6.h}
{\xe \v ipv6.h\:source}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ipv6_t} source}}
\par
{\bkmkstart AAAAAAAARF}
{\bkmkend AAAAAAAARF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 66 of file ipv6.h.}\par
}
{\xe \v traffic\:ipv6.h}
{\xe \v ipv6.h\:traffic}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} traffic}}
\par
{\bkmkstart AAAAAAAARG}
{\bkmkend AAAAAAAARG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 59 of file ipv6.h.}\par
}
{\xe \v ttl\:ipv6.h}
{\xe \v ipv6.h\:ttl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} ttl}}
\par
{\bkmkstart AAAAAAAARH}
{\bkmkend AAAAAAAARH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 64 of file ipv6.h.}\par
}
{\xe \v version\:ipv6.h}
{\xe \v ipv6.h\:version}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} version}}
\par
{\bkmkstart AAAAAAAARI}
{\bkmkend AAAAAAAARI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 58 of file ipv6.h.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/include/aplus/net/udp.h File Reference\par \pard\plain 
{\tc\tcl2 \v src/include/aplus/net/udp.h}
{\xe \v src/include/aplus/net/udp.h}
{\bkmkstart AAAAAAAARJ}
{\bkmkend AAAAAAAARJ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
{\f2 #include <aplus/netif.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b udp_header}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b udp_header} {\b __attribute__} ((packed)) udp_header_t\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b src_port}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b dst_port}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b length}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b checksum}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v __attribute__\:udp.h}
{\xe \v udp.h\:__attribute__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b udp_header} __attribute__ ((packed) )}}
\par
{\bkmkstart AAAAAAAARK}
{\bkmkend AAAAAAAARK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 44 of file desc.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 46                        \{\par
47     uint16_t limit;\par
48     uint32_t base;\par
49 \} __attribute__((packed)) gdt_ptr_t;\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v checksum\:udp.h}
{\xe \v udp.h\:checksum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} checksum}}
\par
{\bkmkstart AAAAAAAARL}
{\bkmkend AAAAAAAARL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 71 of file udp.h.}\par
}
{\xe \v dst_port\:udp.h}
{\xe \v udp.h\:dst_port}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} dst_port}}
\par
{\bkmkstart AAAAAAAARM}
{\bkmkend AAAAAAAARM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 69 of file udp.h.}\par
}
{\xe \v length\:udp.h}
{\xe \v udp.h\:length}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} length}}
\par
{\bkmkstart AAAAAAAARN}
{\bkmkend AAAAAAAARN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 70 of file udp.h.}\par
}
{\xe \v src_port\:udp.h}
{\xe \v udp.h\:src_port}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} src_port}}
\par
{\bkmkstart AAAAAAAARO}
{\bkmkend AAAAAAAARO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 68 of file udp.h.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/include/aplus/netif.h File Reference\par \pard\plain 
{\tc\tcl2 \v src/include/aplus/netif.h}
{\xe \v src/include/aplus/netif.h}
{\bkmkstart AAAAAAAARP}
{\bkmkend AAAAAAAARP}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <aplus.h>}\par
{\f2 #include <aplus/pci.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <stddef.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b netif}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b netif_packet}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b netif_socket}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NETIF_RAW}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NETIF_INET}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NETIF_INET6}\~ 2\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NETIF_ARP}\~ 3\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NETIF_ETH}\~ 4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NETIF_UDP}\~ 5\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NETIF_TCP}\~ 6\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NETIF_ICMP}\~ 7\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NETIF_TELNET}\~ 8\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NETIF_FLAGS_ENABLE}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ARP_DEBUG}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b RTL8139_DEBUG}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b uint8_t} {\b ipv4_t} [4]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b uint16_t} {\b ipv6_t} [8]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b uint8_t} {\b macaddr_t} [6]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b netif} {\b netif_t}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b netif_packet} {\b netif_packet_t}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b netif_socket} {\b netif_socket_t}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v ARP_DEBUG\:netif.h}
{\xe \v netif.h\:ARP_DEBUG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ARP_DEBUG}}
\par
{\bkmkstart AAAAAAAARQ}
{\bkmkend AAAAAAAARQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 29 of file netif.h.}\par
}
{\xe \v NETIF_ARP\:netif.h}
{\xe \v netif.h\:NETIF_ARP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NETIF_ARP\~ 3}}
\par
{\bkmkstart AAAAAAAARR}
{\bkmkend AAAAAAAARR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 18 of file netif.h.}\par
}
{\xe \v NETIF_ETH\:netif.h}
{\xe \v netif.h\:NETIF_ETH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NETIF_ETH\~ 4}}
\par
{\bkmkstart AAAAAAAARS}
{\bkmkend AAAAAAAARS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 19 of file netif.h.}\par
}
{\xe \v NETIF_FLAGS_ENABLE\:netif.h}
{\xe \v netif.h\:NETIF_FLAGS_ENABLE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NETIF_FLAGS_ENABLE\~ 1}}
\par
{\bkmkstart AAAAAAAART}
{\bkmkend AAAAAAAART}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 26 of file netif.h.}\par
}
{\xe \v NETIF_ICMP\:netif.h}
{\xe \v netif.h\:NETIF_ICMP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NETIF_ICMP\~ 7}}
\par
{\bkmkstart AAAAAAAARU}
{\bkmkend AAAAAAAARU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 22 of file netif.h.}\par
}
{\xe \v NETIF_INET\:netif.h}
{\xe \v netif.h\:NETIF_INET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NETIF_INET\~ 1}}
\par
{\bkmkstart AAAAAAAARV}
{\bkmkend AAAAAAAARV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 16 of file netif.h.}\par
}
{\xe \v NETIF_INET6\:netif.h}
{\xe \v netif.h\:NETIF_INET6}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NETIF_INET6\~ 2}}
\par
{\bkmkstart AAAAAAAARW}
{\bkmkend AAAAAAAARW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 17 of file netif.h.}\par
}
{\xe \v NETIF_RAW\:netif.h}
{\xe \v netif.h\:NETIF_RAW}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NETIF_RAW\~ 0}}
\par
{\bkmkstart AAAAAAAARX}
{\bkmkend AAAAAAAARX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 15 of file netif.h.}\par
}
{\xe \v NETIF_TCP\:netif.h}
{\xe \v netif.h\:NETIF_TCP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NETIF_TCP\~ 6}}
\par
{\bkmkstart AAAAAAAARY}
{\bkmkend AAAAAAAARY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 21 of file netif.h.}\par
}
{\xe \v NETIF_TELNET\:netif.h}
{\xe \v netif.h\:NETIF_TELNET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NETIF_TELNET\~ 8}}
\par
{\bkmkstart AAAAAAAARZ}
{\bkmkend AAAAAAAARZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 23 of file netif.h.}\par
}
{\xe \v NETIF_UDP\:netif.h}
{\xe \v netif.h\:NETIF_UDP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NETIF_UDP\~ 5}}
\par
{\bkmkstart AAAAAAAASA}
{\bkmkend AAAAAAAASA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 20 of file netif.h.}\par
}
{\xe \v RTL8139_DEBUG\:netif.h}
{\xe \v netif.h\:RTL8139_DEBUG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define RTL8139_DEBUG}}
\par
{\bkmkstart AAAAAAAASB}
{\bkmkend AAAAAAAASB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 30 of file netif.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v ipv4_t\:netif.h}
{\xe \v netif.h\:ipv4_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b uint8_t} ipv4_t[4]}}
\par
{\bkmkstart AAAAAAAASC}
{\bkmkend AAAAAAAASC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 10 of file netif.h.}\par
}
{\xe \v ipv6_t\:netif.h}
{\xe \v netif.h\:ipv6_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b uint16_t} ipv6_t[8]}}
\par
{\bkmkstart AAAAAAAASD}
{\bkmkend AAAAAAAASD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 11 of file netif.h.}\par
}
{\xe \v macaddr_t\:netif.h}
{\xe \v netif.h\:macaddr_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b uint8_t} macaddr_t[6]}}
\par
{\bkmkstart AAAAAAAASE}
{\bkmkend AAAAAAAASE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 12 of file netif.h.}\par
}
{\xe \v netif_packet_t\:netif.h}
{\xe \v netif.h\:netif_packet_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b netif_packet}  {\b netif_packet_t}}}
\par
{\bkmkstart AAAAAAAASF}
{\bkmkend AAAAAAAASF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v netif_socket_t\:netif.h}
{\xe \v netif.h\:netif_socket_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b netif_socket}  {\b netif_socket_t}}}
\par
{\bkmkstart AAAAAAAASG}
{\bkmkend AAAAAAAASG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v netif_t\:netif.h}
{\xe \v netif.h\:netif_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b netif}  {\b netif_t}}}
\par
{\bkmkstart AAAAAAAASH}
{\bkmkend AAAAAAAASH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/include/aplus/pci.h File Reference\par \pard\plain 
{\tc\tcl2 \v src/include/aplus/pci.h}
{\xe \v src/include/aplus/pci.h}
{\bkmkstart AAAAAAAASI}
{\bkmkend AAAAAAAASI}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <aplus.h>}\par
{\f2 #include <stdint.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b pci_device}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PCI_CLASS_OLD}\~ 0x00\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PCI_CLASS_STORAGE}\~ 0x01\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PCI_CLASS_NETWORK}\~ 0x02\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PCI_CLASS_DISPLAY}\~ 0x03\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PCI_CLASS_MULTIMEDIA}\~ 0x04\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PCI_CLASS_MEMORY}\~ 0x05\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PCI_CLASS_BRIDGE}\~ 0x06\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PCI_CLASS_SIMCOM}\~ 0x07\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PCI_CLASS_SYSPERIPHERAL}\~ 0x08\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PCI_CLASS_INPUT}\~ 0x09\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PCI_CLASS_DOCK}\~ 0x0A\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PCI_CLASS_PROCESSOR}\~ 0x0B\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PCI_CLASS_SERIAL}\~ 0x0C\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PCI_CLASS_MISC}\~ 0xFF\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b pci_device} {\b pci_device_t}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v PCI_CLASS_BRIDGE\:pci.h}
{\xe \v pci.h\:PCI_CLASS_BRIDGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PCI_CLASS_BRIDGE\~ 0x06}}
\par
{\bkmkstart AAAAAAAASJ}
{\bkmkend AAAAAAAASJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 14 of file pci.h.}\par
}
{\xe \v PCI_CLASS_DISPLAY\:pci.h}
{\xe \v pci.h\:PCI_CLASS_DISPLAY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PCI_CLASS_DISPLAY\~ 0x03}}
\par
{\bkmkstart AAAAAAAASK}
{\bkmkend AAAAAAAASK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 11 of file pci.h.}\par
}
{\xe \v PCI_CLASS_DOCK\:pci.h}
{\xe \v pci.h\:PCI_CLASS_DOCK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PCI_CLASS_DOCK\~ 0x0A}}
\par
{\bkmkstart AAAAAAAASL}
{\bkmkend AAAAAAAASL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 18 of file pci.h.}\par
}
{\xe \v PCI_CLASS_INPUT\:pci.h}
{\xe \v pci.h\:PCI_CLASS_INPUT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PCI_CLASS_INPUT\~ 0x09}}
\par
{\bkmkstart AAAAAAAASM}
{\bkmkend AAAAAAAASM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 17 of file pci.h.}\par
}
{\xe \v PCI_CLASS_MEMORY\:pci.h}
{\xe \v pci.h\:PCI_CLASS_MEMORY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PCI_CLASS_MEMORY\~ 0x05}}
\par
{\bkmkstart AAAAAAAASN}
{\bkmkend AAAAAAAASN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 13 of file pci.h.}\par
}
{\xe \v PCI_CLASS_MISC\:pci.h}
{\xe \v pci.h\:PCI_CLASS_MISC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PCI_CLASS_MISC\~ 0xFF}}
\par
{\bkmkstart AAAAAAAASO}
{\bkmkend AAAAAAAASO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 21 of file pci.h.}\par
}
{\xe \v PCI_CLASS_MULTIMEDIA\:pci.h}
{\xe \v pci.h\:PCI_CLASS_MULTIMEDIA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PCI_CLASS_MULTIMEDIA\~ 0x04}}
\par
{\bkmkstart AAAAAAAASP}
{\bkmkend AAAAAAAASP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 12 of file pci.h.}\par
}
{\xe \v PCI_CLASS_NETWORK\:pci.h}
{\xe \v pci.h\:PCI_CLASS_NETWORK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PCI_CLASS_NETWORK\~ 0x02}}
\par
{\bkmkstart AAAAAAAASQ}
{\bkmkend AAAAAAAASQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 10 of file pci.h.}\par
}
{\xe \v PCI_CLASS_OLD\:pci.h}
{\xe \v pci.h\:PCI_CLASS_OLD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PCI_CLASS_OLD\~ 0x00}}
\par
{\bkmkstart AAAAAAAASR}
{\bkmkend AAAAAAAASR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 8 of file pci.h.}\par
}
{\xe \v PCI_CLASS_PROCESSOR\:pci.h}
{\xe \v pci.h\:PCI_CLASS_PROCESSOR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PCI_CLASS_PROCESSOR\~ 0x0B}}
\par
{\bkmkstart AAAAAAAASS}
{\bkmkend AAAAAAAASS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 19 of file pci.h.}\par
}
{\xe \v PCI_CLASS_SERIAL\:pci.h}
{\xe \v pci.h\:PCI_CLASS_SERIAL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PCI_CLASS_SERIAL\~ 0x0C}}
\par
{\bkmkstart AAAAAAAAST}
{\bkmkend AAAAAAAAST}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 20 of file pci.h.}\par
}
{\xe \v PCI_CLASS_SIMCOM\:pci.h}
{\xe \v pci.h\:PCI_CLASS_SIMCOM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PCI_CLASS_SIMCOM\~ 0x07}}
\par
{\bkmkstart AAAAAAAASU}
{\bkmkend AAAAAAAASU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 15 of file pci.h.}\par
}
{\xe \v PCI_CLASS_STORAGE\:pci.h}
{\xe \v pci.h\:PCI_CLASS_STORAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PCI_CLASS_STORAGE\~ 0x01}}
\par
{\bkmkstart AAAAAAAASV}
{\bkmkend AAAAAAAASV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9 of file pci.h.}\par
}
{\xe \v PCI_CLASS_SYSPERIPHERAL\:pci.h}
{\xe \v pci.h\:PCI_CLASS_SYSPERIPHERAL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PCI_CLASS_SYSPERIPHERAL\~ 0x08}}
\par
{\bkmkstart AAAAAAAASW}
{\bkmkend AAAAAAAASW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 16 of file pci.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v pci_device_t\:pci.h}
{\xe \v pci.h\:pci_device_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b pci_device}  {\b pci_device_t}}}
\par
{\bkmkstart AAAAAAAASX}
{\bkmkend AAAAAAAASX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/include/aplus/spinlock.h File Reference\par \pard\plain 
{\tc\tcl2 \v src/include/aplus/spinlock.h}
{\xe \v src/include/aplus/spinlock.h}
{\bkmkstart AAAAAAAASY}
{\bkmkend AAAAAAAASY}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SPINLOCK_FLAGS_LOCKED}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SPINLOCK_FLAGS_FASTLOCK}\~ 2\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b lock}()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b unlock}()\~ {\b spinlock_unlock}(&__func__##_lock)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b spinlock_waiton}(cond)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b fastlock_waiton}(cond)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b spinlock_init}(spin, {\b flags})\~ *(spin) = {\b flags}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef volatile int {\b spinlock_t}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b spinlock_lock} ({\b spinlock_t} *spin)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Acquire a spinlock. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b spinlock_unlock} ({\b spinlock_t} *spin)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Unlock a spinlock. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b spinlock_trylock} ({\b spinlock_t} *spin)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Try to acquire a spinlock. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b __spinlock_waiton} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Yield current task if a false condition was given by {\b spinlock_waiton()}. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b __fastlock_waiton} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Put CPU in pause for a while if a false condition was given by {\b fastlock_waiton()}. }{
}\par
}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v fastlock_waiton\:spinlock.h}
{\xe \v spinlock.h\:fastlock_waiton}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define fastlock_waiton( cond)}}
\par
{\bkmkstart AAAAAAAASZ}
{\bkmkend AAAAAAAASZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid while(cond)                                     \\\par
        __fastlock_waiton()\par
}
{
Definition at line 51 of file spinlock.h.}\par
}
{\xe \v lock\:spinlock.h}
{\xe \v spinlock.h\:lock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define lock()}}
\par
{\bkmkstart AAAAAAAATA}
{\bkmkend AAAAAAAATA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid static spinlock_t __func__##_lock = 0;          \\\par
    spinlock_lock(&__func__##_lock)\par
}
{
Definition at line 38 of file spinlock.h.}\par
}
{\xe \v SPINLOCK_FLAGS_FASTLOCK\:spinlock.h}
{\xe \v spinlock.h\:SPINLOCK_FLAGS_FASTLOCK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SPINLOCK_FLAGS_FASTLOCK\~ 2}}
\par
{\bkmkstart AAAAAAAATB}
{\bkmkend AAAAAAAATB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 27 of file spinlock.h.}\par
}
{\xe \v SPINLOCK_FLAGS_LOCKED\:spinlock.h}
{\xe \v spinlock.h\:SPINLOCK_FLAGS_LOCKED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SPINLOCK_FLAGS_LOCKED\~ 1}}
\par
{\bkmkstart AAAAAAAATC}
{\bkmkend AAAAAAAATC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 26 of file spinlock.h.}\par
}
{\xe \v spinlock_init\:spinlock.h}
{\xe \v spinlock.h\:spinlock_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define spinlock_init( spin,  {\b flags})\~ *(spin) = {\b flags}}}
\par
{\bkmkstart AAAAAAAATD}
{\bkmkend AAAAAAAATD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 56 of file spinlock.h.}\par
}
{\xe \v spinlock_waiton\:spinlock.h}
{\xe \v spinlock.h\:spinlock_waiton}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define spinlock_waiton( cond)}}
\par
{\bkmkstart AAAAAAAATE}
{\bkmkend AAAAAAAATE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid while(cond)                                     \\\par
        __spinlock_waiton()\par
}
{
Definition at line 47 of file spinlock.h.}\par
}
{\xe \v unlock\:spinlock.h}
{\xe \v spinlock.h\:unlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define unlock()\~ {\b spinlock_unlock}(&__func__##_lock)}}
\par
{\bkmkstart AAAAAAAATF}
{\bkmkend AAAAAAAATF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 42 of file spinlock.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v spinlock_t\:spinlock.h}
{\xe \v spinlock.h\:spinlock_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef volatile int {\b spinlock_t}}}
\par
{\bkmkstart AAAAAAAATG}
{\bkmkend AAAAAAAATG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 29 of file spinlock.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v __fastlock_waiton\:spinlock.h}
{\xe \v spinlock.h\:__fastlock_waiton}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void __fastlock_waiton ()}}
\par
{\bkmkstart AAAAAAAATH}
{\bkmkend AAAAAAAATH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Put CPU in pause for a while if a false condition was given by {\b fastlock_waiton()}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b fastlock_waiton} \par
}}{
Definition at line 76 of file spinlock.c.}\par
{
References __asm__().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 76                          \{\par
77     __asm__ __volatile__("pause");\par
78 \}\par
}
}
{\xe \v __spinlock_waiton\:spinlock.h}
{\xe \v spinlock.h\:__spinlock_waiton}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void __spinlock_waiton ()}}
\par
{\bkmkstart AAAAAAAATI}
{\bkmkend AAAAAAAATI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Yield current task if a false condition was given by {\b spinlock_waiton()}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b spinlock_waiton} \par
}}{
Definition at line 68 of file spinlock.c.}\par
{
References schedule_yield().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 68                          \{\par
69     schedule_yield();\par
70 \}\par
}
}
{\xe \v spinlock_lock\:spinlock.h}
{\xe \v spinlock.h\:spinlock_lock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void spinlock_lock ({\b spinlock_t} * {\i spin})}}
\par
{\bkmkstart AAAAAAAATJ}
{\bkmkend AAAAAAAATJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Acquire a spinlock. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i spin} \cell }{Spinlock address. \cell }
{\row }
}
}{
Definition at line 31 of file spinlock.c.}\par
{
References fastlock_waiton, SPINLOCK_FLAGS_FASTLOCK, SPINLOCK_FLAGS_LOCKED, and spinlock_waiton.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 31                                      \{\par
32     if((*spin & SPINLOCK_FLAGS_FASTLOCK) == 0)\par
33         spinlock_waiton(*spin & SPINLOCK_FLAGS_LOCKED);\par
34     else\par
35         fastlock_waiton(*spin & SPINLOCK_FLAGS_LOCKED);\par
36 \par
37     *spin |= SPINLOCK_FLAGS_LOCKED;\par
38 \}\par
}
}
{\xe \v spinlock_trylock\:spinlock.h}
{\xe \v spinlock.h\:spinlock_trylock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int spinlock_trylock ({\b spinlock_t} * {\i spin})}}
\par
{\bkmkstart AAAAAAAATK}
{\bkmkend AAAAAAAATK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Try to acquire a spinlock. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i spin} \cell }{Spinlock address. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid 0 for success else -1. \par
}}{
Definition at line 55 of file spinlock.c.}\par
{
References SPINLOCK_FLAGS_LOCKED.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 55                                        \{\par
56     if(*spin & SPINLOCK_FLAGS_LOCKED)\par
57         return -1;\par
58         \par
59     *spin |= SPINLOCK_FLAGS_LOCKED;\par
60     return 0;\par
61 \}\par
}
}
{\xe \v spinlock_unlock\:spinlock.h}
{\xe \v spinlock.h\:spinlock_unlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void spinlock_unlock ({\b spinlock_t} * {\i spin})}}
\par
{\bkmkstart AAAAAAAATL}
{\bkmkend AAAAAAAATL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Unlock a spinlock. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i spin} \cell }{Spinlock address. \cell }
{\row }
}
}{
Definition at line 45 of file spinlock.c.}\par
{
References SPINLOCK_FLAGS_LOCKED.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 45                                        \{\par
46     *spin &= ~SPINLOCK_FLAGS_LOCKED;\par
47 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/include/aplus/syscall.h File Reference\par \pard\plain 
{\tc\tcl2 \v src/include/aplus/syscall.h}
{\xe \v src/include/aplus/syscall.h}
{\bkmkstart AAAAAAAATM}
{\bkmkend AAAAAAAATM}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <aplus.h>}\par
{\f2 #include <aplus/attribute.h>}\par
{\f2 #include <stdint.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b __syscall}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSCALL}(h, n)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b __syscall} {\b syscall_t}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v SYSCALL\:syscall.h}
{\xe \v syscall.h\:SYSCALL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSCALL( h,  n)}}
\par
{\bkmkstart AAAAAAAATN}
{\bkmkend AAAAAAAATN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid static syscall_t syscall_##n = \{                                        \\\par
        (void*) h, (int) n                                                  \\\par
    \};                                                                      \\\par
    ATTRIBUTE("syscall", syscall_##n)\par
}
{
Definition at line 15 of file syscall.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v syscall_t\:syscall.h}
{\xe \v syscall.h\:syscall_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b __syscall}  {\b syscall_t}}}
\par
{\bkmkstart AAAAAAAATO}
{\bkmkend AAAAAAAATO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/include/aplus/task.h File Reference\par \pard\plain 
{\tc\tcl2 \v src/include/aplus/task.h}
{\xe \v src/include/aplus/task.h}
{\bkmkstart AAAAAAAATP}
{\bkmkend AAAAAAAATP}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
{\f2 #include <aplus.h>}\par
{\f2 #include <aplus/fs.h>}\par
{\f2 #include <signal.h>}\par
{\f2 #include <sys/types.h>}\par
{\f2 #include <setjmp.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b task_env}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b task}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TASK_MAX_FD}\~ 512\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TASK_STACKSIZE}\~ 0x1000\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TASK_STACKADDR}\~ 0xF0000000\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TASK_STATE_ALIVE}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TASK_STATE_ZOMBIE}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TASK_STATE_DEAD}\~ 2\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TASK_PRIORITY_MIN}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TASK_PRIORITY_LOW}\~ 5\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TASK_PRIORITY_REGULAR}\~ 15\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TASK_PRIORITY_HIGH}\~ 30\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TASK_PRIORITY_MAX}\~ 50\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UID_SUPERUSER}\~ 1000\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GID_SUPERUSER}\~ 1000\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b task} {\b task_t}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b task_env} {\b __attribute__} ((packed)) task_env_t\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b edi}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b esi}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b ebx}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b ecx}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b eax}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b edx}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b eflags}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b ebp}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b eip}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v GID_SUPERUSER\:task.h}
{\xe \v task.h\:GID_SUPERUSER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GID_SUPERUSER\~ 1000}}
\par
{\bkmkstart AAAAAAAATQ}
{\bkmkend AAAAAAAATQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 52 of file task.h.}\par
}
{\xe \v TASK_MAX_FD\:task.h}
{\xe \v task.h\:TASK_MAX_FD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TASK_MAX_FD\~ 512}}
\par
{\bkmkstart AAAAAAAATR}
{\bkmkend AAAAAAAATR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 35 of file task.h.}\par
}
{\xe \v TASK_PRIORITY_HIGH\:task.h}
{\xe \v task.h\:TASK_PRIORITY_HIGH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TASK_PRIORITY_HIGH\~ 30}}
\par
{\bkmkstart AAAAAAAATS}
{\bkmkend AAAAAAAATS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 47 of file task.h.}\par
}
{\xe \v TASK_PRIORITY_LOW\:task.h}
{\xe \v task.h\:TASK_PRIORITY_LOW}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TASK_PRIORITY_LOW\~ 5}}
\par
{\bkmkstart AAAAAAAATT}
{\bkmkend AAAAAAAATT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 45 of file task.h.}\par
}
{\xe \v TASK_PRIORITY_MAX\:task.h}
{\xe \v task.h\:TASK_PRIORITY_MAX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TASK_PRIORITY_MAX\~ 50}}
\par
{\bkmkstart AAAAAAAATU}
{\bkmkend AAAAAAAATU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 48 of file task.h.}\par
}
{\xe \v TASK_PRIORITY_MIN\:task.h}
{\xe \v task.h\:TASK_PRIORITY_MIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TASK_PRIORITY_MIN\~ 1}}
\par
{\bkmkstart AAAAAAAATV}
{\bkmkend AAAAAAAATV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 44 of file task.h.}\par
}
{\xe \v TASK_PRIORITY_REGULAR\:task.h}
{\xe \v task.h\:TASK_PRIORITY_REGULAR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TASK_PRIORITY_REGULAR\~ 15}}
\par
{\bkmkstart AAAAAAAATW}
{\bkmkend AAAAAAAATW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 46 of file task.h.}\par
}
{\xe \v TASK_STACKADDR\:task.h}
{\xe \v task.h\:TASK_STACKADDR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TASK_STACKADDR\~ 0xF0000000}}
\par
{\bkmkstart AAAAAAAATX}
{\bkmkend AAAAAAAATX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 38 of file task.h.}\par
}
{\xe \v TASK_STACKSIZE\:task.h}
{\xe \v task.h\:TASK_STACKSIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TASK_STACKSIZE\~ 0x1000}}
\par
{\bkmkstart AAAAAAAATY}
{\bkmkend AAAAAAAATY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 37 of file task.h.}\par
}
{\xe \v TASK_STATE_ALIVE\:task.h}
{\xe \v task.h\:TASK_STATE_ALIVE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TASK_STATE_ALIVE\~ 0}}
\par
{\bkmkstart AAAAAAAATZ}
{\bkmkend AAAAAAAATZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 40 of file task.h.}\par
}
{\xe \v TASK_STATE_DEAD\:task.h}
{\xe \v task.h\:TASK_STATE_DEAD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TASK_STATE_DEAD\~ 2}}
\par
{\bkmkstart AAAAAAAAUA}
{\bkmkend AAAAAAAAUA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 42 of file task.h.}\par
}
{\xe \v TASK_STATE_ZOMBIE\:task.h}
{\xe \v task.h\:TASK_STATE_ZOMBIE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TASK_STATE_ZOMBIE\~ 1}}
\par
{\bkmkstart AAAAAAAAUB}
{\bkmkend AAAAAAAAUB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 41 of file task.h.}\par
}
{\xe \v UID_SUPERUSER\:task.h}
{\xe \v task.h\:UID_SUPERUSER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UID_SUPERUSER\~ 1000}}
\par
{\bkmkstart AAAAAAAAUC}
{\bkmkend AAAAAAAAUC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 51 of file task.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v task_t\:task.h}
{\xe \v task.h\:task_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b task}  {\b task_t}}}
\par
{\bkmkstart AAAAAAAAUD}
{\bkmkend AAAAAAAAUD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v __attribute__\:task.h}
{\xe \v task.h\:__attribute__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b task_env} __attribute__ ((packed) )}}
\par
{\bkmkstart AAAAAAAAUE}
{\bkmkend AAAAAAAAUE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 44 of file desc.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 46                        \{\par
47     uint16_t limit;\par
48     uint32_t base;\par
49 \} __attribute__((packed)) gdt_ptr_t;\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v eax\:task.h}
{\xe \v task.h\:eax}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} eax}}
\par
{\bkmkstart AAAAAAAAUF}
{\bkmkend AAAAAAAAUF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 16 of file task.h.}\par
}
{\xe \v ebp\:task.h}
{\xe \v task.h\:ebp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} ebp}}
\par
{\bkmkstart AAAAAAAAUG}
{\bkmkend AAAAAAAAUG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 19 of file task.h.}\par
}
{\xe \v ebx\:task.h}
{\xe \v task.h\:ebx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} ebx}}
\par
{\bkmkstart AAAAAAAAUH}
{\bkmkend AAAAAAAAUH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 14 of file task.h.}\par
}
{\xe \v ecx\:task.h}
{\xe \v task.h\:ecx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} ecx}}
\par
{\bkmkstart AAAAAAAAUI}
{\bkmkend AAAAAAAAUI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 15 of file task.h.}\par
}
{\xe \v edi\:task.h}
{\xe \v task.h\:edi}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} edi}}
\par
{\bkmkstart AAAAAAAAUJ}
{\bkmkend AAAAAAAAUJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 12 of file task.h.}\par
}
{\xe \v edx\:task.h}
{\xe \v task.h\:edx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} edx}}
\par
{\bkmkstart AAAAAAAAUK}
{\bkmkend AAAAAAAAUK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 17 of file task.h.}\par
}
{\xe \v eflags\:task.h}
{\xe \v task.h\:eflags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} eflags}}
\par
{\bkmkstart AAAAAAAAUL}
{\bkmkend AAAAAAAAUL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 18 of file task.h.}\par
}
{\xe \v eip\:task.h}
{\xe \v task.h\:eip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} eip}}
\par
{\bkmkstart AAAAAAAAUM}
{\bkmkend AAAAAAAAUM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 20 of file task.h.}\par
}
{\xe \v esi\:task.h}
{\xe \v task.h\:esi}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} esi}}
\par
{\bkmkstart AAAAAAAAUN}
{\bkmkend AAAAAAAAUN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 13 of file task.h.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/include/grub.h File Reference\par \pard\plain 
{\tc\tcl2 \v src/include/grub.h}
{\xe \v src/include/grub.h}
{\bkmkstart AAAAAAAAUO}
{\bkmkend AAAAAAAAUO}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b vesaInfo_t}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b vesaModeInfo_t}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b BootInfo_t}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MULTIBOOT_FLAG_MEM}\~ 0x001\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MULTIBOOT_FLAG_DEVICE}\~ 0x002\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MULTIBOOT_FLAG_CMDLINE}\~ 0x004\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MULTIBOOT_FLAG_MODS}\~ 0x008\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MULTIBOOT_FLAG_AOUT}\~ 0x010\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MULTIBOOT_FLAG_ELF}\~ 0x020\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MULTIBOOT_FLAG_MMAP}\~ 0x040\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MULTIBOOT_FLAG_CONFIG}\~ 0x080\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MULTIBOOT_FLAG_LOADER}\~ 0x100\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MULTIBOOT_FLAG_APM}\~ 0x200\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MULTIBOOT_FLAG_VBE}\~ 0x400\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b vesaInfo_t} {\b vesaInfo}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b BootInfo_t} {\b BootInfo}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b vesaModeInfo_t} {\b __attribute__} ((packed)) vesaModeInfo\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b attributes}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b winA}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b winB}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b granularity}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b winsize}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b segmentA}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b segmentB}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b realFctPtr}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b pitch}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b Xres}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b Yres}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b Wchar}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b Ychar}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b planes}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b bpp}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b banks}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b memory_model}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b bank_size}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b image_pages}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b reserved0}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b red_mask}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b red_position}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b green_mask}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b green_position}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b blue_mask}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b blue_position}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b rsv_mask}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b rsv_position}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b directcolor_attributes}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b physbase}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b reserved1}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
short {\b reserved2}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b BootInfo} * {\b mbd}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b magic}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v MULTIBOOT_FLAG_AOUT\:grub.h}
{\xe \v grub.h\:MULTIBOOT_FLAG_AOUT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MULTIBOOT_FLAG_AOUT\~ 0x010}}
\par
{\bkmkstart AAAAAAAAUP}
{\bkmkend AAAAAAAAUP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 99 of file grub.h.}\par
}
{\xe \v MULTIBOOT_FLAG_APM\:grub.h}
{\xe \v grub.h\:MULTIBOOT_FLAG_APM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MULTIBOOT_FLAG_APM\~ 0x200}}
\par
{\bkmkstart AAAAAAAAUQ}
{\bkmkend AAAAAAAAUQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 104 of file grub.h.}\par
}
{\xe \v MULTIBOOT_FLAG_CMDLINE\:grub.h}
{\xe \v grub.h\:MULTIBOOT_FLAG_CMDLINE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MULTIBOOT_FLAG_CMDLINE\~ 0x004}}
\par
{\bkmkstart AAAAAAAAUR}
{\bkmkend AAAAAAAAUR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 97 of file grub.h.}\par
}
{\xe \v MULTIBOOT_FLAG_CONFIG\:grub.h}
{\xe \v grub.h\:MULTIBOOT_FLAG_CONFIG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MULTIBOOT_FLAG_CONFIG\~ 0x080}}
\par
{\bkmkstart AAAAAAAAUS}
{\bkmkend AAAAAAAAUS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 102 of file grub.h.}\par
}
{\xe \v MULTIBOOT_FLAG_DEVICE\:grub.h}
{\xe \v grub.h\:MULTIBOOT_FLAG_DEVICE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MULTIBOOT_FLAG_DEVICE\~ 0x002}}
\par
{\bkmkstart AAAAAAAAUT}
{\bkmkend AAAAAAAAUT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 96 of file grub.h.}\par
}
{\xe \v MULTIBOOT_FLAG_ELF\:grub.h}
{\xe \v grub.h\:MULTIBOOT_FLAG_ELF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MULTIBOOT_FLAG_ELF\~ 0x020}}
\par
{\bkmkstart AAAAAAAAUU}
{\bkmkend AAAAAAAAUU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 100 of file grub.h.}\par
}
{\xe \v MULTIBOOT_FLAG_LOADER\:grub.h}
{\xe \v grub.h\:MULTIBOOT_FLAG_LOADER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MULTIBOOT_FLAG_LOADER\~ 0x100}}
\par
{\bkmkstart AAAAAAAAUV}
{\bkmkend AAAAAAAAUV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 103 of file grub.h.}\par
}
{\xe \v MULTIBOOT_FLAG_MEM\:grub.h}
{\xe \v grub.h\:MULTIBOOT_FLAG_MEM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MULTIBOOT_FLAG_MEM\~ 0x001}}
\par
{\bkmkstart AAAAAAAAUW}
{\bkmkend AAAAAAAAUW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 95 of file grub.h.}\par
}
{\xe \v MULTIBOOT_FLAG_MMAP\:grub.h}
{\xe \v grub.h\:MULTIBOOT_FLAG_MMAP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MULTIBOOT_FLAG_MMAP\~ 0x040}}
\par
{\bkmkstart AAAAAAAAUX}
{\bkmkend AAAAAAAAUX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 101 of file grub.h.}\par
}
{\xe \v MULTIBOOT_FLAG_MODS\:grub.h}
{\xe \v grub.h\:MULTIBOOT_FLAG_MODS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MULTIBOOT_FLAG_MODS\~ 0x008}}
\par
{\bkmkstart AAAAAAAAUY}
{\bkmkend AAAAAAAAUY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 98 of file grub.h.}\par
}
{\xe \v MULTIBOOT_FLAG_VBE\:grub.h}
{\xe \v grub.h\:MULTIBOOT_FLAG_VBE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MULTIBOOT_FLAG_VBE\~ 0x400}}
\par
{\bkmkstart AAAAAAAAUZ}
{\bkmkend AAAAAAAAUZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 105 of file grub.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v BootInfo\:grub.h}
{\xe \v grub.h\:BootInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b BootInfo_t}  {\b BootInfo}}}
\par
{\bkmkstart AAAAAAAAVA}
{\bkmkend AAAAAAAAVA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vesaInfo\:grub.h}
{\xe \v grub.h\:vesaInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b vesaInfo_t}  {\b vesaInfo}}}
\par
{\bkmkstart AAAAAAAAVB}
{\bkmkend AAAAAAAAVB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v __attribute__\:grub.h}
{\xe \v grub.h\:__attribute__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b vesaModeInfo_t} __attribute__ ((packed) )}}
\par
{\bkmkstart AAAAAAAAVC}
{\bkmkend AAAAAAAAVC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 44 of file desc.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 46                        \{\par
47     uint16_t limit;\par
48     uint32_t base;\par
49 \} __attribute__((packed)) gdt_ptr_t;\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v attributes\:grub.h}
{\xe \v grub.h\:attributes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short attributes}}
\par
{\bkmkstart AAAAAAAAVD}
{\bkmkend AAAAAAAAVD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 140 of file grub.h.}\par
}
{\xe \v bank_size\:grub.h}
{\xe \v grub.h\:bank_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char bank_size}}
\par
{\bkmkstart AAAAAAAAVE}
{\bkmkend AAAAAAAAVE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 150 of file grub.h.}\par
}
{\xe \v banks\:grub.h}
{\xe \v grub.h\:banks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char banks}}
\par
{\bkmkstart AAAAAAAAVF}
{\bkmkend AAAAAAAAVF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 149 of file grub.h.}\par
}
{\xe \v blue_mask\:grub.h}
{\xe \v grub.h\:blue_mask}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char blue_mask}}
\par
{\bkmkstart AAAAAAAAVG}
{\bkmkend AAAAAAAAVG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 155 of file grub.h.}\par
}
{\xe \v blue_position\:grub.h}
{\xe \v grub.h\:blue_position}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char blue_position}}
\par
{\bkmkstart AAAAAAAAVH}
{\bkmkend AAAAAAAAVH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 155 of file grub.h.}\par
}
{\xe \v bpp\:grub.h}
{\xe \v grub.h\:bpp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char bpp}}
\par
{\bkmkstart AAAAAAAAVI}
{\bkmkend AAAAAAAAVI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 149 of file grub.h.}\par
}
{\xe \v directcolor_attributes\:grub.h}
{\xe \v grub.h\:directcolor_attributes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char directcolor_attributes}}
\par
{\bkmkstart AAAAAAAAVJ}
{\bkmkend AAAAAAAAVJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 157 of file grub.h.}\par
}
{\xe \v granularity\:grub.h}
{\xe \v grub.h\:granularity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short granularity}}
\par
{\bkmkstart AAAAAAAAVK}
{\bkmkend AAAAAAAAVK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 142 of file grub.h.}\par
}
{\xe \v green_mask\:grub.h}
{\xe \v grub.h\:green_mask}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char green_mask}}
\par
{\bkmkstart AAAAAAAAVL}
{\bkmkend AAAAAAAAVL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 154 of file grub.h.}\par
}
{\xe \v green_position\:grub.h}
{\xe \v grub.h\:green_position}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char green_position}}
\par
{\bkmkstart AAAAAAAAVM}
{\bkmkend AAAAAAAAVM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 154 of file grub.h.}\par
}
{\xe \v image_pages\:grub.h}
{\xe \v grub.h\:image_pages}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char image_pages}}
\par
{\bkmkstart AAAAAAAAVN}
{\bkmkend AAAAAAAAVN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 150 of file grub.h.}\par
}
{\xe \v magic\:grub.h}
{\xe \v grub.h\:magic}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int magic}}
\par
{\bkmkstart AAAAAAAAVO}
{\bkmkend AAAAAAAAVO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 42 of file mm.c.}\par
}
{\xe \v mbd\:grub.h}
{\xe \v grub.h\:mbd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b BootInfo}* mbd}}
\par
{\bkmkstart AAAAAAAAVP}
{\bkmkend AAAAAAAAVP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v memory_model\:grub.h}
{\xe \v grub.h\:memory_model}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char memory_model}}
\par
{\bkmkstart AAAAAAAAVQ}
{\bkmkend AAAAAAAAVQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 150 of file grub.h.}\par
}
{\xe \v physbase\:grub.h}
{\xe \v grub.h\:physbase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int physbase}}
\par
{\bkmkstart AAAAAAAAVR}
{\bkmkend AAAAAAAAVR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 159 of file grub.h.}\par
}
{\xe \v pitch\:grub.h}
{\xe \v grub.h\:pitch}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short pitch}}
\par
{\bkmkstart AAAAAAAAVS}
{\bkmkend AAAAAAAAVS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 146 of file grub.h.}\par
}
{\xe \v planes\:grub.h}
{\xe \v grub.h\:planes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char planes}}
\par
{\bkmkstart AAAAAAAAVT}
{\bkmkend AAAAAAAAVT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 149 of file grub.h.}\par
}
{\xe \v realFctPtr\:grub.h}
{\xe \v grub.h\:realFctPtr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int realFctPtr}}
\par
{\bkmkstart AAAAAAAAVU}
{\bkmkend AAAAAAAAVU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 145 of file grub.h.}\par
}
{\xe \v red_mask\:grub.h}
{\xe \v grub.h\:red_mask}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char red_mask}}
\par
{\bkmkstart AAAAAAAAVV}
{\bkmkend AAAAAAAAVV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 153 of file grub.h.}\par
}
{\xe \v red_position\:grub.h}
{\xe \v grub.h\:red_position}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char red_position}}
\par
{\bkmkstart AAAAAAAAVW}
{\bkmkend AAAAAAAAVW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 153 of file grub.h.}\par
}
{\xe \v reserved0\:grub.h}
{\xe \v grub.h\:reserved0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char reserved0}}
\par
{\bkmkstart AAAAAAAAVX}
{\bkmkend AAAAAAAAVX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 151 of file grub.h.}\par
}
{\xe \v reserved1\:grub.h}
{\xe \v grub.h\:reserved1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int reserved1}}
\par
{\bkmkstart AAAAAAAAVY}
{\bkmkend AAAAAAAAVY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 160 of file grub.h.}\par
}
{\xe \v reserved2\:grub.h}
{\xe \v grub.h\:reserved2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
short reserved2}}
\par
{\bkmkstart AAAAAAAAVZ}
{\bkmkend AAAAAAAAVZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 161 of file grub.h.}\par
}
{\xe \v rsv_mask\:grub.h}
{\xe \v grub.h\:rsv_mask}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char rsv_mask}}
\par
{\bkmkstart AAAAAAAAWA}
{\bkmkend AAAAAAAAWA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 156 of file grub.h.}\par
}
{\xe \v rsv_position\:grub.h}
{\xe \v grub.h\:rsv_position}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char rsv_position}}
\par
{\bkmkstart AAAAAAAAWB}
{\bkmkend AAAAAAAAWB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 156 of file grub.h.}\par
}
{\xe \v segmentA\:grub.h}
{\xe \v grub.h\:segmentA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short segmentA}}
\par
{\bkmkstart AAAAAAAAWC}
{\bkmkend AAAAAAAAWC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 144 of file grub.h.}\par
}
{\xe \v segmentB\:grub.h}
{\xe \v grub.h\:segmentB}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short segmentB}}
\par
{\bkmkstart AAAAAAAAWD}
{\bkmkend AAAAAAAAWD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 144 of file grub.h.}\par
}
{\xe \v Wchar\:grub.h}
{\xe \v grub.h\:Wchar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char Wchar}}
\par
{\bkmkstart AAAAAAAAWE}
{\bkmkend AAAAAAAAWE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 149 of file grub.h.}\par
}
{\xe \v winA\:grub.h}
{\xe \v grub.h\:winA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char winA}}
\par
{\bkmkstart AAAAAAAAWF}
{\bkmkend AAAAAAAAWF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 141 of file grub.h.}\par
}
{\xe \v winB\:grub.h}
{\xe \v grub.h\:winB}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char winB}}
\par
{\bkmkstart AAAAAAAAWG}
{\bkmkend AAAAAAAAWG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 141 of file grub.h.}\par
}
{\xe \v winsize\:grub.h}
{\xe \v grub.h\:winsize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short winsize}}
\par
{\bkmkstart AAAAAAAAWH}
{\bkmkend AAAAAAAAWH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 143 of file grub.h.}\par
}
{\xe \v Xres\:grub.h}
{\xe \v grub.h\:Xres}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short Xres}}
\par
{\bkmkstart AAAAAAAAWI}
{\bkmkend AAAAAAAAWI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 148 of file grub.h.}\par
}
{\xe \v Ychar\:grub.h}
{\xe \v grub.h\:Ychar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char Ychar}}
\par
{\bkmkstart AAAAAAAAWJ}
{\bkmkend AAAAAAAAWJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 149 of file grub.h.}\par
}
{\xe \v Yres\:grub.h}
{\xe \v grub.h\:Yres}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short Yres}}
\par
{\bkmkstart AAAAAAAAWK}
{\bkmkend AAAAAAAAWK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 148 of file grub.h.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/main.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/main.c}
{\xe \v src/main.c}
{\bkmkstart AAAAAAAAWL}
{\bkmkend AAAAAAAAWL}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <aplus.h>}\par
{\f2 #include <aplus/fs.h>}\par
{\f2 #include <aplus/list.h>}\par
{\f2 #include <grub.h>}\par
{\f2 #include <aplus/task.h>}\par
{\f2 #include <aplus/attribute.h>}\par
{\f2 #include <aplus/mm.h>}\par
{\f2 #include <stddef.h>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <fcntl.h>}\par
{\f2 #include <sys/times.h>}\par
{\f2 #include <time.h>}\par
{\f2 #include <aplus/netif.h>}\par
{\f2 #include <aplus/net/eth.h>}\par
{\f2 #include <aplus/net/ipv4.h>}\par
{\f2 #include <aplus/net/ipv6.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b sysidle} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Put Kernel Task in optimized loop for powersave. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Entry point for kernel. }{
}\par
}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b inode_t} * {\b vfs_root}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b task_t} * {\b current_task}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current task address. }{
}\par
}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v main\:src/main.c}
{\xe \v src/main.c\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main ()}}
\par
{\bkmkstart AAAAAAAAWM}
{\bkmkend AAAAAAAAWM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Entry point for kernel. }}\par
{
Definition at line 62 of file main.c.}\par
{
References bufio_init(), desc_init(), devfs_mount(), kprintf(), mbd, mkramdev(), mm_init(), BootInfo_t::mods_addr, BootInfo_t::mods_count, netif_init(), panic(), pci_init(), schedule_init(), serial_init(), sys_mount(), syscall_init(), sysidle(), uint32_t, vfs_init(), and vfs_map().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 62            \{\par
63     serial_init();\par
64     mm_init();\par
65     desc_init();\par
66     syscall_init();\par
67     vfs_init();\par
68     schedule_init();\par
69     bufio_init();\par
70     pci_init();\par
71     netif_init();\par
72     \par
73     vfs_map(devfs_mount());\par
74 \par
75 \par
76     if(mbd->mods_count == 0)\par
77         panic("no initrd module found");\par
78     \par
79 \par
80     uint32_t addr = ((uint32_t*) mbd->mods_addr) [0];\par
81     uint32_t endp = ((uint32_t*) mbd->mods_addr) [1];\par
82 \par
83     kprintf("initrd: module found at addess: 0x%x (%d KB)\\n", addr, (endp - addr) / 1024);\par
84 \par
85 \par
86     if(!mkramdev("/dev/ram0", addr, endp - addr))\par
87         panic("initrd: cannot create /dev/ram0");\par
88 \par
89 \par
90     if(sys_mount("/dev/ram0", "/dev/ramdisk", "iso9660", 0, 0) != 0)\par
91         panic("initrd: cannot mount ramdisk");\par
92 \par
93 \par
94 /*\par
95     if(fork() == 0)\par
96         execl("/bin/init", "/bin/init", 0);\par
97     else\par
98 */\par
99     sysidle();\par
100 \}\par
}
}
{\xe \v sysidle\:src/main.c}
{\xe \v src/main.c\:sysidle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void sysidle (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAWN}
{\bkmkend AAAAAAAAWN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Put Kernel Task in optimized loop for powersave. }}\par
{
Definition at line 50 of file main.c.}\par
{
References __asm__(), schedule_setpriority(), and TASK_PRIORITY_LOW.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 50                       \{\par
51     schedule_setpriority(TASK_PRIORITY_LOW);\par
52 \par
53 \par
54     for(;;)\par
55         __asm__ ("pause");\par
56 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v current_task\:src/main.c}
{\xe \v src/main.c\:current_task}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b task_t}* current_task}}
\par
{\bkmkstart AAAAAAAAWO}
{\bkmkend AAAAAAAAWO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current task address. }}\par
{
Definition at line 35 of file sched.c.}\par
}
{\xe \v vfs_root\:src/main.c}
{\xe \v src/main.c\:vfs_root}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b inode_t}* vfs_root}}
\par
{\bkmkstart AAAAAAAAWP}
{\bkmkend AAAAAAAAWP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 19 of file vfs.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
usr/src/libcrt0/test/main.c File Reference\par \pard\plain 
{\tc\tcl2 \v usr/src/libcrt0/test/main.c}
{\xe \v usr/src/libcrt0/test/main.c}
{\bkmkstart AAAAAAAAWQ}
{\bkmkend AAAAAAAAWQ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include <signal.h>}\par
{\f2 #include <assert.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b __test_signals__} (int sig)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b test_stdio} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b test_args} (int argc, char **argv)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b test_signals} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} (int argc, char **argv)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v __test_signals__\:usr/src/libcrt0/test/main.c}
{\xe \v usr/src/libcrt0/test/main.c\:__test_signals__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int __test_signals__ (int {\i sig}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAWR}
{\bkmkend AAAAAAAAWR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 6 of file main.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6                                      \{\par
7     printf("received signal %d\\n", sig);\par
8 \par
9     return 0;\par
10 \}\par
}
}
{\xe \v main\:usr/src/libcrt0/test/main.c}
{\xe \v usr/src/libcrt0/test/main.c\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main (int {\i argc}, char ** {\i argv})}}
\par
{\bkmkstart AAAAAAAAWS}
{\bkmkend AAAAAAAAWS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 34 of file main.c.}\par
{
References test_args(), test_signals(), and test_stdio().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 34                                 \{\par
35     \par
36     assert(test_stdio() && "Test stdio failed");\par
37     assert(test_args(argc, argv) && "Test arguments failed");\par
38     assert(test_signals() >= 0 && "Test signals failed");\par
39     \par
40     printf("Test OK\\n");\par
41     return 0;\par
42 \}\par
}
}
{\xe \v test_args\:usr/src/libcrt0/test/main.c}
{\xe \v usr/src/libcrt0/test/main.c\:test_args}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int test_args (int {\i argc}, char ** {\i argv}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAWT}
{\bkmkend AAAAAAAAWT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 16 of file main.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 16                                             \{\par
17     if(argc == 0)\par
18         return 0;\par
19 \par
20     int i;\par
21     for(i = 0; i < argc; i++)\par
22         printf("argv[%d] => \\"%s\\"\\n", i, argv[i]);\par
23 \par
24     return 1;\par
25 \}\par
}
}
{\xe \v test_signals\:usr/src/libcrt0/test/main.c}
{\xe \v usr/src/libcrt0/test/main.c\:test_signals}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int test_signals (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAWU}
{\bkmkend AAAAAAAAWU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 28 of file main.c.}\par
{
References __test_signals__().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28                           \{\par
29     assert(signal(SIGUSR1, __test_signals__) != SIG_ERR);\par
30     return raise(SIGUSR1);\par
31 \}\par
}
}
{\xe \v test_stdio\:usr/src/libcrt0/test/main.c}
{\xe \v usr/src/libcrt0/test/main.c\:test_stdio}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int test_stdio (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAWV}
{\bkmkend AAAAAAAAWV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 12 of file main.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12                         \{\par
13     return printf("Bla bla bla\\n");\par
14 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
usr/src/libpthread/test/main.c File Reference\par \pard\plain 
{\tc\tcl2 \v usr/src/libpthread/test/main.c}
{\xe \v usr/src/libpthread/test/main.c}
{\bkmkstart AAAAAAAAWW}
{\bkmkend AAAAAAAAWW}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include <assert.h>}\par
{\f2 #include <pthread.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void * {\b __test_pthread_1} (void *p)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} (int argc, char **argv)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v __test_pthread_1\:usr/src/libpthread/test/main.c}
{\xe \v usr/src/libpthread/test/main.c\:__test_pthread_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void* __test_pthread_1 (void * {\i p}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAWX}
{\bkmkend AAAAAAAAWX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 7 of file main.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7                                         \{\par
8     return (void*) 200;\par
9 \}\par
}
}
{\xe \v main\:usr/src/libpthread/test/main.c}
{\xe \v usr/src/libpthread/test/main.c\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main (int {\i argc}, char ** {\i argv})}}
\par
{\bkmkstart AAAAAAAAWY}
{\bkmkend AAAAAAAAWY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 12 of file main.c.}\par
{
References __test_pthread_1(), pthread_barrier_destroy(), pthread_barrier_init(), PTHREAD_BARRIER_SERIAL_THREAD, pthread_barrier_wait(), pthread_cond_destroy(), pthread_cond_init(), pthread_create(), pthread_getspecific(), pthread_join(), pthread_key_create(), pthread_key_delete(), pthread_mutex_destroy(), pthread_mutex_init(), pthread_mutex_trylock(), pthread_mutex_unlock(), pthread_rwlock_destroy(), pthread_rwlock_init(), pthread_rwlock_tryrdlock(), pthread_rwlock_trywrlock(), pthread_rwlock_unlock(), pthread_setspecific(), pthread_spin_destroy(), pthread_spin_init(), pthread_spin_trylock(), and pthread_spin_unlock().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12                                 \{\par
13 \par
14     printf("Test #1 - Create and join thread\\n");\par
15 \par
16     pthread_t ptx_1;\par
17     void* retval_1;\par
18 \par
19     assert(pthread_create(&ptx_1, NULL, __test_pthread_1, NULL) == 0);\par
20     assert(pthread_join(ptx_1, &retval_1) == 0);\par
21     assert((int) retval_1 == 200 && "bad returned value");\par
22 \par
23     \par
24 \par
25     printf("Test #2 - Create and lock/unlock mutex\\n");\par
26     pthread_mutex_t mtx_2;\par
27     \par
28     assert(pthread_mutex_init(&mtx_2, NULL) == 0);\par
29     assert(pthread_mutex_trylock(&mtx_2) == 0);\par
30     assert(pthread_mutex_unlock(&mtx_2) == 0);\par
31     assert(pthread_mutex_destroy(&mtx_2) == 0);\par
32         \par
33 \par
34 \par
35     printf("Test #3 - Create and lock/unlock spinlock\\n");\par
36     pthread_spinlock_t spl_3;\par
37     \par
38     assert(pthread_spin_init(&spl_3, 0) == 0);\par
39     assert(pthread_spin_trylock(&spl_3) == 0);\par
40     assert(pthread_spin_unlock(&spl_3) == 0);\par
41     assert(pthread_spin_destroy(&spl_3) == 0);\par
42 \par
43 \par
44 \par
45     printf("Test #4 - Create and lock/unlock condition\\n");\par
46     pthread_cond_t cond_4;\par
47     pthread_mutex_t mtx_4;\par
48 \par
49     assert(pthread_mutex_init(&mtx_4, NULL) == 0);\par
50     assert(pthread_cond_init(&cond_4, NULL) == 0);\par
51     assert(pthread_cond_destroy(&cond_4) == 0);\par
52 \par
53 \par
54 \par
55     printf("Test #5 - Create and lock/unlock Read-Write lock\\n");\par
56     pthread_rwlock_t rw_5;\par
57     \par
58     assert(pthread_rwlock_init(&rw_5, NULL) == 0);\par
59     assert(pthread_rwlock_tryrdlock(&rw_5) == 0);\par
60     assert(pthread_rwlock_unlock(&rw_5) == 0);\par
61     assert(pthread_rwlock_trywrlock(&rw_5) == 0);\par
62     assert(pthread_rwlock_unlock(&rw_5) == 0);\par
63     assert(pthread_rwlock_destroy(&rw_5) == 0);\par
64 \par
65     printf("Test #6 - Create and wait barrier\\n");\par
66     pthread_barrier_t bar_6;\par
67     \par
68     assert(pthread_barrier_init(&bar_6, NULL, 1) == 0);\par
69     assert(pthread_barrier_wait(&bar_6) == PTHREAD_BARRIER_SERIAL_THREAD);\par
70     assert(pthread_barrier_destroy(&bar_6) == 0);\par
71 \par
72 \par
73 \par
74     printf("Test #7 - Store and read from TLS\\n");\par
75     pthread_key_t key_7;\par
76 \par
77     assert(pthread_key_create(&key_7, NULL) == 0);\par
78     assert(pthread_setspecific(key_7, (const void*) 200) == 0);\par
79     assert((int) pthread_getspecific(key_7) == 200 && "bad returned value");\par
80     assert(pthread_key_delete(key_7) == 0);\par
81 \par
82 \par
83 \par
84     printf("\\nTest OK\\n");\par
85     return 0;\par
86 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/mm/heap.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/mm/heap.c}
{\xe \v src/mm/heap.c}
{\bkmkstart AAAAAAAAWZ}
{\bkmkend AAAAAAAAWZ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stddef.h>}\par
{\f2 #include <sys/types.h>}\par
{\f2 #include <aplus/mm.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b halloc} ({\b heap_t} *{\b heap}, size_t {\b size})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b hfree} ({\b heap_t} *{\b heap}, void *addr, size_t {\b size})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v halloc\:heap.c}
{\xe \v heap.c\:halloc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* halloc ({\b heap_t} * {\i heap}, size_t {\i size})}}
\par
{\bkmkstart AAAAAAAAXA}
{\bkmkend AAAAAAAAXA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 28 of file heap.c.}\par
{
References heap::alloc.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28                                         \{\par
29     if(heap)\par
30         if(heap->alloc)\par
31             return heap->alloc(heap, size);\par
32             \par
33     return 0;\par
34 \}\par
}
}
{\xe \v hfree\:heap.c}
{\xe \v heap.c\:hfree}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void hfree ({\b heap_t} * {\i heap}, void * {\i addr}, size_t {\i size})}}
\par
{\bkmkstart AAAAAAAAXB}
{\bkmkend AAAAAAAAXB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 36 of file heap.c.}\par
{
References heap::free.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 36                                                   \{\par
37     if(heap)\par
38         if(heap->free)\par
39             heap->free(heap, addr, size);\par
40 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/mm/kheap.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/mm/kheap.c}
{\xe \v src/mm/kheap.c}
{\bkmkstart AAAAAAAAXC}
{\bkmkend AAAAAAAAXC}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stddef.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <sys/types.h>}\par
{\f2 #include <aplus/mm.h>}\par
{\f2 #include <grub.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BITMAP_SET}(bmp, bit)\~ bmp[bit / 32] |= (1 << (bit % 32))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BITMAP_CLR}(bmp, bit)\~ bmp[bit / 32] &= ~(1 << (bit % 32))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BITMAP_TST}(bmp, bit)\~ (bmp[bit / 32] & (1 << (bit % 32)))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GETBIT}(addr)\~ (({\b uint32_t}) addr / {\b BLKSIZE})\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b bitmap_first} ({\b heap_t} *{\b heap}, size_t {\b size})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b bitmap_alloc} ({\b heap_t} *{\b heap}, size_t {\b size})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b bitmap_free} ({\b heap_t} *{\b heap}, void *addr, size_t {\b size})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b kheap_init} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b heap_t} {\b kheap}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b memsize}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b uint8_t} {\b __bitmap} [131072]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v BITMAP_CLR\:kheap.c}
{\xe \v kheap.c\:BITMAP_CLR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BITMAP_CLR( bmp,  bit)\~ bmp[bit / 32] &= ~(1 << (bit % 32))}}
\par
{\bkmkstart AAAAAAAAXD}
{\bkmkend AAAAAAAAXD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 35 of file kheap.c.}\par
}
{\xe \v BITMAP_SET\:kheap.c}
{\xe \v kheap.c\:BITMAP_SET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BITMAP_SET( bmp,  bit)\~ bmp[bit / 32] |= (1 << (bit % 32))}}
\par
{\bkmkstart AAAAAAAAXE}
{\bkmkend AAAAAAAAXE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 32 of file kheap.c.}\par
}
{\xe \v BITMAP_TST\:kheap.c}
{\xe \v kheap.c\:BITMAP_TST}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BITMAP_TST( bmp,  bit)\~ (bmp[bit / 32] & (1 << (bit % 32)))}}
\par
{\bkmkstart AAAAAAAAXF}
{\bkmkend AAAAAAAAXF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 38 of file kheap.c.}\par
}
{\xe \v GETBIT\:kheap.c}
{\xe \v kheap.c\:GETBIT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GETBIT( addr)\~ (({\b uint32_t}) addr / {\b BLKSIZE})}}
\par
{\bkmkstart AAAAAAAAXG}
{\bkmkend AAAAAAAAXG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 42 of file kheap.c.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v bitmap_alloc\:kheap.c}
{\xe \v kheap.c\:bitmap_alloc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* bitmap_alloc ({\b heap_t} * {\i heap}, size_t {\i size})}}
\par
{\bkmkstart AAAAAAAAXH}
{\bkmkend AAAAAAAAXH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 75 of file kheap.c.}\par
{
References heap::bitmap, bitmap_first(), BITMAP_SET, BLKSIZE, heap::size, size, and heap::used.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 75                                               \{\par
76     if(!heap)\par
77         return 0;\par
78         \par
79     if(!heap->bitmap)\par
80         return 0;\par
81         \par
82     if(heap->used >= heap->size)\par
83         return 0;\par
84         \par
85     \par
86     if(size % BLKSIZE) \{\par
87         size /= BLKSIZE;\par
88         size += 1;\par
89     \}else \{\par
90         size /= BLKSIZE;\par
91     \}   \par
92         \par
93     int index = bitmap_first(heap, size);\par
94     if(index == -1)\par
95         return 0;\par
96                 \par
97     for(int i = 0; i < size; i++)\par
98         BITMAP_SET(heap->bitmap, (index + i));\par
99     \par
100     \par
101     heap->used += size;\par
102     \par
103     return (void*) (index * BLKSIZE);\par
104 \}\par
}
}
{\xe \v bitmap_first\:kheap.c}
{\xe \v kheap.c\:bitmap_first}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int bitmap_first ({\b heap_t} * {\i heap}, size_t {\i size}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAXI}
{\bkmkend AAAAAAAAXI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 55 of file kheap.c.}\par
{
References heap::bitmap, BITMAP_TST, heap::size, and size.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 55                                                    \{\par
56     if(size == 0)\par
57         return -1;\par
58         \par
59     for(int i = 0; i < heap->size; i++) \{   \par
60         for(int j = 0, f = 0; j < size; j++) \{\par
61             if(BITMAP_TST(heap->bitmap, (i + j)))\par
62                 continue;\par
63             \par
64             f++;    \par
65             if(f == size)\par
66                 return i;\par
67         \}\par
68     \}\par
69     \par
70     return -1;\par
71 \}\par
}
}
{\xe \v bitmap_free\:kheap.c}
{\xe \v kheap.c\:bitmap_free}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void bitmap_free ({\b heap_t} * {\i heap}, void * {\i addr}, size_t {\i size})}}
\par
{\bkmkstart AAAAAAAAXJ}
{\bkmkend AAAAAAAAXJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 106 of file kheap.c.}\par
{
References heap::bitmap, BITMAP_CLR, BLKSIZE, GETBIT, size, and heap::used.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 106                                                         \{\par
107     if(!heap)\par
108         return;\par
109         \par
110     if(!heap->bitmap)\par
111         return;\par
112         \par
113         \par
114     if(size % BLKSIZE) \{\par
115         size /= BLKSIZE;\par
116         size += 1;\par
117     \}else \{\par
118         size /= BLKSIZE;\par
119     \}   \par
120         \par
121     \par
122     int index = GETBIT(addr);\par
123     for(int i = 0; i < size; i++)\par
124         BITMAP_CLR(heap->bitmap, (index + i));\par
125         \par
126         \par
127     heap->used -= size;\par
128 \}\par
}
}
{\xe \v kheap_init\:kheap.c}
{\xe \v kheap.c\:kheap_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int kheap_init ()}}
\par
{\bkmkstart AAAAAAAAXK}
{\bkmkend AAAAAAAAXK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 132 of file kheap.c.}\par
{
References __bitmap, heap::alloc, heap::bitmap, bitmap_alloc(), bitmap_free(), BLKSIZE, heap::free, halloc(), memsize, mm_setheap(), heap::size, and uint32_t.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 132                  \{\par
133 \par
134     kheap.bitmap = (uint32_t*) __bitmap;\par
135     kheap.size = memsize / BLKSIZE;\par
136     kheap.alloc = bitmap_alloc;\par
137     kheap.free = bitmap_free;\par
138     \par
139     memset(kheap.bitmap, 0, kheap.size);\par
140     \par
141     mm_setheap(&kheap);\par
142     \par
143     // Alloc first 4MB (reserved physical kernel area)\par
144     halloc(&kheap, (size_t) 0x400000);\par
145     \par
146 \par
147     return 0;\par
148 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v __bitmap\:kheap.c}
{\xe \v kheap.c\:__bitmap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} __bitmap[131072]{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAXL}
{\bkmkend AAAAAAAAXL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 52 of file kheap.c.}\par
}
{\xe \v kheap\:kheap.c}
{\xe \v kheap.c\:kheap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b heap_t} kheap{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAXM}
{\bkmkend AAAAAAAAXM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 48 of file kheap.c.}\par
}
{\xe \v memsize\:kheap.c}
{\xe \v kheap.c\:memsize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} memsize}}
\par
{\bkmkstart AAAAAAAAXN}
{\bkmkend AAAAAAAAXN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 35 of file mm.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/mm/mm.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/mm/mm.c}
{\xe \v src/mm/mm.c}
{\bkmkstart AAAAAAAAXO}
{\bkmkend AAAAAAAAXO}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <sys/types.h>}\par
{\f2 #include <stddef.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <aplus/mm.h>}\par
{\f2 #include <aplus/list.h>}\par
{\f2 #include <grub.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b block}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b block} {\b __attribute__} ((packed))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b kfree} (void *ptr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b krealloc} (void *ptr, size_t {\b size})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b mm_setheap} ({\b heap_t} *{\b heap})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile {\b heap_t} * {\b mm_getheap} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b mm_init} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b memsize}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile {\b heap_t} * {\b current_heap}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} * {\b current_vmm}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} * {\b kernel_vmm}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b list_t} * {\b vmm_queue}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b magic}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b size}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v __attribute__\:mm.c}
{\xe \v mm.c\:__attribute__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b block} __attribute__ ((packed) )}}
\par
{\bkmkstart AAAAAAAAXP}
{\bkmkend AAAAAAAAXP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 47 of file mm.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 50                            \{\par
51     void* addr = (void*) halloc(current_heap, size);\par
52     if(!addr)\par
53         panic("halloc(): failed!");\par
54 \par
55 \par
56     addr = mm_vaddr(addr);\par
57 \par
58     block_t* block = (block_t*) addr;\par
59     block->magic = BLKMAGIC;\par
60     block->size = size;\par
61 \par
62     return (void*) ((uint32_t) block + sizeof(block_t));\par
63 \}\par
}
}
{\xe \v kfree\:mm.c}
{\xe \v mm.c\:kfree}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void kfree (void * {\i ptr})}}
\par
{\bkmkstart AAAAAAAAXQ}
{\bkmkend AAAAAAAAXQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 66 of file mm.c.}\par
{
References BLKMAGIC, hfree(), mm_align(), mm_paddr(), and size.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 66                       \{\par
67     if(!ptr)\par
68         return;\par
69         \par
70     \par
71     block_t* block = (block_t*) ptr;\par
72     if(block->magic != BLKMAGIC)\par
73         return;\par
74         \par
75     size_t size = block->size;\par
76     block->size = 0;\par
77     block->magic = 0;\par
78     \par
79     \par
80     hfree(current_heap, mm_paddr(mm_align(ptr)), size);\par
81 \}\par
}
}
{\xe \v krealloc\:mm.c}
{\xe \v mm.c\:krealloc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* krealloc (void * {\i ptr}, size_t {\i size})}}
\par
{\bkmkstart AAAAAAAAXR}
{\bkmkend AAAAAAAAXR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 84 of file mm.c.}\par
{
References BLKMAGIC, kfree(), and kmalloc().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 84                                        \{\par
85     if(ptr == NULL)\par
86         return kmalloc(size);\par
87         \par
88     if(size == 0) \{\par
89         kfree(ptr);\par
90         return NULL;\par
91     \}   \par
92 \par
93     block_t* block = (block_t*) ptr;\par
94     if(block->magic != BLKMAGIC)\par
95         return NULL;\par
96         \par
97     void* newptr = kmalloc(size);\par
98     if(!newptr)\par
99         return NULL;\par
100         \par
101     if(size > block->size)\par
102         size = block->size;\par
103         \par
104     memcpy(newptr, ptr, size);\par
105     kfree(ptr);\par
106     \par
107     return newptr;\par
108 \}\par
}
}
{\xe \v mm_getheap\:mm.c}
{\xe \v mm.c\:mm_getheap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile {\b heap_t}* mm_getheap ()}}
\par
{\bkmkstart AAAAAAAAXS}
{\bkmkend AAAAAAAAXS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 117 of file mm.c.}\par
{
References current_heap.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 117                               \{\par
118     return current_heap;\par
119 \}\par
}
}
{\xe \v mm_init\:mm.c}
{\xe \v mm.c\:mm_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int mm_init ()}}
\par
{\bkmkstart AAAAAAAAXT}
{\bkmkend AAAAAAAAXT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 122 of file mm.c.}\par
{
References kheap_init(), mbd, BootInfo_t::mem_lower, BootInfo_t::mem_upper, memsize, vmm_init(), and VMM_MAX_MEMORY.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 122               \{\par
123 \par
124     memsize = (mbd->mem_upper + mbd->mem_lower) * 1024;\par
125     if(memsize > VMM_MAX_MEMORY)\par
126         memsize = VMM_MAX_MEMORY;\par
127 \par
128 \par
129     kheap_init();\par
130     vmm_init();\par
131 \par
132     return 0;\par
133 \}\par
}
}
{\xe \v mm_setheap\:mm.c}
{\xe \v mm.c\:mm_setheap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void mm_setheap ({\b heap_t} * {\i heap})}}
\par
{\bkmkstart AAAAAAAAXU}
{\bkmkend AAAAAAAAXU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 113 of file mm.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 113                               \{\par
114     current_heap = heap;\par
115 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v current_heap\:mm.c}
{\xe \v mm.c\:current_heap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile {\b heap_t}* current_heap}}
\par
{\bkmkstart AAAAAAAAXV}
{\bkmkend AAAAAAAAXV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 36 of file mm.c.}\par
}
{\xe \v current_vmm\:mm.c}
{\xe \v mm.c\:current_vmm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t}* current_vmm}}
\par
{\bkmkstart AAAAAAAAXW}
{\bkmkend AAAAAAAAXW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 46 of file paging.c.}\par
}
{\xe \v kernel_vmm\:mm.c}
{\xe \v mm.c\:kernel_vmm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t}* kernel_vmm}}
\par
{\bkmkstart AAAAAAAAXX}
{\bkmkend AAAAAAAAXX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 47 of file paging.c.}\par
}
{\xe \v magic\:mm.c}
{\xe \v mm.c\:magic}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} magic}}
\par
{\bkmkstart AAAAAAAAXY}
{\bkmkend AAAAAAAAXY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 42 of file mm.c.}\par
}
{\xe \v memsize\:mm.c}
{\xe \v mm.c\:memsize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} memsize}}
\par
{\bkmkstart AAAAAAAAXZ}
{\bkmkend AAAAAAAAXZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 35 of file mm.c.}\par
}
{\xe \v size\:mm.c}
{\xe \v mm.c\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t size}}
\par
{\bkmkstart AAAAAAAAYA}
{\bkmkend AAAAAAAAYA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 43 of file mm.c.}\par
}
{\xe \v vmm_queue\:mm.c}
{\xe \v mm.c\:vmm_queue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b list_t}* vmm_queue}}
\par
{\bkmkstart AAAAAAAAYB}
{\bkmkend AAAAAAAAYB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 49 of file paging.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/mm/paging.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/mm/paging.c}
{\xe \v src/mm/paging.c}
{\bkmkstart AAAAAAAAYC}
{\bkmkend AAAAAAAAYC}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
{\f2 #include <stddef.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <sys/types.h>}\par
{\f2 #include <aplus.h>}\par
{\f2 #include <aplus/mm.h>}\par
{\f2 #include <aplus/task.h>}\par
{\f2 #include <aplus/list.h>}\par
{\f2 #include <grub.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PGSIZE}\~ ({\b BLKSIZE})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PGFLAGS}\~ (0x00000000)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PDSIZE}\~ (1024)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PDENTRY}(x)\~ (({\b uint32_t}) x >> 22)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PTSIZE}\~ (1024)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PTENTRY}(x)\~ (({\b uint32_t}) x << 10 >> 10 >> 12)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vmm_switch} ({\b uint32_t} *addr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vmm_enable} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vmm_disable} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b vmm_map} ({\b uint32_t} *pd, void *paddr, void *vaddr, size_t len, int {\b flags})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vmm_umap} ({\b uint32_t} *pd, void *addr, size_t len)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b vmm_alloc} (void *vaddr, size_t {\b size}, int {\b flags})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vmm_mapkernel} ({\b uint32_t} *{\b dest})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} * {\b vmm_create} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vmm_destroy} ({\b uint32_t} *vmm)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vmm_init} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile {\b heap_t} * {\b current_heap}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b memsize}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} * {\b current_vmm}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} * {\b kernel_vmm}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b list_t} * {\b vmm_queue}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v PDENTRY\:paging.c}
{\xe \v paging.c\:PDENTRY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PDENTRY( x)\~ (({\b uint32_t}) x >> 22)}}
\par
{\bkmkstart AAAAAAAAYD}
{\bkmkend AAAAAAAAYD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 38 of file paging.c.}\par
}
{\xe \v PDSIZE\:paging.c}
{\xe \v paging.c\:PDSIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PDSIZE\~ (1024)}}
\par
{\bkmkstart AAAAAAAAYE}
{\bkmkend AAAAAAAAYE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 37 of file paging.c.}\par
}
{\xe \v PGFLAGS\:paging.c}
{\xe \v paging.c\:PGFLAGS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PGFLAGS\~ (0x00000000)}}
\par
{\bkmkstart AAAAAAAAYF}
{\bkmkend AAAAAAAAYF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 35 of file paging.c.}\par
}
{\xe \v PGSIZE\:paging.c}
{\xe \v paging.c\:PGSIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PGSIZE\~ ({\b BLKSIZE})}}
\par
{\bkmkstart AAAAAAAAYG}
{\bkmkend AAAAAAAAYG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 34 of file paging.c.}\par
}
{\xe \v PTENTRY\:paging.c}
{\xe \v paging.c\:PTENTRY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PTENTRY( x)\~ (({\b uint32_t}) x << 10 >> 10 >> 12)}}
\par
{\bkmkstart AAAAAAAAYH}
{\bkmkend AAAAAAAAYH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 41 of file paging.c.}\par
}
{\xe \v PTSIZE\:paging.c}
{\xe \v paging.c\:PTSIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PTSIZE\~ (1024)}}
\par
{\bkmkstart AAAAAAAAYI}
{\bkmkend AAAAAAAAYI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 40 of file paging.c.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v vmm_alloc\:paging.c}
{\xe \v paging.c\:vmm_alloc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* vmm_alloc (void * {\i vaddr}, size_t {\i size}, int {\i flags})}}
\par
{\bkmkstart AAAAAAAAYJ}
{\bkmkend AAAAAAAAYJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 130 of file paging.c.}\par
{
References current_vmm, halloc(), and vmm_map().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 130                                                      \{\par
131     void* paddr = (void*) halloc(current_heap, size);\par
132 \par
133     vmm_map(current_vmm, paddr, vaddr, size, flags);\par
134 \par
135     return paddr;\par
136 \}\par
}
}
{\xe \v vmm_create\:paging.c}
{\xe \v paging.c\:vmm_create}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t}* vmm_create ()}}
\par
{\bkmkstart AAAAAAAAYK}
{\bkmkend AAAAAAAAYK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 151 of file paging.c.}\par
{
References kmalloc(), mm_align(), PDSIZE, and uint32_t.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 151                        \{\par
152     uint32_t* addr = (uint32_t*) mm_align((void*) kmalloc(PDSIZE * sizeof(uint32_t)));\par
153     if(!addr)\par
154         return NULL;\par
155         \par
156 \par
157     memset(addr, 0, PDSIZE * sizeof(uint32_t));\par
158     return addr;\par
159 \}\par
}
}
{\xe \v vmm_destroy\:paging.c}
{\xe \v paging.c\:vmm_destroy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vmm_destroy ({\b uint32_t} * {\i vmm})}}
\par
{\bkmkstart AAAAAAAAYL}
{\bkmkend AAAAAAAAYL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 161 of file paging.c.}\par
{
References PDSIZE, and uint32_t.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 161                                 \{\par
162     memset(vmm, 0, PDSIZE * sizeof(uint32_t));\par
163 \}\par
}
}
{\xe \v vmm_disable\:paging.c}
{\xe \v paging.c\:vmm_disable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vmm_disable ()}}
\par
{\bkmkstart AAAAAAAAYM}
{\bkmkend AAAAAAAAYM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 65 of file paging.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 65                    \{\par
66     write_cr0(read_cr0() & ~0x80000000);\par
67 \}\par
}
}
{\xe \v vmm_enable\:paging.c}
{\xe \v paging.c\:vmm_enable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vmm_enable ()}}
\par
{\bkmkstart AAAAAAAAYN}
{\bkmkend AAAAAAAAYN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 60 of file paging.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 60                   \{\par
61     write_cr4(read_cr4() & ~0x00000010);\par
62     write_cr0(read_cr0() | 0x80000000);\par
63 \}\par
}
}
{\xe \v vmm_init\:paging.c}
{\xe \v paging.c\:vmm_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vmm_init ()}}
\par
{\bkmkstart AAAAAAAAYO}
{\bkmkend AAAAAAAAYO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 165 of file paging.c.}\par
{
References halloc(), kernel_vmm, list_init, panic(), PDSIZE, uint32_t, vmm_enable(), vmm_mapkernel(), and vmm_switch().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 165                \{\par
166 \par
167     kernel_vmm = (uint32_t*) halloc(current_heap, PDSIZE * sizeof(uint32_t));\par
168     if(!kernel_vmm)\par
169         panic("Could not initialize VMM");\par
170     \par
171 \par
172     memset(kernel_vmm, 0, PDSIZE * sizeof(uint32_t));\par
173     \par
174     vmm_mapkernel(kernel_vmm);\par
175     vmm_switch(kernel_vmm);\par
176     vmm_enable();\par
177 \par
178     list_init(vmm_queue);\par
179     return 0;\par
180 \}\par
}
}
{\xe \v vmm_map\:paging.c}
{\xe \v paging.c\:vmm_map}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* vmm_map ({\b uint32_t} * {\i pd}, void * {\i paddr}, void * {\i vaddr}, size_t {\i len}, int {\i flags})}}
\par
{\bkmkstart AAAAAAAAYP}
{\bkmkend AAAAAAAAYP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 72 of file paging.c.}\par
{
References current_vmm, flags, halloc(), mm_align(), panic(), PDENTRY, PGSIZE, PTENTRY, PTSIZE, uint32_t, and VMM_FLAGS_DEFAULT.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 72                                                                              \{  \par
73     if(!pd)\par
74         return paddr;\par
75         \par
76     paddr = mm_align(paddr);\par
77     vaddr = mm_align(vaddr);\par
78         \par
79     int pages = (len / PGSIZE) + 1;\par
80     uint32_t pframe = (uint32_t) paddr;\par
81     uint32_t vframe = (uint32_t) vaddr;\par
82     \par
83     for(int i = 0; i < pages; i++) \{\par
84         uint32_t* e = &pd[PDENTRY(vframe)];\par
85         \par
86         if(*e == 0) \{\par
87             uint32_t* table = (uint32_t*) halloc(current_heap, PTSIZE * sizeof(uint32_t));\par
88             if(!table)\par
89                 panic("vmm_map(): cannot allocate more table\\n");\par
90                 \par
91             if(current_vmm)\par
92                 vmm_map(current_vmm, table, table, PTSIZE * sizeof(uint32_t), VMM_FLAGS_DEFAULT);\par
93             \par
94             memset(table, 0, PTSIZE * sizeof(uint32_t));\par
95             *e = (uint32_t) table | flags;  \par
96         \}\par
97         \par
98         uint32_t* t = (uint32_t*) (*e & ~0xFFF);\par
99         t[PTENTRY(vframe)] = pframe | flags;\par
100         \par
101         pframe += PGSIZE;\par
102         vframe += PGSIZE;\par
103     \}\par
104     \par
105     return vaddr;\par
106 \}\par
}
}
{\xe \v vmm_mapkernel\:paging.c}
{\xe \v paging.c\:vmm_mapkernel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vmm_mapkernel ({\b uint32_t} * {\i dest})}}
\par
{\bkmkstart AAAAAAAAYQ}
{\bkmkend AAAAAAAAYQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 138 of file paging.c.}\par
{
References memsize, MM_LBASE, MM_LSIZE, mm_vaddr(), VMM_FLAGS_DEFAULT, VMM_FLAGS_USER, and vmm_map().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 138                                    \{\par
139     // Map 8MB to low area (kernel reserved)\par
140     vmm_map(dest, (void*) MM_LBASE, (void*) MM_LBASE, MM_LSIZE, VMM_FLAGS_DEFAULT);\par
141 \par
142     // Map all high-memory (kernel reserved)\par
143     vmm_map(dest, (void*) 0, mm_vaddr((void*) 0), memsize, VMM_FLAGS_DEFAULT);\par
144 \par
145     // Map Linear Frame Buffer\par
146     vmm_map(dest, (void*) 0xE0000000, (void*) 0xE0000000, 0x10000000, VMM_FLAGS_DEFAULT | VMM_FLAGS_USER);\par
147 \}\par
}
}
{\xe \v vmm_switch\:paging.c}
{\xe \v paging.c\:vmm_switch}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vmm_switch ({\b uint32_t} * {\i addr})}}
\par
{\bkmkstart AAAAAAAAYR}
{\bkmkend AAAAAAAAYR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 54 of file paging.c.}\par
{
References current_vmm, mm_paddr(), and uint32_t.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 54                                 \{\par
55     current_vmm = addr;\par
56     \par
57     write_cr3((uint32_t) mm_paddr((void*) addr));\par
58 \}\par
}
}
{\xe \v vmm_umap\:paging.c}
{\xe \v paging.c\:vmm_umap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vmm_umap ({\b uint32_t} * {\i pd}, void * {\i addr}, size_t {\i len})}}
\par
{\bkmkstart AAAAAAAAYS}
{\bkmkend AAAAAAAAYS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 109 of file paging.c.}\par
{
References mm_align(), PDENTRY, PGSIZE, PTENTRY, and uint32_t.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 109                                                     \{\par
110     if(!pd)\par
111         return;\par
112         \par
113     addr = mm_align(addr);\par
114         \par
115     int pages = (len / PGSIZE) + 1;\par
116     \par
117     \par
118     for(uint32_t i = 0, frame = (uint32_t) addr; i < pages; i++, frame += PGSIZE) \{\par
119         uint32_t* e = &pd[PDENTRY(frame)];\par
120         if((*e & 1) != 1)\par
121             continue;\par
122             \par
123         uint32_t* table = (uint32_t*) (*e & ~0xFFF);\par
124         table[PTENTRY(frame)] = 0;\par
125     \}\par
126     \par
127 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v current_heap\:paging.c}
{\xe \v paging.c\:current_heap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile {\b heap_t}* current_heap}}
\par
{\bkmkstart AAAAAAAAYT}
{\bkmkend AAAAAAAAYT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 36 of file mm.c.}\par
}
{\xe \v current_vmm\:paging.c}
{\xe \v paging.c\:current_vmm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t}* current_vmm}}
\par
{\bkmkstart AAAAAAAAYU}
{\bkmkend AAAAAAAAYU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 46 of file paging.c.}\par
}
{\xe \v kernel_vmm\:paging.c}
{\xe \v paging.c\:kernel_vmm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t}* kernel_vmm}}
\par
{\bkmkstart AAAAAAAAYV}
{\bkmkend AAAAAAAAYV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 47 of file paging.c.}\par
}
{\xe \v memsize\:paging.c}
{\xe \v paging.c\:memsize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} memsize}}
\par
{\bkmkstart AAAAAAAAYW}
{\bkmkend AAAAAAAAYW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 35 of file mm.c.}\par
}
{\xe \v vmm_queue\:paging.c}
{\xe \v paging.c\:vmm_queue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b list_t}* vmm_queue}}
\par
{\bkmkstart AAAAAAAAYX}
{\bkmkend AAAAAAAAYX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 49 of file paging.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/net/arp.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/net/arp.c}
{\xe \v src/net/arp.c}
{\bkmkstart AAAAAAAAYY}
{\bkmkend AAAAAAAAYY}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <aplus.h>}\par
{\f2 #include <aplus/list.h>}\par
{\f2 #include <aplus/netif.h>}\par
{\f2 #include <stddef.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <aplus/net/eth.h>}\par
{\f2 #include <aplus/net/arp.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b arp_cache_entry_t} * {\b arp_cache_find_by_macaddr} ({\b macaddr_t} macaddr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b arp_cache_add} ({\b macaddr_t} macaddr, {\b ipv4_t} ipv4)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b arp_recv} ({\b netif_t} *{\b netif}, void *buf, size_t {\b length})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b arp_send} ({\b netif_t} *{\b netif})\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b list_t} * {\b arp_cache} = NULL\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v arp_cache_add\:arp.c}
{\xe \v arp.c\:arp_cache_add}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int arp_cache_add ({\b macaddr_t} {\i macaddr}, {\b ipv4_t} {\i ipv4})}}
\par
{\bkmkstart AAAAAAAAYZ}
{\bkmkend AAAAAAAAYZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 33 of file arp.c.}\par
{
References arp_cache_find_by_macaddr(), netif::ipv4, kmalloc(), kprintf(), list_add(), list_init, list_remove(), and netif_find_by_macaddr().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 33                                                   \{\par
34     if(arp_cache == NULL) \{\par
35         list_init(arp_cache);\par
36     \}\par
37 \par
38 \par
39     arp_cache_entry_t* arp = arp_cache_find_by_macaddr(macaddr);\par
40     if(arp)\par
41         list_remove(arp_cache, (listval_t) arp);\par
42 \par
43 \par
44     arp = kmalloc(sizeof(arp_cache_entry_t));\par
45     memcpy(arp->macaddr, macaddr, sizeof(macaddr_t));\par
46     memcpy(arp->ipv4, ipv4, sizeof(ipv4_t));\par
47 \par
48     //arp->ttl = time(NULL) + ARP_TTL;\par
49 \par
50 \par
51 #ifdef ARP_DEBUG\par
52     kprintf("arp: added new cache entry (%02x.%02x.%02x.%02x)\\n",\par
53         arp->ipv4[0],\par
54         arp->ipv4[1],\par
55         arp->ipv4[2],\par
56         arp->ipv4[3]\par
57     );\par
58 #endif\par
59 \par
60     netif_t* netif = (netif_t*) netif_find_by_macaddr(arp->macaddr);\par
61     if(netif)\par
62         memcpy(netif->ipv4, arp->ipv4, sizeof(ipv4_t));\par
63 \par
64     return list_add(arp_cache, (listval_t) arp);\par
65 \}\par
}
}
{\xe \v arp_cache_find_by_macaddr\:arp.c}
{\xe \v arp.c\:arp_cache_find_by_macaddr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b arp_cache_entry_t}* arp_cache_find_by_macaddr ({\b macaddr_t} {\i macaddr})}}
\par
{\bkmkstart AAAAAAAAZA}
{\bkmkend AAAAAAAAZA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 16 of file arp.c.}\par
{
References list_empty(), list_foreach, arp_cache_entry::macaddr, and value.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 16                                                                 \{\par
17     if(arp_cache == NULL)\par
18         return NULL;\par
19 \par
20     if(list_empty(arp_cache))\par
21         return NULL;\par
22 \par
23     list_foreach(value, arp_cache) \{\par
24         arp_cache_entry_t* arp = (arp_cache_entry_t*) value;\par
25 \par
26         if(memcmp(arp->macaddr, macaddr, sizeof(macaddr_t)) == 0)\par
27             return arp;\par
28     \}\par
29 \par
30     return NULL;\par
31 \}\par
}
}
{\xe \v arp_recv\:arp.c}
{\xe \v arp.c\:arp_recv}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int arp_recv ({\b netif_t} * {\i netif}, void * {\i buf}, size_t {\i length})}}
\par
{\bkmkstart AAAAAAAAZB}
{\bkmkend AAAAAAAAZB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 67 of file arp.c.}\par
{
References arp_cache_add(), ARP_OPERATION_REPLY, length, and netif::macaddr.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 67                                                        \{\par
68     arp_header_t* arp = (arp_header_t*) buf;\par
69 \par
70 \par
71     if(arp->operation == ARP_OPERATION_REPLY)\par
72         if(memcmp(netif->macaddr, arp->tha, sizeof(macaddr_t)) == 0)\par
73             arp_cache_add(arp->tha, arp->tpa);\par
74 \par
75     return length;\par
76 \}\par
}
}
{\xe \v arp_send\:arp.c}
{\xe \v arp.c\:arp_send}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int arp_send ({\b netif_t} * {\i netif})}}
\par
{\bkmkstart AAAAAAAAZC}
{\bkmkend AAAAAAAAZC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 79 of file arp.c.}\par
{
References ARP_HWLEN, ARP_HWTYPE, ARP_OPERATION_REQUEST, ARP_PRLEN, ARP_PRTYPE, eth_send(), kfree(), kmalloc(), kprintf(), netif::macaddr, netif::name, and NETIF_ARP.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 79                              \{\par
80     arp_header_t* arp = (arp_header_t*) kmalloc(sizeof(arp_header_t));\par
81     arp->hwtype = ARP_HWTYPE;\par
82     arp->prtype = ARP_PRTYPE;\par
83     arp->hwlen = ARP_HWLEN;\par
84     arp->prlen = ARP_PRLEN;\par
85     arp->operation = ARP_OPERATION_REQUEST;\par
86     \par
87     memcpy(arp->sha, netif->macaddr, sizeof(macaddr_t));\par
88     memset(arp->tha, 0, sizeof(macaddr_t));\par
89     memset(arp->spa, 0, sizeof(ipv4_t));\par
90     memset(arp->tpa, 0, sizeof(ipv4_t));\par
91 \par
92 #ifdef ARP_DEBUG\par
93     kprintf("arp: sending request for %s\\n", netif->name);\par
94 #endif\par
95 \par
96     int ret = eth_send(netif, arp, sizeof(arp_header_t), NETIF_ARP);\par
97     kfree(arp);\par
98     \par
99     return ret;\par
100 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v arp_cache\:arp.c}
{\xe \v arp.c\:arp_cache}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b list_t}* arp_cache = NULL}}
\par
{\bkmkstart AAAAAAAAZD}
{\bkmkend AAAAAAAAZD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 13 of file arp.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/net/eth.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/net/eth.c}
{\xe \v src/net/eth.c}
{\bkmkstart AAAAAAAAZE}
{\bkmkend AAAAAAAAZE}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <aplus.h>}\par
{\f2 #include <aplus/list.h>}\par
{\f2 #include <aplus/netif.h>}\par
{\f2 #include <stddef.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <aplus/net/eth.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b __params}\~ {\b netif}, (void*) (({\b uint32_t}) buf + sizeof(eth_header_t)), {\b length} - sizeof(eth_header_t)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b eth_recv} ({\b netif_t} *{\b netif}, void *buf, size_t {\b length})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b eth_send_packet} ({\b netif_t} *{\b netif}, void *buf, size_t {\b length}, int {\b type})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b eth_send} ({\b netif_t} *{\b netif}, void *buf, size_t {\b length}, int {\b type})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v __params\:eth.c}
{\xe \v eth.c\:__params}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define __params\~ {\b netif}, (void*) (({\b uint32_t}) buf + sizeof(eth_header_t)), {\b length} - sizeof(eth_header_t)}}
\par
{\bkmkstart AAAAAAAAZF}
{\bkmkend AAAAAAAAZF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v eth_recv\:eth.c}
{\xe \v eth.c\:eth_recv}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int eth_recv ({\b netif_t} * {\i netif}, void * {\i buf}, size_t {\i length})}}
\par
{\bkmkstart AAAAAAAAZG}
{\bkmkend AAAAAAAAZG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 11 of file eth.c.}\par
{
References __params, arp_recv(), ETH_TYPE_ARP, ETH_TYPE_IPV4, ETH_TYPE_IPV6, ipv4_recv(), ipv6_recv(), length, NETIF_ETH, netif_packets_add(), and netif_packets_create().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11                                                        \{\par
12     eth_header_t* ethpkt = (eth_header_t*) buf;\par
13 \par
14     #define __params    \\\par
15         netif, (void*) ((uint32_t) buf + sizeof(eth_header_t)), length - sizeof(eth_header_t)\par
16 \par
17     switch(ethpkt->type) \{\par
18         case ETH_TYPE_IPV4:\par
19             if(ipv4_recv(__params) == 0)\par
20                 return 0;\par
21             return length;\par
22 \par
23         case ETH_TYPE_IPV6:\par
24             if(ipv6_recv(__params) == 0)\par
25                 return 0;\par
26             return length;\par
27 \par
28         case ETH_TYPE_ARP:\par
29             if(arp_recv(__params) == 0)\par
30                 return 0;\par
31             return length;\par
32     \}\par
33 \par
34 \par
35     /* ETH_TYPE_RAW */\par
36     netif_packets_add (\par
37         netif_packets_create (\par
38                             netif,\par
39                             NETIF_ETH, \par
40                             length, \par
41                             sizeof(eth_header_t), \par
42                             buf\par
43         )\par
44     );\par
45     return length;\par
46 \}\par
}
}
{\xe \v eth_send\:eth.c}
{\xe \v eth.c\:eth_send}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int eth_send ({\b netif_t} * {\i netif}, void * {\i buf}, size_t {\i length}, int {\i type})}}
\par
{\bkmkstart AAAAAAAAZH}
{\bkmkend AAAAAAAAZH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 79 of file eth.c.}\par
{
References eth_send_packet(), length, netif::mtu, type, and uint32_t.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 79                                                                  \{\par
80 \par
81     if(length + sizeof(eth_header_t) < netif->mtu) \{\par
82         if(eth_send_packet(netif, buf, length, type) > 0)\par
83             return length;\par
84         else\par
85             return 0;\par
86     \}\par
87 \par
88     int delta = netif->mtu - sizeof(eth_header_t);\par
89     int ret = 0;\par
90 \par
91 \par
92     for(int i = 0; i < length; i += delta)\par
93         ret += eth_send_packet(netif, (void*) ((uint32_t) buf + i), delta, type);\par
94 \par
95     if((length % delta) != 0)\par
96         ret += eth_send_packet(netif, (void*) ((uint32_t) buf + length - (length % delta)), length % delta, type);\par
97     \par
98     \par
99     if(ret)\par
100         return length;\par
101     \par
102     return 0;\par
103 \}\par
}
}
{\xe \v eth_send_packet\:eth.c}
{\xe \v eth.c\:eth_send_packet}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int eth_send_packet ({\b netif_t} * {\i netif}, void * {\i buf}, size_t {\i length}, int {\i type}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAZI}
{\bkmkend AAAAAAAAZI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 49 of file eth.c.}\par
{
References ETH_TYPE_ARP, ETH_TYPE_IPV4, ETH_TYPE_IPV6, ETH_TYPE_RAW, kfree(), kmalloc(), netif::macaddr, NETIF_ARP, NETIF_ETH, NETIF_INET, NETIF_INET6, netif::send, and uint32_t.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 49                                                                                \{\par
50     eth_header_t* ethpkt = kmalloc(length + sizeof(eth_header_t));\par
51     memset((void*) ethpkt->dest, 0xFF, sizeof(macaddr_t));\par
52     memcpy((void*) ethpkt->source, (void*) netif->macaddr, sizeof(macaddr_t));\par
53     memcpy((void*) ((uint32_t) ethpkt + sizeof(eth_header_t)), buf, length);\par
54 \par
55     switch(type) \{\par
56         case NETIF_INET:\par
57             ethpkt->type = ETH_TYPE_IPV4;\par
58             break;\par
59         case NETIF_INET6:\par
60             ethpkt->type = ETH_TYPE_IPV6;\par
61             break;\par
62         case NETIF_ARP:\par
63             ethpkt->type = ETH_TYPE_ARP;\par
64             break;\par
65         default:\par
66             ethpkt->type = ETH_TYPE_RAW;\par
67             break;\par
68     \}\par
69 \par
70     \par
71     length += sizeof(eth_header_t);\par
72     \par
73     int ret = netif->send(netif, ethpkt, length, NETIF_ETH);\par
74     kfree(ethpkt);\par
75     \par
76     return ret;\par
77 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/net/ipv4.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/net/ipv4.c}
{\xe \v src/net/ipv4.c}
{\bkmkstart AAAAAAAAZJ}
{\bkmkend AAAAAAAAZJ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <aplus.h>}\par
{\f2 #include <aplus/list.h>}\par
{\f2 #include <aplus/netif.h>}\par
{\f2 #include <stddef.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <aplus/net/eth.h>}\par
{\f2 #include <aplus/net/ipv4.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b __params}\~ {\b netif}, (void*) (({\b uint32_t}) ip + {\b IPV4_HEADER_LENGTH}(ip)), {\b length} - {\b IPV4_HEADER_LENGTH}(ip)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b ipv4_checksum} (ipv4_header_t *pkt)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b ipv4_create_packet} ({\b netif_t} *{\b netif}, void *buf, size_t {\b length}, int {\b type}, {\b ipv4_t} {\b dest}, int fragment, int {\b offset})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ipv4_recv} ({\b netif_t} *{\b netif}, void *buf, size_t {\b length})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ipv4_send} ({\b netif_t} *{\b netif}, void *buf, size_t {\b length}, int {\b type}, {\b ipv4_t} {\b dest})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v __params\:ipv4.c}
{\xe \v ipv4.c\:__params}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define __params\~ {\b netif}, (void*) (({\b uint32_t}) ip + {\b IPV4_HEADER_LENGTH}(ip)), {\b length} - {\b IPV4_HEADER_LENGTH}(ip)}}
\par
{\bkmkstart AAAAAAAAZK}
{\bkmkend AAAAAAAAZK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v ipv4_checksum\:ipv4.c}
{\xe \v ipv4.c\:ipv4_checksum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} ipv4_checksum (ipv4_header_t * {\i pkt})}}
\par
{\bkmkstart AAAAAAAAZL}
{\bkmkend AAAAAAAAZL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 13 of file ipv4.c.}\par
{
References length, uint16_t, and uint8_t.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13                                            \{\par
14     int length = sizeof(ipv4_header_t);\par
15     int sum = 0;\par
16     uint8_t* buf = (uint8_t*) pkt;\par
17 \par
18     while(length > 1) \{\par
19         sum += 0xFFFF & *((uint16_t*) buf);\par
20         buf += sizeof(uint16_t);\par
21         length -= sizeof(uint16_t);\par
22     \}\par
23 \par
24     if(length)\par
25         sum += (0xFF & *buf) << 8;\par
26 \par
27     while(sum >> 16)\par
28         sum = (sum & 0xFFFF) + (sum >> 16);\par
29 \par
30     uint16_t cksum = ((uint16_t) sum ^ 0xFFFF);\par
31     return (((cksum & 0x00FF) << 8) | ((cksum & 0xFF00) >> 8)) & 0xFFFF;\par
32 \}\par
}
}
{\xe \v ipv4_create_packet\:ipv4.c}
{\xe \v ipv4.c\:ipv4_create_packet}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* ipv4_create_packet ({\b netif_t} * {\i netif}, void * {\i buf}, size_t {\i length}, int {\i type}, {\b ipv4_t} {\i dest}, int {\i fragment}, int {\i offset})}}
\par
{\bkmkstart AAAAAAAAZM}
{\bkmkend AAAAAAAAZM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 34 of file ipv4.c.}\par
{
References netif::ipv4, ipv4_checksum(), IPV4_FLAGS_MF, IPV4_MAX_LENGTH, IPV4_PROTO_ICMP, IPV4_PROTO_RAW, IPV4_PROTO_TCP, IPV4_PROTO_UDP, kmalloc(), NETIF_ICMP, NETIF_TCP, NETIF_UDP, offset, and uint32_t.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 34                                                                                                                     \{\par
35 \par
36     ipv4_header_t* ip = (ipv4_header_t*) kmalloc(length + sizeof(ipv4_header_t));\par
37     ip->info = (((sizeof(ipv4_header_t) >> 2) & 0xF) << 4) | 4; /* length: 20 byte; Version: ipv4; */\par
38     ip->tos = 0;\par
39     ip->length = length + sizeof(ipv4_header_t);\par
40     ip->id = 0;\par
41     ip->ttl = 0xFF;\par
42 \par
43     if(fragment == -1)\par
44         ip->offset = offset;\par
45     else\par
46         ip->offset = IPV4_FLAGS_MF | (offset * IPV4_MAX_LENGTH);\par
47 \par
48     switch(type) \{\par
49         case NETIF_UDP:\par
50             ip->protocol = IPV4_PROTO_UDP;\par
51             break;\par
52         case NETIF_TCP:\par
53             ip->protocol = IPV4_PROTO_TCP;\par
54             break;\par
55         case NETIF_ICMP:\par
56             ip->protocol = IPV4_PROTO_ICMP;\par
57             break;\par
58         default:\par
59             ip->protocol = IPV4_PROTO_RAW;\par
60             break;\par
61     \}\par
62 \par
63     memcpy(ip->source, netif->ipv4, sizeof(ipv4_t));\par
64     memcpy(ip->dest, dest, sizeof(ipv4_t));\par
65     memcpy((void*) ((uint32_t) ip + sizeof(ipv4_header_t)), buf, length);\par
66 \par
67     ip->checksum = ipv4_checksum(ip);\par
68     return (void*) ip;\par
69 \}\par
}
}
{\xe \v ipv4_recv\:ipv4.c}
{\xe \v ipv4.c\:ipv4_recv}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ipv4_recv ({\b netif_t} * {\i netif}, void * {\i buf}, size_t {\i length})}}
\par
{\bkmkstart AAAAAAAAZN}
{\bkmkend AAAAAAAAZN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 71 of file ipv4.c.}\par
{
References __params, IPV4_CHECK_VERSION, IPV4_FLAGS, IPV4_FLAGS_MF, IPV4_HEADER_LENGTH, IPV4_PROTO_ICMP, IPV4_PROTO_TCP, IPV4_PROTO_UDP, kprintf(), length, NETIF_INET, netif_packets_add(), netif_packets_create(), panic(), and udp_recv().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 71                                                         \{\par
72     ipv4_header_t* ip = (ipv4_header_t*) buf;\par
73 \par
74     if(IPV4_CHECK_VERSION(ip) == 0)\par
75         return 0;\par
76 \par
77     if(IPV4_FLAGS(ip) & IPV4_FLAGS_MF)\par
78         panic("ipv4: packet fragmentation not supported in recv mode");\par
79 \par
80 \par
81     #define __params    \\\par
82         netif, (void*) ((uint32_t) ip + IPV4_HEADER_LENGTH(ip)), length - IPV4_HEADER_LENGTH(ip)\par
83 \par
84     switch(ip->protocol) \{\par
85         case IPV4_PROTO_UDP:\par
86             if(udp_recv(__params) == 0)\par
87                 return 0;\par
88             return length;\par
89         \par
90         case IPV4_PROTO_TCP:\par
91             //if(tcp_recv(__params) == 0)       /* Support for TCP ?? -> pfff.. \'F9.\'F9 */\par
92             //  return 0;\par
93             return length;\par
94 \par
95         case IPV4_PROTO_ICMP:\par
96             //if(icmp_recv(__params) == 0)\par
97             //  return 0;\par
98             return length;\par
99     \}\par
100 \par
101     /* IPV4_PROTO_RAW */\par
102     netif_packets_add (\par
103         netif_packets_create (\par
104                             netif,\par
105                             NETIF_INET, \par
106                             length, \par
107                             IPV4_HEADER_LENGTH(ip), \par
108                             buf\par
109         )\par
110     );\par
111 \par
112     kprintf("ok\\n");\par
113     return length;\par
114 \}\par
}
}
{\xe \v ipv4_send\:ipv4.c}
{\xe \v ipv4.c\:ipv4_send}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ipv4_send ({\b netif_t} * {\i netif}, void * {\i buf}, size_t {\i length}, int {\i type}, {\b ipv4_t} {\i dest})}}
\par
{\bkmkstart AAAAAAAAZO}
{\bkmkend AAAAAAAAZO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 116 of file ipv4.c.}\par
{
References eth_send(), ipv4_create_packet(), IPV4_MAX_LENGTH, kfree(), length, NETIF_INET, and uint32_t.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 116                                                                                \{\par
117     if(length < IPV4_MAX_LENGTH) \{\par
118         void* pkt = ipv4_create_packet(netif, buf, length, type, dest, -1, 0);\par
119         int ret = eth_send(netif, pkt, length + sizeof(ipv4_header_t), NETIF_INET);\par
120         kfree(pkt);\par
121 \par
122         if(ret)\par
123             return length;\par
124     \par
125         return 0;\par
126     \}\par
127 \par
128     int ret = 0;\par
129     int i = 0;\par
130     int max = length / IPV4_MAX_LENGTH;\par
131 \par
132     if(length % IPV4_MAX_LENGTH == 0)\par
133         max -= 1;\par
134 \par
135     for(i = 0; i < max; i++) \{\par
136         void* pkt = ipv4_create_packet(netif, (void*) ((uint32_t) buf + (i * IPV4_MAX_LENGTH)), IPV4_MAX_LENGTH, type, dest, 0, i);\par
137         ret += eth_send(netif, pkt, IPV4_MAX_LENGTH, NETIF_INET);\par
138         kfree(pkt);\par
139     \}\par
140 \par
141 \par
142     void* pkt = ipv4_create_packet(netif, (void*) ((uint32_t) buf + (i * IPV4_MAX_LENGTH)), length - ((i - 1) * IPV4_MAX_LENGTH), type, dest, -1, i);\par
143     ret += eth_send(netif, pkt, IPV4_MAX_LENGTH, NETIF_INET);\par
144     kfree(pkt);\par
145 \par
146     if(ret)\par
147         return length;\par
148     \par
149     return 0;\par
150 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/net/ipv6.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/net/ipv6.c}
{\xe \v src/net/ipv6.c}
{\bkmkstart AAAAAAAAZP}
{\bkmkend AAAAAAAAZP}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <aplus.h>}\par
{\f2 #include <aplus/list.h>}\par
{\f2 #include <aplus/netif.h>}\par
{\f2 #include <stddef.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <aplus/net/eth.h>}\par
{\f2 #include <aplus/net/ipv6.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b __params}\~ {\b netif}, (void*) (({\b uint32_t}) ip + sizeof(ipv6_header_t)), {\b length} - sizeof(ipv6_header_t)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ipv6_recv} ({\b netif_t} *{\b netif}, void *buf, size_t {\b length}, int {\b type})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ipv6_send} ({\b netif_t} *{\b netif}, void *buf, size_t {\b length}, int {\b type}, {\b ipv6_t} {\b dest})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v __params\:ipv6.c}
{\xe \v ipv6.c\:__params}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define __params\~ {\b netif}, (void*) (({\b uint32_t}) ip + sizeof(ipv6_header_t)), {\b length} - sizeof(ipv6_header_t)}}
\par
{\bkmkstart AAAAAAAAZQ}
{\bkmkend AAAAAAAAZQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v ipv6_recv\:ipv6.c}
{\xe \v ipv6.c\:ipv6_recv}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ipv6_recv ({\b netif_t} * {\i netif}, void * {\i buf}, size_t {\i length}, int {\i type})}}
\par
{\bkmkstart AAAAAAAAZR}
{\bkmkend AAAAAAAAZR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 14 of file ipv6.c.}\par
{
References IPV6_CHECK_VERSION, IPV6_PROTO_ICMP, IPV6_PROTO_TCP, IPV6_PROTO_UDP, length, NETIF_INET6, netif_packets_add(), and netif_packets_create().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14                                                                   \{\par
15     ipv6_header_t* ip = (ipv6_header_t*) buf;\par
16     \par
17     if(IPV6_CHECK_VERSION(ip) == 0)\par
18         return 0;\par
19 \par
20 \par
21     #define __params    \\\par
22         netif, (void*) ((uint32_t) ip + sizeof(ipv6_header_t)), length - sizeof(ipv6_header_t)\par
23 \par
24     switch(ip->protocol) \{\par
25         case IPV6_PROTO_UDP:\par
26             //if(udp_recv(__params) == 0)\par
27             //  return 0;\par
28             return length;\par
29         \par
30         case IPV6_PROTO_TCP:\par
31             //if(tcp_recv(__params) == 0)       /* Support for TCP ?? -> pfff.. \'F9.\'F9 */\par
32             //  return 0;\par
33             return length;\par
34 \par
35         case IPV6_PROTO_ICMP:\par
36             //if(icmp_recv(__params) == 0)\par
37             //  return 0;\par
38             return length;\par
39     \}\par
40 \par
41     /* IPV6_PROTO_RAW */\par
42     netif_packets_add (\par
43         netif_packets_create (\par
44                             netif,\par
45                             NETIF_INET6, \par
46                             length, \par
47                             sizeof(ipv6_header_t), \par
48                             buf\par
49         )\par
50     );\par
51 \par
52     return length;\par
53 \}\par
}
}
{\xe \v ipv6_send\:ipv6.c}
{\xe \v ipv6.c\:ipv6_send}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ipv6_send ({\b netif_t} * {\i netif}, void * {\i buf}, size_t {\i length}, int {\i type}, {\b ipv6_t} {\i dest})}}
\par
{\bkmkstart AAAAAAAAZS}
{\bkmkend AAAAAAAAZS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 55 of file ipv6.c.}\par
{
References eth_send(), netif::ipv6, IPV6_PROTO_ICMP, IPV6_PROTO_RAW, IPV6_PROTO_TCP, IPV6_PROTO_UDP, kfree(), kmalloc(), length, NETIF_ICMP, NETIF_INET6, NETIF_TCP, NETIF_UDP, and uint32_t.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 55                                                                                \{\par
56     ipv6_header_t* ip = (ipv6_header_t*) kmalloc(length + sizeof(ipv6_header_t));\par
57     ip->version = 6;\par
58     ip->traffic = 0;\par
59     ip->flow = 0;\par
60     ip->length = length;\par
61     ip->ttl = 0xFF;\par
62     \par
63     switch(type) \{\par
64         case NETIF_UDP:\par
65             ip->protocol = IPV6_PROTO_UDP;\par
66             break;\par
67         case NETIF_TCP:\par
68             ip->protocol = IPV6_PROTO_TCP;\par
69             break;\par
70         case NETIF_ICMP:\par
71             ip->protocol = IPV6_PROTO_ICMP;\par
72             break;\par
73         default:\par
74             ip->protocol = IPV6_PROTO_RAW;\par
75             break;\par
76     \}\par
77 \par
78     memcpy(ip->dest, dest, sizeof(ipv6_t));\par
79     memcpy(ip->source, netif->ipv6, sizeof(ipv6_t));\par
80     memcpy((void*) ((uint32_t) ip + sizeof(ipv6_header_t)), buf, length);\par
81 \par
82     int ret = eth_send(netif, (void*) ip, length + sizeof(ipv6_header_t), NETIF_INET6);\par
83     kfree(ip);\par
84 \par
85     if(ret)\par
86         return length;\par
87     \par
88     return 0;\par
89 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/net/loopback/loopback.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/net/loopback/loopback.c}
{\xe \v src/net/loopback/loopback.c}
{\bkmkstart AAAAAAAAZT}
{\bkmkend AAAAAAAAZT}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <aplus.h>}\par
{\f2 #include <aplus/netif.h>}\par
{\f2 #include <aplus/bufio.h>}\par
{\f2 #include <aplus/mm.h>}\par
{\f2 #include <aplus/task.h>}\par
{\f2 #include <aplus/spinlock.h>}\par
{\f2 #include <aplus/list.h>}\par
{\f2 #include <aplus/attribute.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <errno.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b LOOPBACK_MAGIC}\~ 0x127001FF\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b LOOPBACK_MTU}\~ 65563\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b loopback_ifup} ({\b netif_t} *{\b netif})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b loopback_ifdown} ({\b netif_t} *{\b netif})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b loopback_recv} ({\b netif_t} *{\b netif}, void *buf, size_t len)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b loopback_send} ({\b netif_t} *{\b netif}, void *buf, size_t len, int {\b type})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b loopback_init} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ATTRIBUTE} ("netif", loopback_init)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v LOOPBACK_MAGIC\:loopback.c}
{\xe \v loopback.c\:LOOPBACK_MAGIC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define LOOPBACK_MAGIC\~ 0x127001FF}}
\par
{\bkmkstart AAAAAAAAZU}
{\bkmkend AAAAAAAAZU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 15 of file loopback.c.}\par
}
{\xe \v LOOPBACK_MTU\:loopback.c}
{\xe \v loopback.c\:LOOPBACK_MTU}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define LOOPBACK_MTU\~ 65563}}
\par
{\bkmkstart AAAAAAAAZV}
{\bkmkend AAAAAAAAZV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 16 of file loopback.c.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v ATTRIBUTE\:loopback.c}
{\xe \v loopback.c\:ATTRIBUTE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ATTRIBUTE ("netif" , {\b loopback_init} )}}
\par
{\bkmkstart AAAAAAAAZW}
{\bkmkend AAAAAAAAZW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v loopback_ifdown\:loopback.c}
{\xe \v loopback.c\:loopback_ifdown}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int loopback_ifdown ({\b netif_t} * {\i netif})}}
\par
{\bkmkstart AAAAAAAAZX}
{\bkmkend AAAAAAAAZX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 24 of file loopback.c.}\par
{
References netif::flags, and NETIF_FLAGS_ENABLE.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 24                                     \{\par
25     netif->flags &= ~NETIF_FLAGS_ENABLE;\par
26     return 0;\par
27 \}\par
}
}
{\xe \v loopback_ifup\:loopback.c}
{\xe \v loopback.c\:loopback_ifup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int loopback_ifup ({\b netif_t} * {\i netif})}}
\par
{\bkmkstart AAAAAAAAZY}
{\bkmkend AAAAAAAAZY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 19 of file loopback.c.}\par
{
References netif::flags, and NETIF_FLAGS_ENABLE.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19                                   \{\par
20     netif->flags |= NETIF_FLAGS_ENABLE;\par
21     return 0;\par
22 \}\par
}
}
{\xe \v loopback_init\:loopback.c}
{\xe \v loopback.c\:loopback_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int loopback_init ()}}
\par
{\bkmkstart AAAAAAAAZZ}
{\bkmkend AAAAAAAAZZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 65 of file loopback.c.}\par
{
References netif::data, netif::ifdown, netif::ifup, netif::ipv4, netif::ipv6, kmalloc(), loopback_ifdown(), loopback_ifup(), LOOPBACK_MTU, loopback_send(), netif::macaddr, netif::mtu, netif::name, netif_add(), netif::netmask, and netif::send.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 65                     \{\par
66 \par
67     netif_t* netif = (netif_t*) kmalloc(sizeof(netif_t));\par
68     memset(netif, 0, sizeof(netif_t));\par
69 \par
70 \par
71     strcpy(netif->name, "lo");\par
72     memset(netif->macaddr, 0xFF, sizeof(macaddr_t));\par
73 \par
74     netif->ipv4[0] = 127;\par
75     netif->ipv4[1] = 0;\par
76     netif->ipv4[2] = 0;\par
77     netif->ipv4[3] = 1;\par
78 \par
79     netif->ipv6[0] = 0;\par
80     netif->ipv6[1] = 0;\par
81     netif->ipv6[2] = 0;\par
82     netif->ipv6[3] = 0;\par
83     netif->ipv6[4] = 0;\par
84     netif->ipv6[5] = 0;\par
85     netif->ipv6[6] = 0;\par
86     netif->ipv6[7] = 1;\par
87 \par
88     netif->netmask[0] = 255;\par
89     netif->netmask[1] = 255;\par
90     netif->netmask[2] = 255;\par
91     netif->netmask[3] = 255;\par
92 \par
93 \par
94     netif->mtu = LOOPBACK_MTU;\par
95     netif->send = loopback_send;\par
96     netif->ifup = loopback_ifup;\par
97     netif->ifdown = loopback_ifdown;\par
98     netif->data = NULL;\par
99 \par
100     netif_add(netif);\par
101     return 0;\par
102 \}\par
}
}
{\xe \v loopback_recv\:loopback.c}
{\xe \v loopback.c\:loopback_recv}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int loopback_recv ({\b netif_t} * {\i netif}, void * {\i buf}, size_t {\i len})}}
\par
{\bkmkstart AAAAAAABAA}
{\bkmkend AAAAAAABAA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 31 of file loopback.c.}\par
{
References eth_recv(), netif::flags, NETIF_FLAGS_ENABLE, netif::rx_bytes, netif::rx_errors, netif::rx_packets, and netif::state.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 31                                                          \{\par
32     if((netif->flags & NETIF_FLAGS_ENABLE) == 0)\par
33         return 0;\par
34 \par
35     if(eth_recv(netif, buf, len) > 0) \{\par
36         netif->state.rx_packets += 1;\par
37         netif->state.rx_bytes += len;\par
38 \par
39         return len;\par
40     \}\par
41         \par
42     netif->state.rx_errors += 1;\par
43     return 0;\par
44 \}\par
}
}
{\xe \v loopback_send\:loopback.c}
{\xe \v loopback.c\:loopback_send}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int loopback_send ({\b netif_t} * {\i netif}, void * {\i buf}, size_t {\i len}, int {\i type})}}
\par
{\bkmkstart AAAAAAABAB}
{\bkmkend AAAAAAABAB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 46 of file loopback.c.}\par
{
References netif::flags, LOOPBACK_MTU, loopback_recv(), NETIF_FLAGS_ENABLE, netif::state, netif::tx_bytes, netif::tx_errors, and netif::tx_packets.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 46                                                                    \{\par
47     if((netif->flags & NETIF_FLAGS_ENABLE) == 0)\par
48         return 0;\par
49 \par
50     if(len > LOOPBACK_MTU) \{\par
51         netif->state.tx_errors += 1;\par
52         return 0;\par
53     \}\par
54 \par
55 \par
56     netif->state.tx_packets += 1;\par
57     netif->state.tx_bytes += len;\par
58 \par
59 \par
60     loopback_recv(netif, buf, len); \par
61     return len;\par
62 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/net/netif.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/net/netif.c}
{\xe \v src/net/netif.c}
{\bkmkstart AAAAAAABAC}
{\bkmkend AAAAAAABAC}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <aplus.h>}\par
{\f2 #include <aplus/list.h>}\par
{\f2 #include <aplus/netif.h>}\par
{\f2 #include <aplus/attribute.h>}\par
{\f2 #include <stddef.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <aplus/net/arp.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b netif_htonl} ({\b uint32_t} h)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b netif_htons} ({\b uint16_t} h)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b netif_ntohl} ({\b uint32_t} h)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32_t} {\b netif_ntohs} ({\b uint32_t} h)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b netif_t} * {\b netif_find_by_ipv4} ({\b ipv4_t} *ipv4)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b netif_t} * {\b netif_find_by_ipv6} ({\b ipv6_t} *ipv6)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b netif_t} * {\b netif_find_by_macaddr} ({\b macaddr_t} *macaddr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b netif_t} * {\b netif_find_by_name} (char *{\b name})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b netif_ifup} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b netif_ifdown} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b netif_add} ({\b netif_t} *netdev)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b netif_remove} ({\b netif_t} *netdev)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b netif_init} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b netif_packets_add} ({\b netif_packet_t} *packet)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b netif_packets_remove} ({\b netif_packet_t} *packet)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b netif_packet_t} * {\b netif_packets_find_by_id} (uint64_t {\b id})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b list_t} * {\b netif_packets_find_by_protocol} (int {\b protocol})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b netif_packet_t} * {\b netif_packets_create} ({\b netif_t} *{\b netif}, int {\b protocol}, int tot_length, int head_length, void *{\b data})\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b list_t} * {\b lst_netif} = NULL\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b list_t} * {\b lst_packets} = NULL\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v netif_add\:netif.c}
{\xe \v netif.c\:netif_add}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int netif_add ({\b netif_t} * {\i netdev})}}
\par
{\bkmkstart AAAAAAABAD}
{\bkmkend AAAAAAABAD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 124 of file netif.c.}\par
{
References netif::dns, netif::ipv4, netif::ipv6, kprintf(), list_add(), list_init, netif::macaddr, netif::mtu, netif::name, netif_find_by_ipv4(), netif_find_by_ipv6(), netif_find_by_macaddr(), netif::netmask, netif::primary, and netif::secondary.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 124                                \{\par
125     if(lst_netif == NULL) \{\par
126         list_init(lst_netif);\par
127     \}\par
128 \par
129 \par
130     if(netif_find_by_ipv4(&netdev->ipv4) != NULL) \{\par
131         kprintf("netif: conflitto di ipv4\\n");\par
132         return -1;\par
133     \}\par
134 \par
135     if(netif_find_by_ipv6(&netdev->ipv6) != NULL) \{\par
136         kprintf("netif: conflitto di ipv6\\n");\par
137         return -1;\par
138     \}\par
139 \par
140 \par
141     if(netif_find_by_macaddr(&netdev->macaddr) != NULL) \{\par
142         kprintf("netif: conflitto di macaddr\\n");\par
143         return -1;\par
144     \}\par
145 \par
146 \par
147 \par
148     kprintf("\\n%s:\\tipv4\\t%d.%d.%d.%d\\n\\tnetmask\\t%d.%d.%d.%d\\n",\par
149             netdev->name,\par
150             netdev->ipv4[0],\par
151             netdev->ipv4[1],\par
152             netdev->ipv4[2],\par
153             netdev->ipv4[3],\par
154             netdev->netmask[0],\par
155             netdev->netmask[1],\par
156             netdev->netmask[2],\par
157             netdev->netmask[3]\par
158     );\par
159 \par
160     kprintf("\\tipv6\\t%04x:%04x:%04x:%04x:%04x:%04x:%04x:%04x\\n",\par
161             netdev->ipv6[0],\par
162             netdev->ipv6[1],\par
163             netdev->ipv6[2],\par
164             netdev->ipv6[3],\par
165             netdev->ipv6[4],\par
166             netdev->ipv6[5],\par
167             netdev->ipv6[6],\par
168             netdev->ipv6[7]\par
169     );\par
170 \par
171     kprintf("\\tmacaddr\\t%02x:%02x:%02x:%02x:%02x:%02x\\n\\tmtu\\t%d bytes\\n",\par
172             netdev->macaddr[0],\par
173             netdev->macaddr[1],\par
174             netdev->macaddr[2],\par
175             netdev->macaddr[3],\par
176             netdev->macaddr[4],\par
177             netdev->macaddr[5],\par
178             netdev->mtu\par
179     );\par
180 \par
181     kprintf("\\tdns\\t%d.%d.%d.%d\\n\\t\\t%d.%d.%d.%d\\n",\par
182             netdev->dns.primary.ipv4[0],\par
183             netdev->dns.primary.ipv4[1],\par
184             netdev->dns.primary.ipv4[2],\par
185             netdev->dns.primary.ipv4[3],\par
186             netdev->dns.secondary.ipv4[0],\par
187             netdev->dns.secondary.ipv4[1],\par
188             netdev->dns.secondary.ipv4[2],\par
189             netdev->dns.secondary.ipv4[3]\par
190     );\par
191 \par
192     kprintf("\\t\\t%04x:%04x:%04x:%04x:%04x:%04x:%04x:%04x\\n\\t\\t%04x:%04x:%04x:%04x:%04x:%04x:%04x:%04x\\n",\par
193             netdev->dns.primary.ipv6[0],\par
194             netdev->dns.primary.ipv6[1],\par
195             netdev->dns.primary.ipv6[2],\par
196             netdev->dns.primary.ipv6[3],\par
197             netdev->dns.primary.ipv6[4],\par
198             netdev->dns.primary.ipv6[5],\par
199             netdev->dns.primary.ipv6[6],\par
200             netdev->dns.primary.ipv6[7],\par
201             netdev->dns.secondary.ipv6[0],\par
202             netdev->dns.secondary.ipv6[1],\par
203             netdev->dns.secondary.ipv6[2],\par
204             netdev->dns.secondary.ipv6[3],\par
205             netdev->dns.secondary.ipv6[4],\par
206             netdev->dns.secondary.ipv6[5],\par
207             netdev->dns.secondary.ipv6[6],\par
208             netdev->dns.secondary.ipv6[7]\par
209     );\par
210 \par
211     return list_add(lst_netif, (listval_t) netdev);\par
212 \}\par
}
}
{\xe \v netif_find_by_ipv4\:netif.c}
{\xe \v netif.c\:netif_find_by_ipv4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b netif_t}* netif_find_by_ipv4 ({\b ipv4_t} * {\i ipv4})}}
\par
{\bkmkstart AAAAAAABAE}
{\bkmkend AAAAAAABAE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 36 of file netif.c.}\par
{
References netif::ipv4, list_foreach, and value.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 36                                           \{\par
37     if(lst_netif == NULL)\par
38         return NULL;\par
39 \par
40     list_foreach(value, lst_netif) \{\par
41         netif_t* netif = (netif_t*) value;\par
42 \par
43         if(memcmp(netif->ipv4, ipv4, sizeof(ipv4_t)) == 0)\par
44             return netif;\par
45     \}\par
46 \par
47     return NULL;\par
48 \}\par
}
}
{\xe \v netif_find_by_ipv6\:netif.c}
{\xe \v netif.c\:netif_find_by_ipv6}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b netif_t}* netif_find_by_ipv6 ({\b ipv6_t} * {\i ipv6})}}
\par
{\bkmkstart AAAAAAABAF}
{\bkmkend AAAAAAABAF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 50 of file netif.c.}\par
{
References netif::ipv6, list_foreach, and value.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 50                                           \{\par
51     if(lst_netif == NULL)\par
52         return NULL;\par
53 \par
54     list_foreach(value, lst_netif) \{\par
55         netif_t* netif = (netif_t*) value;\par
56 \par
57         if(memcmp(netif->ipv6, ipv6, sizeof(ipv6_t)) == 0)\par
58             return netif;\par
59     \}\par
60 \par
61     return NULL;\par
62 \}\par
}
}
{\xe \v netif_find_by_macaddr\:netif.c}
{\xe \v netif.c\:netif_find_by_macaddr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b netif_t}* netif_find_by_macaddr ({\b macaddr_t} * {\i macaddr})}}
\par
{\bkmkstart AAAAAAABAG}
{\bkmkend AAAAAAABAG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 66 of file netif.c.}\par
{
References list_foreach, netif::macaddr, and value.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 66                                                    \{\par
67     if(lst_netif == NULL)\par
68         return NULL;\par
69 \par
70     list_foreach(value, lst_netif) \{\par
71         netif_t* netif = (netif_t*) value;\par
72 \par
73         if(memcmp(netif->macaddr, macaddr, sizeof(macaddr_t)) == 0)\par
74             return netif;\par
75     \}\par
76 \par
77     return NULL;\par
78 \}\par
}
}
{\xe \v netif_find_by_name\:netif.c}
{\xe \v netif.c\:netif_find_by_name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b netif_t}* netif_find_by_name (char * {\i name})}}
\par
{\bkmkstart AAAAAAABAH}
{\bkmkend AAAAAAABAH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 80 of file netif.c.}\par
{
References list_foreach, netif::name, and value.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 80                                         \{\par
81     if(lst_netif == NULL)\par
82         return NULL;\par
83 \par
84     list_foreach(value, lst_netif) \{\par
85         netif_t* netif = (netif_t*) value;\par
86 \par
87         if(strcmp(netif->name, name) == 0)\par
88             return netif;\par
89     \}\par
90 \par
91     return NULL;\par
92 \}\par
}
}
{\xe \v netif_htonl\:netif.c}
{\xe \v netif.c\:netif_htonl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} netif_htonl ({\b uint32_t} {\i h})}}
\par
{\bkmkstart AAAAAAABAI}
{\bkmkend AAAAAAABAI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 18 of file netif.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18                                  \{\par
19     return ((h & 0xFF000000) >> 24) | ((h & 0x000000FF) << 24) |\par
20             ((h & 0x00FF0000) >> 8) | ((h & 0x0000FF00) << 8);\par
21 \}\par
}
}
{\xe \v netif_htons\:netif.c}
{\xe \v netif.c\:netif_htons}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} netif_htons ({\b uint16_t} {\i h})}}
\par
{\bkmkstart AAAAAAABAJ}
{\bkmkend AAAAAAABAJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 23 of file netif.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 23                                  \{\par
24     return ((h & 0xFF00) >> 8) | ((h & 0x00FF) << 8);\par
25 \}\par
}
}
{\xe \v netif_ifdown\:netif.c}
{\xe \v netif.c\:netif_ifdown}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int netif_ifdown ()}}
\par
{\bkmkstart AAAAAAABAK}
{\bkmkend AAAAAAABAK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 110 of file netif.c.}\par
{
References netif::ifdown, list_foreach, and value.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 110                    \{\par
111     if(lst_netif == NULL)\par
112         return -1;\par
113 \par
114     list_foreach(value, lst_netif) \{\par
115         netif_t* netif = (netif_t*) value;\par
116 \par
117         if(netif->ifdown)\par
118             netif->ifdown(netif);\par
119     \}\par
120 \par
121     return -1;\par
122 \}\par
}
}
{\xe \v netif_ifup\:netif.c}
{\xe \v netif.c\:netif_ifup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int netif_ifup ()}}
\par
{\bkmkstart AAAAAAABAL}
{\bkmkend AAAAAAABAL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 94 of file netif.c.}\par
{
References arp_send(), netif::ifup, list_foreach, and value.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 94                  \{\par
95     if(lst_netif == NULL)\par
96         return -1;\par
97 \par
98     list_foreach(value, lst_netif) \{\par
99         netif_t* netif = (netif_t*) value;\par
100 \par
101         if(netif->ifup)\par
102             netif->ifup(netif);\par
103 \par
104         arp_send(netif);\par
105     \}\par
106 \par
107     return -1;\par
108 \}\par
}
}
{\xe \v netif_init\:netif.c}
{\xe \v netif.c\:netif_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int netif_init ()}}
\par
{\bkmkstart AAAAAAABAM}
{\bkmkend AAAAAAABAM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 221 of file netif.c.}\par
{
References attribute(), list_destroy, list_empty(), list_foreach, list_init, netif_ifup(), and value.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 221                  \{\par
222     list_init(lst_packets);\par
223 \par
224     list_t* lst_netif = attribute("netif");\par
225     if(list_empty(lst_netif))\par
226         return -1;\par
227 \par
228     list_foreach(value, lst_netif) \{\par
229         int (*handler) () = (int (*) ()) value;\par
230 \par
231         if(handler)\par
232             handler();\par
233     \}\par
234     \par
235     list_destroy(lst_netif);\par
236 \par
237     netif_ifup();\par
238     return 0;\par
239 \}\par
}
}
{\xe \v netif_ntohl\:netif.c}
{\xe \v netif.c\:netif_ntohl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} netif_ntohl ({\b uint32_t} {\i h})}}
\par
{\bkmkstart AAAAAAABAN}
{\bkmkend AAAAAAABAN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 27 of file netif.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 27                                  \{\par
28     return ((h & 0xFF000000) >> 24) | ((h & 0x000000FF) << 24) |\par
29             ((h & 0x00FF0000) >> 8) | ((h & 0x0000FF00) << 8);\par
30 \}\par
}
}
{\xe \v netif_ntohs\:netif.c}
{\xe \v netif.c\:netif_ntohs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32_t} netif_ntohs ({\b uint32_t} {\i h})}}
\par
{\bkmkstart AAAAAAABAO}
{\bkmkend AAAAAAABAO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 32 of file netif.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 32                                  \{\par
33     return ((h & 0xFF00) >> 8) | ((h & 0x00FF) << 8);\par
34 \}\par
}
}
{\xe \v netif_packets_add\:netif.c}
{\xe \v netif.c\:netif_packets_add}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int netif_packets_add ({\b netif_packet_t} * {\i packet})}}
\par
{\bkmkstart AAAAAAABAP}
{\bkmkend AAAAAAABAP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 242 of file netif.c.}\par
{
References netif_packet::id, and list_add().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 242                                               \{\par
243     static uint64_t nextid = 0;\par
244     \par
245     packet->id = nextid++;\par
246     return list_add(lst_packets, (listval_t) packet);\par
247 \}\par
}
}
{\xe \v netif_packets_create\:netif.c}
{\xe \v netif.c\:netif_packets_create}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b netif_packet_t}* netif_packets_create ({\b netif_t} * {\i netif}, int {\i protocol}, int {\i tot_length}, int {\i head_length}, void * {\i data})}}
\par
{\bkmkstart AAAAAAABAQ}
{\bkmkend AAAAAAABAQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 279 of file netif.c.}\par
{
References netif_packet::data, netif_packet::header, kmalloc(), netif_packet::length, netif_packet::netif, protocol, netif_packet::protocol, and uint32_t.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 279                                                                                                                 \{\par
280     netif_packet_t* pkt = (netif_packet_t*) kmalloc(sizeof(netif_packet_t) + tot_length);\par
281     pkt->netif = netif;\par
282     pkt->protocol = protocol;\par
283     pkt->length = tot_length - head_length;\par
284     \par
285     memcpy(pkt->header, data, head_length);\par
286     memcpy(pkt->data, (void*) ((uint32_t) data + head_length), pkt->length);\par
287 \par
288     return pkt;\par
289 \}\par
}
}
{\xe \v netif_packets_find_by_id\:netif.c}
{\xe \v netif.c\:netif_packets_find_by_id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b netif_packet_t}* netif_packets_find_by_id (uint64_t {\i id})}}
\par
{\bkmkstart AAAAAAABAR}
{\bkmkend AAAAAAABAR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 253 of file netif.c.}\par
{
References netif_packet::id, list_foreach, and value.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 253                                                       \{\par
254     list_foreach(value, lst_packets) \{\par
255         netif_packet_t* pkt = (netif_packet_t*) value;\par
256 \par
257         if(pkt->id == id)\par
258             return pkt;\par
259     \}\par
260 \par
261     return NULL;\par
262 \}\par
}
}
{\xe \v netif_packets_find_by_protocol\:netif.c}
{\xe \v netif.c\:netif_packets_find_by_protocol}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b list_t}* netif_packets_find_by_protocol (int {\i protocol})}}
\par
{\bkmkstart AAAAAAABAS}
{\bkmkend AAAAAAABAS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 264 of file netif.c.}\par
{
References list_add(), list_foreach, list_init, netif_packet::protocol, and value.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 264                                                      \{\par
265     list_t* tmp = NULL;\par
266     list_init(tmp);\par
267 \par
268 \par
269     list_foreach(value, lst_packets) \{\par
270         netif_packet_t* pkt = (netif_packet_t*) value;\par
271 \par
272         if(pkt->protocol == protocol)\par
273             list_add(tmp, (listval_t) pkt);\par
274     \}\par
275 \par
276     return tmp;\par
277 \}\par
}
}
{\xe \v netif_packets_remove\:netif.c}
{\xe \v netif.c\:netif_packets_remove}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int netif_packets_remove ({\b netif_packet_t} * {\i packet})}}
\par
{\bkmkstart AAAAAAABAT}
{\bkmkend AAAAAAABAT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 249 of file netif.c.}\par
{
References list_remove().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 249                                                  \{\par
250     return list_remove(lst_packets, (listval_t) packet);\par
251 \}\par
}
}
{\xe \v netif_remove\:netif.c}
{\xe \v netif.c\:netif_remove}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int netif_remove ({\b netif_t} * {\i netdev})}}
\par
{\bkmkstart AAAAAAABAU}
{\bkmkend AAAAAAABAU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 214 of file netif.c.}\par
{
References list_remove().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 214                                   \{\par
215     if(lst_netif == NULL)\par
216         return -1;\par
217 \par
218     return list_remove(lst_netif, (listval_t) netdev);\par
219 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v lst_netif\:netif.c}
{\xe \v netif.c\:lst_netif}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b list_t}* lst_netif = NULL{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABAV}
{\bkmkend AAAAAAABAV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 13 of file netif.c.}\par
}
{\xe \v lst_packets\:netif.c}
{\xe \v netif.c\:lst_packets}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b list_t}* lst_packets = NULL{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABAW}
{\bkmkend AAAAAAABAW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 14 of file netif.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/net/rtl8139/rtl8139.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/net/rtl8139/rtl8139.c}
{\xe \v src/net/rtl8139/rtl8139.c}
{\bkmkstart AAAAAAABAX}
{\bkmkend AAAAAAABAX}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <aplus.h>}\par
{\f2 #include <aplus/netif.h>}\par
{\f2 #include <aplus/bufio.h>}\par
{\f2 #include <aplus/mm.h>}\par
{\f2 #include <aplus/task.h>}\par
{\f2 #include <aplus/spinlock.h>}\par
{\f2 #include <aplus/list.h>}\par
{\f2 #include <aplus/attribute.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <errno.h>}\par
{\f2 #include <aplus/net/eth.h>}\par
{\f2 #include "rtl8139.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b card}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b card} {\b card_t}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b rtl8139_ifup} ({\b netif_t} *{\b netif})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b rtl8139_ifdown} ({\b netif_t} *{\b netif})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b rtl8139_send} ({\b netif_t} *{\b netif}, void *buf, size_t len, int {\b type})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b recvdata} ({\b card_t} *{\b card})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b rtl8139_handler} (void *{\b unused})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b rtl8139_init} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ATTRIBUTE} ("netif", rtl8139_init)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b card_t} * {\b card} = NULL\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b rtl8139_rxbuffer} [{\b RX_BUFFER_SIZE}+16]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b rtl8139_txbuffer} [{\b TX_BUFFER_SIZE} *4+16]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v card_t\:rtl8139.c}
{\xe \v rtl8139.c\:card_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b card}  {\b card_t}}}
\par
{\bkmkstart AAAAAAABAY}
{\bkmkend AAAAAAABAY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v ATTRIBUTE\:rtl8139.c}
{\xe \v rtl8139.c\:ATTRIBUTE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ATTRIBUTE ("netif" , {\b rtl8139_init} )}}
\par
{\bkmkstart AAAAAAABAZ}
{\bkmkend AAAAAAABAZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v recvdata\:rtl8139.c}
{\xe \v rtl8139.c\:recvdata}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void recvdata ({\b card_t} * {\i card}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABBA}
{\bkmkend AAAAAAABBA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 87 of file rtl8139.c.}\par
{
References CR_BUFFER_IS_EMPTY, data, eth_recv(), netif::flags, int_in8, int_out16, kmalloc(), kprintf(), length, card::netif, NETIF_FLAGS_ENABLE, REG_COMMAND, REG_CUR_READ_ADDR, RX_BUFFER_SIZE, netif::rx_bytes, netif::rx_errors, netif::rx_packets, card::rxBuffer, card::rxBufferOffset, netif::state, udp_recv(), uint16_t, uint32_t, and uint8_t.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 87                                    \{\par
88     if((card->netif->flags & NETIF_FLAGS_ENABLE) == 0)\par
89         return;\par
90 \par
91     while(1) \{\par
92         uint8_t cmd = int_in8(card, REG_COMMAND);\par
93     \par
94         if(cmd & CR_BUFFER_IS_EMPTY)\par
95             break;\par
96 \par
97         uint16_t* rxBuffer = (uint16_t*) ((uint32_t) card->rxBuffer + card->rxBufferOffset);\par
98         uint16_t head = *rxBuffer++;\par
99 \par
100         if((head & 1) == 0)\par
101             break;\par
102 \par
103         uint16_t length = *rxBuffer++;\par
104         length -= 4;\par
105 \par
106         card->rxBufferOffset += 4;\par
107 \par
108 \par
109         void* data = kmalloc(length);\par
110         if((card->rxBufferOffset + length) >= RX_BUFFER_SIZE) \{\par
111             memcpy(data, rxBuffer, RX_BUFFER_SIZE - card->rxBufferOffset);\par
112             memcpy((void*) ((uint32_t) data + RX_BUFFER_SIZE - card->rxBufferOffset), card->rxBuffer, length - (RX_BUFFER_SIZE - card->rxBufferOffset));\par
113         \} else\par
114             memcpy(data, rxBuffer, length);\par
115 \par
116 #ifdef RTL8139_DEBUG\par
117         kprintf("rtl8139: receveid %d bytes\\n", length);\par
118 #endif\par
119 \par
120 #ifdef USERNET\par
121         if(udp_recv(card->netif, data, length) > 0) \{\par
122 #else\par
123         if(eth_recv(card->netif, data, length) > 0) \{\par
124 #endif\par
125             card->netif->state.rx_packets += 1;\par
126             card->netif->state.rx_bytes += length;\par
127         \} else\par
128             card->netif->state.rx_errors += 1;\par
129         \par
130 \par
131         card->rxBufferOffset += length + 4;\par
132         card->rxBufferOffset = (card->rxBufferOffset + 3) & ~3;\par
133         card->rxBufferOffset %= RX_BUFFER_SIZE;\par
134 \par
135         int_out16(card, REG_CUR_READ_ADDR, card->rxBufferOffset - 0x10);\par
136     \}\par
137 \}\par
}
}
{\xe \v rtl8139_handler\:rtl8139.c}
{\xe \v rtl8139.c\:rtl8139_handler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void rtl8139_handler (void * {\i unused}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABBB}
{\bkmkend AAAAAAABBB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 139 of file rtl8139.c.}\par
{
References int_in16, int_out16, ISR_RECEIVE_OK, ISR_TRANSMIT_OK, kprintf(), recvdata(), REG_INTERRUPT_STATUS, card::txBufferUsed, and uint16_t.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 139                                           \{\par
140     uint16_t isr = int_in16(card, REG_INTERRUPT_STATUS);\par
141     uint16_t nsr = 0;\par
142 \par
143     if(isr & ISR_TRANSMIT_OK) \{\par
144 #ifdef RTL8139_DEBUG\par
145         kprintf("rtl8139: Transmitted data successfully\\n");\par
146 #endif\par
147 \par
148         card->txBufferUsed = 0;\par
149         nsr |= ISR_TRANSMIT_OK;\par
150     \}\par
151 \par
152     if(isr & ISR_RECEIVE_OK) \{\par
153 #ifdef RTL8139_DEBUG\par
154         kprintf("rtl8139: Received data\\n");\par
155 #endif\par
156         recvdata(card);\par
157         nsr |= ISR_RECEIVE_OK;\par
158     \}\par
159 \par
160     int_out16(card, REG_INTERRUPT_STATUS, nsr);\par
161 \}\par
}
}
{\xe \v rtl8139_ifdown\:rtl8139.c}
{\xe \v rtl8139.c\:rtl8139_ifdown}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int rtl8139_ifdown ({\b netif_t} * {\i netif})}}
\par
{\bkmkstart AAAAAAABBC}
{\bkmkend AAAAAAABBC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 47 of file rtl8139.c.}\par
{
References netif::flags, and NETIF_FLAGS_ENABLE.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 47                                    \{\par
48     netif->flags &= ~NETIF_FLAGS_ENABLE;\par
49     return 0;\par
50 \}\par
}
}
{\xe \v rtl8139_ifup\:rtl8139.c}
{\xe \v rtl8139.c\:rtl8139_ifup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int rtl8139_ifup ({\b netif_t} * {\i netif})}}
\par
{\bkmkstart AAAAAAABBD}
{\bkmkend AAAAAAABBD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 42 of file rtl8139.c.}\par
{
References netif::flags, and NETIF_FLAGS_ENABLE.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 42                                  \{\par
43     netif->flags |= NETIF_FLAGS_ENABLE;\par
44     return 0;\par
45 \}\par
}
}
{\xe \v rtl8139_init\:rtl8139.c}
{\xe \v rtl8139.c\:rtl8139_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int rtl8139_init ()}}
\par
{\bkmkstart AAAAAAABBE}
{\bkmkend AAAAAAABBE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 164 of file rtl8139.c.}\par
{
References pci_device::bus, CR_RECEIVER_ENABLE, CR_RESET, CR_TRANSMITTER_ENABLE, card::curBuffer, netif::data, pci_device::dev, card::device, netif::dns, eth_send(), pci_device::func, netif::ifdown, netif::ifup, int_in8, int_out16, int_out32, int_out8, pci_device::intr_line, pci_device::iobase, netif::ipv4, netif::ipv6, irq_set(), kmalloc(), kprintf(), card::macaddr, netif::macaddr, card::magic, netif::mtu, netif::name, card::netif, netif_add(), NETIF_RAW, netif::netmask, pci_find_by_id(), netif::primary, RCR_ACCEPT_BROADCAST, RCR_ACCEPT_PHYS_MATCH, RCR_MXDMA_UNLIMITED, REG_COMMAND, REG_CONFIG1, REG_INTERRUPT_MASK, REG_INTERRUPT_STATUS, REG_RECEIVE_BUFFER, REG_RECEIVE_CONFIGURATION, REG_TRANSMIT_ADDR0, REG_TRANSMIT_CONFIGURATION, rtl8139_handler(), rtl8139_ifdown(), rtl8139_ifup(), RTL8139_MAGIC, rtl8139_rxbuffer, rtl8139_send(), rtl8139_txbuffer, RX_BUFFER_SIZE, card::rxBuffer, card::rxBufferOffset, netif::secondary, netif::send, TCR_IFG_STANDARD, TCR_MXDMA_256, TX_BUFFER_SIZE, card::txBuffer, card::txBufferUsed, and uint32_t.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 164                    \{\par
165     pci_device_t* device = (pci_device_t*) pci_find_by_id(0x10EC, 0x8139);\par
166     if(device == NULL) \{\par
167 #ifdef RTL8139_DEBUG\par
168         kprintf("rtl8139: no device found\\n");\par
169 #endif\par
170         return -1;\par
171     \}\par
172     \par
173     card = kmalloc(sizeof(card_t));\par
174     card->magic = RTL8139_MAGIC;\par
175     card->device = device;\par
176 \par
177     int_out8(card, REG_CONFIG1, 0);\par
178     int_out8(card, REG_COMMAND, CR_RESET);\par
179 \par
180     while((int_in8(card, REG_COMMAND) & REG_COMMAND) == CR_RESET);\par
181 \par
182     memset(card->macaddr, 0, 6);\par
183     for(int i = 0; i < 6; i++)\par
184         card->macaddr[i] = int_in8(card, i);\par
185     \par
186 \par
187 #ifdef RTL8139_DEBUG\par
188     kprintf("rtl8139: %d:%d.%d, iobase 0x%x, irq %d, MAC Address %02x:%02x:%02x:%02x:%02x:%02x\\n",\par
189         card->device->bus,\par
190         card->device->dev,\par
191         card->device->func,\par
192         card->device->iobase,\par
193         card->device->intr_line,\par
194         card->macaddr[0],\par
195         card->macaddr[1],\par
196         card->macaddr[2],\par
197         card->macaddr[3],\par
198         card->macaddr[4],\par
199         card->macaddr[5]\par
200     );\par
201 #endif\par
202 \par
203     if(card->device->intr_line == 0xFF) \{\par
204         kprintf("rtl8139: network card isn't connected to the PIC\\n");\par
205         return -1;\par
206     \}\par
207 \par
208     card->rxBuffer = (char*) rtl8139_rxbuffer;\par
209     card->txBuffer = (char*) rtl8139_txbuffer;\par
210 \par
211     card->rxBufferOffset = 0;\par
212     card->curBuffer = 0;\par
213     card->txBufferUsed = 0;\par
214 \par
215     memset(card->rxBuffer, 0, RX_BUFFER_SIZE + 16);\par
216     memset(card->txBuffer, 0, TX_BUFFER_SIZE * 4 + 16);\par
217 \par
218 \par
219     irq_set(card->device->intr_line, rtl8139_handler);\par
220 \par
221     int_out16(card, REG_INTERRUPT_MASK, 0x0005);\par
222     int_out16(card, REG_INTERRUPT_STATUS, 0);\par
223 \par
224     int_out8(card, REG_COMMAND, CR_RECEIVER_ENABLE | CR_TRANSMITTER_ENABLE);\par
225 \par
226     int_out32(card, REG_RECEIVE_BUFFER, (uint32_t) card->rxBuffer);\par
227 \par
228     for(int i = 0; i < 4; i++)\par
229         int_out32(card, REG_TRANSMIT_ADDR0 + (4 * i), (uint32_t) card->txBuffer + (TX_BUFFER_SIZE * i));\par
230 \par
231     int_out32(card, REG_RECEIVE_CONFIGURATION, RCR_MXDMA_UNLIMITED | RCR_ACCEPT_BROADCAST | RCR_ACCEPT_PHYS_MATCH);\par
232     int_out32(card, REG_TRANSMIT_CONFIGURATION, TCR_IFG_STANDARD | TCR_MXDMA_256);\par
233 \par
234     int_out8(card, REG_COMMAND, CR_RECEIVER_ENABLE | CR_TRANSMITTER_ENABLE);\par
235 \par
236 \par
237     card->netif = (netif_t*) kmalloc(sizeof(netif_t));\par
238     memset(card->netif, 0, sizeof(netif_t));\par
239 \par
240 \par
241     strcpy(card->netif->name, "eth0");\par
242     memcpy(card->netif->macaddr, card->macaddr, sizeof(macaddr_t));\par
243 \par
244     card->netif->ipv4[0] = 192;\par
245     card->netif->ipv4[1] = 168;\par
246     card->netif->ipv4[2] = 1;\par
247     card->netif->ipv4[3] = 80;\par
248 \par
249     card->netif->netmask[0] = 255;\par
250     card->netif->netmask[1] = 255;\par
251     card->netif->netmask[2] = 255;\par
252     card->netif->netmask[3] = 0;\par
253 \par
254     card->netif->ipv6[0] = 0xfe80;\par
255     card->netif->ipv6[1] = 0x0000;\par
256     card->netif->ipv6[2] = 0x0000;\par
257     card->netif->ipv6[3] = 0x0000;\par
258     card->netif->ipv6[4] = 0x021d;\par
259     card->netif->ipv6[5] = 0x72ff;\par
260     card->netif->ipv6[6] = 0xfef9;\par
261     card->netif->ipv6[7] = 0x9b71;\par
262 \par
263     card->netif->dns.primary.ipv4[0] = 8;\par
264     card->netif->dns.primary.ipv4[1] = 8;\par
265     card->netif->dns.primary.ipv4[2] = 8;\par
266     card->netif->dns.primary.ipv4[3] = 8;\par
267 \par
268     card->netif->dns.secondary.ipv4[0] = 8;\par
269     card->netif->dns.secondary.ipv4[1] = 8;\par
270     card->netif->dns.secondary.ipv4[2] = 4;\par
271     card->netif->dns.secondary.ipv4[3] = 4;\par
272     \par
273 \par
274     card->netif->dns.primary.ipv6[0] = 0x2001;\par
275     card->netif->dns.primary.ipv6[1] = 0x4860;\par
276     card->netif->dns.primary.ipv6[2] = 0x4860;\par
277     card->netif->dns.primary.ipv6[3] = 0x0000;\par
278     card->netif->dns.primary.ipv6[4] = 0x0000;\par
279     card->netif->dns.primary.ipv6[5] = 0x0000;\par
280     card->netif->dns.primary.ipv6[6] = 0x0000;\par
281     card->netif->dns.primary.ipv6[7] = 0x8888;\par
282     card->netif->dns.secondary.ipv6[0] = 0x2001;\par
283     card->netif->dns.secondary.ipv6[1] = 0x4860;\par
284     card->netif->dns.secondary.ipv6[2] = 0x4860;\par
285     card->netif->dns.secondary.ipv6[3] = 0x0000;\par
286     card->netif->dns.secondary.ipv6[4] = 0x0000;\par
287     card->netif->dns.secondary.ipv6[5] = 0x0000;\par
288     card->netif->dns.secondary.ipv6[6] = 0x0000;\par
289     card->netif->dns.secondary.ipv6[7] = 0x8844;\par
290 \par
291 \par
292     card->netif->mtu = 1500;\par
293     card->netif->send = rtl8139_send;\par
294     card->netif->ifup = rtl8139_ifup;\par
295     card->netif->ifdown = rtl8139_ifdown;\par
296     card->netif->data = (void*) card;\par
297 \par
298 #ifdef RTL8139_DEBUG\par
299     kprintf("rtl8139: sending data for test (512 Bytes)\\n");\par
300     \par
301     void* tmpbuf = kmalloc(512);\par
302     memset(tmpbuf, 0xFF, 512);\par
303 \par
304     rtl8139_ifup(card->netif);\par
305     eth_send(card->netif, tmpbuf, 512, NETIF_RAW); \par
306     rtl8139_ifdown(card->netif);\par
307 \par
308 #endif\par
309 \par
310     netif_add(card->netif);\par
311     return 0;\par
312 \}\par
}
}
{\xe \v rtl8139_send\:rtl8139.c}
{\xe \v rtl8139.c\:rtl8139_send}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int rtl8139_send ({\b netif_t} * {\i netif}, void * {\i buf}, size_t {\i len}, int {\i type})}}
\par
{\bkmkstart AAAAAAABBF}
{\bkmkend AAAAAAABBF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 52 of file rtl8139.c.}\par
{
References card::curBuffer, netif::data, fastlock_waiton, netif::flags, int_out32, card::magic, NETIF_FLAGS_ENABLE, REG_TRANSMIT_ADDR0, REG_TRANSMIT_STATUS0, RTL8139_MAGIC, netif::state, TX_BUFFER_SIZE, netif::tx_bytes, netif::tx_errors, netif::tx_packets, card::txBuffer, card::txBufferUsed, uint32_t, and uint8_t.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 52                                                                   \{\par
53     if((netif->flags & NETIF_FLAGS_ENABLE) == 0)\par
54         return 0;\par
55 \par
56     card_t* card = (card_t*) netif->data;\par
57     if(card->magic != RTL8139_MAGIC)\par
58         return 0;\par
59 \par
60     if(len > 1500) \{\par
61         netif->state.tx_errors += 1;\par
62         return 0;\par
63     \}\par
64 \par
65     fastlock_waiton(card->txBufferUsed);\par
66 \par
67     memcpy(card->txBuffer, buf, len);\par
68     if(len < 60) \{\par
69         memset((void*) ((uint32_t) card->txBuffer + len), 0, 60 - len);\par
70         len = 60;\par
71     \}\par
72 \par
73     uint8_t curBuffer = card->curBuffer++;\par
74     card->curBuffer %= 4;\par
75 \par
76 \par
77     int_out32(card, REG_TRANSMIT_ADDR0 + (4 * curBuffer), (uint32_t) card->txBuffer + (TX_BUFFER_SIZE * curBuffer));\par
78     int_out32(card, REG_TRANSMIT_STATUS0 + (4 * curBuffer), ((256 << 11) & 0x003F0000) | len);\par
79 \par
80     netif->state.tx_packets += 1;\par
81     netif->state.tx_bytes += len;\par
82 \par
83     return len;\par
84 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v card\:rtl8139.c}
{\xe \v rtl8139.c\:card}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b card_t}* {\b card} = NULL{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABBG}
{\bkmkend AAAAAAABBG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 35 of file rtl8139.c.}\par
}
{\xe \v rtl8139_rxbuffer\:rtl8139.c}
{\xe \v rtl8139.c\:rtl8139_rxbuffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} rtl8139_rxbuffer[{\b RX_BUFFER_SIZE}+16]}}
\par
{\bkmkstart AAAAAAABBH}
{\bkmkend AAAAAAABBH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 38 of file rtl8139.c.}\par
}
{\xe \v rtl8139_txbuffer\:rtl8139.c}
{\xe \v rtl8139.c\:rtl8139_txbuffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} rtl8139_txbuffer[{\b TX_BUFFER_SIZE} *4+16]}}
\par
{\bkmkstart AAAAAAABBI}
{\bkmkend AAAAAAABBI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 39 of file rtl8139.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/net/rtl8139/rtl8139.h File Reference\par \pard\plain 
{\tc\tcl2 \v src/net/rtl8139/rtl8139.h}
{\xe \v src/net/rtl8139/rtl8139.h}
{\bkmkstart AAAAAAABBJ}
{\bkmkend AAAAAAABBJ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <aplus/netif.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b REG_ID0}\~ 0x00\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b REG_ID4}\~ 0x04\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b REG_TRANSMIT_STATUS0}\~ 0x10\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b REG_TRANSMIT_ADDR0}\~ 0x20\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b REG_RECEIVE_BUFFER}\~ 0x30\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b REG_COMMAND}\~ 0x37\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b REG_CUR_READ_ADDR}\~ 0x38\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b REG_INTERRUPT_MASK}\~ 0x3C\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b REG_INTERRUPT_STATUS}\~ 0x3E\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b REG_TRANSMIT_CONFIGURATION}\~ 0x40\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b REG_RECEIVE_CONFIGURATION}\~ 0x44\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b REG_CONFIG1}\~ 0x52\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CR_RESET}\~ (1 << 4)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CR_RECEIVER_ENABLE}\~ (1 << 3)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CR_TRANSMITTER_ENABLE}\~ (1 << 2)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CR_BUFFER_IS_EMPTY}\~ (1 << 0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TCR_IFG_STANDARD}\~ (3 << 24)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TCR_MXDMA_256}\~ (4 << 8)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TCR_MXDMA_512}\~ (5 << 8)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TCR_MXDMA_1024}\~ (6 << 8)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TCR_MXDMA_2048}\~ (7 << 8)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b RCR_MXDMA_512}\~ (5 << 8)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b RCR_MXDMA_1024}\~ (6 << 8)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b RCR_MXDMA_UNLIMITED}\~ (7 << 8)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b RCR_ACCEPT_BROADCAST}\~ (1 << 3)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b RCR_ACCEPT_MULTICAST}\~ (1 << 2)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b RCR_ACCEPT_PHYS_MATCH}\~ (1 << 1)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ISR_RECEIVE_BUFFER_OVERFLOW}\~ (1 << 4)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ISR_TRANSMIT_OK}\~ (1 << 2)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ISR_RECEIVE_OK}\~ (1 << 0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b RX_BUFFER_SIZE}\~ 8192\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TX_BUFFER_SIZE}\~ 4096\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b int_out8}({\b card}, port, {\b value})\~ outb({\b card}->device->iobase + port, {\b value})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b int_out16}({\b card}, port, {\b value})\~ outw({\b card}->device->iobase + port, {\b value})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b int_out32}({\b card}, port, {\b value})\~ outl({\b card}->device->iobase + port, {\b value})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b int_in8}({\b card}, port)\~ inb({\b card}->device->iobase + port)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b int_in16}({\b card}, port)\~ inw({\b card}->device->iobase + port)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b RTL8139_MAGIC}\~ 0x8139FFFF\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v CR_BUFFER_IS_EMPTY\:rtl8139.h}
{\xe \v rtl8139.h\:CR_BUFFER_IS_EMPTY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CR_BUFFER_IS_EMPTY\~ (1 << 0)}}
\par
{\bkmkstart AAAAAAABBK}
{\bkmkend AAAAAAABBK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 23 of file rtl8139.h.}\par
}
{\xe \v CR_RECEIVER_ENABLE\:rtl8139.h}
{\xe \v rtl8139.h\:CR_RECEIVER_ENABLE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CR_RECEIVER_ENABLE\~ (1 << 3)}}
\par
{\bkmkstart AAAAAAABBL}
{\bkmkend AAAAAAABBL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 21 of file rtl8139.h.}\par
}
{\xe \v CR_RESET\:rtl8139.h}
{\xe \v rtl8139.h\:CR_RESET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CR_RESET\~ (1 << 4)}}
\par
{\bkmkstart AAAAAAABBM}
{\bkmkend AAAAAAABBM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 20 of file rtl8139.h.}\par
}
{\xe \v CR_TRANSMITTER_ENABLE\:rtl8139.h}
{\xe \v rtl8139.h\:CR_TRANSMITTER_ENABLE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CR_TRANSMITTER_ENABLE\~ (1 << 2)}}
\par
{\bkmkstart AAAAAAABBN}
{\bkmkend AAAAAAABBN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 22 of file rtl8139.h.}\par
}
{\xe \v int_in16\:rtl8139.h}
{\xe \v rtl8139.h\:int_in16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define int_in16( {\b card},  port)\~ inw({\b card}->device->iobase + port)}}
\par
{\bkmkstart AAAAAAABBO}
{\bkmkend AAAAAAABBO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 51 of file rtl8139.h.}\par
}
{\xe \v int_in8\:rtl8139.h}
{\xe \v rtl8139.h\:int_in8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define int_in8( {\b card},  port)\~ inb({\b card}->device->iobase + port)}}
\par
{\bkmkstart AAAAAAABBP}
{\bkmkend AAAAAAABBP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 50 of file rtl8139.h.}\par
}
{\xe \v int_out16\:rtl8139.h}
{\xe \v rtl8139.h\:int_out16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define int_out16( {\b card},  port,  {\b value})\~ outw({\b card}->device->iobase + port, {\b value})}}
\par
{\bkmkstart AAAAAAABBQ}
{\bkmkend AAAAAAABBQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 47 of file rtl8139.h.}\par
}
{\xe \v int_out32\:rtl8139.h}
{\xe \v rtl8139.h\:int_out32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define int_out32( {\b card},  port,  {\b value})\~ outl({\b card}->device->iobase + port, {\b value})}}
\par
{\bkmkstart AAAAAAABBR}
{\bkmkend AAAAAAABBR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 48 of file rtl8139.h.}\par
}
{\xe \v int_out8\:rtl8139.h}
{\xe \v rtl8139.h\:int_out8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define int_out8( {\b card},  port,  {\b value})\~ outb({\b card}->device->iobase + port, {\b value})}}
\par
{\bkmkstart AAAAAAABBS}
{\bkmkend AAAAAAABBS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 46 of file rtl8139.h.}\par
}
{\xe \v ISR_RECEIVE_BUFFER_OVERFLOW\:rtl8139.h}
{\xe \v rtl8139.h\:ISR_RECEIVE_BUFFER_OVERFLOW}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ISR_RECEIVE_BUFFER_OVERFLOW\~ (1 << 4)}}
\par
{\bkmkstart AAAAAAABBT}
{\bkmkend AAAAAAABBT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 38 of file rtl8139.h.}\par
}
{\xe \v ISR_RECEIVE_OK\:rtl8139.h}
{\xe \v rtl8139.h\:ISR_RECEIVE_OK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ISR_RECEIVE_OK\~ (1 << 0)}}
\par
{\bkmkstart AAAAAAABBU}
{\bkmkend AAAAAAABBU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 40 of file rtl8139.h.}\par
}
{\xe \v ISR_TRANSMIT_OK\:rtl8139.h}
{\xe \v rtl8139.h\:ISR_TRANSMIT_OK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ISR_TRANSMIT_OK\~ (1 << 2)}}
\par
{\bkmkstart AAAAAAABBV}
{\bkmkend AAAAAAABBV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 39 of file rtl8139.h.}\par
}
{\xe \v RCR_ACCEPT_BROADCAST\:rtl8139.h}
{\xe \v rtl8139.h\:RCR_ACCEPT_BROADCAST}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define RCR_ACCEPT_BROADCAST\~ (1 << 3)}}
\par
{\bkmkstart AAAAAAABBW}
{\bkmkend AAAAAAABBW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 34 of file rtl8139.h.}\par
}
{\xe \v RCR_ACCEPT_MULTICAST\:rtl8139.h}
{\xe \v rtl8139.h\:RCR_ACCEPT_MULTICAST}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define RCR_ACCEPT_MULTICAST\~ (1 << 2)}}
\par
{\bkmkstart AAAAAAABBX}
{\bkmkend AAAAAAABBX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 35 of file rtl8139.h.}\par
}
{\xe \v RCR_ACCEPT_PHYS_MATCH\:rtl8139.h}
{\xe \v rtl8139.h\:RCR_ACCEPT_PHYS_MATCH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define RCR_ACCEPT_PHYS_MATCH\~ (1 << 1)}}
\par
{\bkmkstart AAAAAAABBY}
{\bkmkend AAAAAAABBY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 36 of file rtl8139.h.}\par
}
{\xe \v RCR_MXDMA_1024\:rtl8139.h}
{\xe \v rtl8139.h\:RCR_MXDMA_1024}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define RCR_MXDMA_1024\~ (6 << 8)}}
\par
{\bkmkstart AAAAAAABBZ}
{\bkmkend AAAAAAABBZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 32 of file rtl8139.h.}\par
}
{\xe \v RCR_MXDMA_512\:rtl8139.h}
{\xe \v rtl8139.h\:RCR_MXDMA_512}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define RCR_MXDMA_512\~ (5 << 8)}}
\par
{\bkmkstart AAAAAAABCA}
{\bkmkend AAAAAAABCA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 31 of file rtl8139.h.}\par
}
{\xe \v RCR_MXDMA_UNLIMITED\:rtl8139.h}
{\xe \v rtl8139.h\:RCR_MXDMA_UNLIMITED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define RCR_MXDMA_UNLIMITED\~ (7 << 8)}}
\par
{\bkmkstart AAAAAAABCB}
{\bkmkend AAAAAAABCB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 33 of file rtl8139.h.}\par
}
{\xe \v REG_COMMAND\:rtl8139.h}
{\xe \v rtl8139.h\:REG_COMMAND}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define REG_COMMAND\~ 0x37}}
\par
{\bkmkstart AAAAAAABCC}
{\bkmkend AAAAAAABCC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 12 of file rtl8139.h.}\par
}
{\xe \v REG_CONFIG1\:rtl8139.h}
{\xe \v rtl8139.h\:REG_CONFIG1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define REG_CONFIG1\~ 0x52}}
\par
{\bkmkstart AAAAAAABCD}
{\bkmkend AAAAAAABCD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 18 of file rtl8139.h.}\par
}
{\xe \v REG_CUR_READ_ADDR\:rtl8139.h}
{\xe \v rtl8139.h\:REG_CUR_READ_ADDR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define REG_CUR_READ_ADDR\~ 0x38}}
\par
{\bkmkstart AAAAAAABCE}
{\bkmkend AAAAAAABCE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 13 of file rtl8139.h.}\par
}
{\xe \v REG_ID0\:rtl8139.h}
{\xe \v rtl8139.h\:REG_ID0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define REG_ID0\~ 0x00}}
\par
{\bkmkstart AAAAAAABCF}
{\bkmkend AAAAAAABCF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 6 of file rtl8139.h.}\par
}
{\xe \v REG_ID4\:rtl8139.h}
{\xe \v rtl8139.h\:REG_ID4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define REG_ID4\~ 0x04}}
\par
{\bkmkstart AAAAAAABCG}
{\bkmkend AAAAAAABCG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 7 of file rtl8139.h.}\par
}
{\xe \v REG_INTERRUPT_MASK\:rtl8139.h}
{\xe \v rtl8139.h\:REG_INTERRUPT_MASK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define REG_INTERRUPT_MASK\~ 0x3C}}
\par
{\bkmkstart AAAAAAABCH}
{\bkmkend AAAAAAABCH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 14 of file rtl8139.h.}\par
}
{\xe \v REG_INTERRUPT_STATUS\:rtl8139.h}
{\xe \v rtl8139.h\:REG_INTERRUPT_STATUS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define REG_INTERRUPT_STATUS\~ 0x3E}}
\par
{\bkmkstart AAAAAAABCI}
{\bkmkend AAAAAAABCI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 15 of file rtl8139.h.}\par
}
{\xe \v REG_RECEIVE_BUFFER\:rtl8139.h}
{\xe \v rtl8139.h\:REG_RECEIVE_BUFFER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define REG_RECEIVE_BUFFER\~ 0x30}}
\par
{\bkmkstart AAAAAAABCJ}
{\bkmkend AAAAAAABCJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 11 of file rtl8139.h.}\par
}
{\xe \v REG_RECEIVE_CONFIGURATION\:rtl8139.h}
{\xe \v rtl8139.h\:REG_RECEIVE_CONFIGURATION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define REG_RECEIVE_CONFIGURATION\~ 0x44}}
\par
{\bkmkstart AAAAAAABCK}
{\bkmkend AAAAAAABCK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 17 of file rtl8139.h.}\par
}
{\xe \v REG_TRANSMIT_ADDR0\:rtl8139.h}
{\xe \v rtl8139.h\:REG_TRANSMIT_ADDR0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define REG_TRANSMIT_ADDR0\~ 0x20}}
\par
{\bkmkstart AAAAAAABCL}
{\bkmkend AAAAAAABCL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 10 of file rtl8139.h.}\par
}
{\xe \v REG_TRANSMIT_CONFIGURATION\:rtl8139.h}
{\xe \v rtl8139.h\:REG_TRANSMIT_CONFIGURATION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define REG_TRANSMIT_CONFIGURATION\~ 0x40}}
\par
{\bkmkstart AAAAAAABCM}
{\bkmkend AAAAAAABCM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 16 of file rtl8139.h.}\par
}
{\xe \v REG_TRANSMIT_STATUS0\:rtl8139.h}
{\xe \v rtl8139.h\:REG_TRANSMIT_STATUS0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define REG_TRANSMIT_STATUS0\~ 0x10}}
\par
{\bkmkstart AAAAAAABCN}
{\bkmkend AAAAAAABCN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9 of file rtl8139.h.}\par
}
{\xe \v RTL8139_MAGIC\:rtl8139.h}
{\xe \v rtl8139.h\:RTL8139_MAGIC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define RTL8139_MAGIC\~ 0x8139FFFF}}
\par
{\bkmkstart AAAAAAABCO}
{\bkmkend AAAAAAABCO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 53 of file rtl8139.h.}\par
}
{\xe \v RX_BUFFER_SIZE\:rtl8139.h}
{\xe \v rtl8139.h\:RX_BUFFER_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define RX_BUFFER_SIZE\~ 8192}}
\par
{\bkmkstart AAAAAAABCP}
{\bkmkend AAAAAAABCP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 42 of file rtl8139.h.}\par
}
{\xe \v TCR_IFG_STANDARD\:rtl8139.h}
{\xe \v rtl8139.h\:TCR_IFG_STANDARD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TCR_IFG_STANDARD\~ (3 << 24)}}
\par
{\bkmkstart AAAAAAABCQ}
{\bkmkend AAAAAAABCQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 25 of file rtl8139.h.}\par
}
{\xe \v TCR_MXDMA_1024\:rtl8139.h}
{\xe \v rtl8139.h\:TCR_MXDMA_1024}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TCR_MXDMA_1024\~ (6 << 8)}}
\par
{\bkmkstart AAAAAAABCR}
{\bkmkend AAAAAAABCR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 28 of file rtl8139.h.}\par
}
{\xe \v TCR_MXDMA_2048\:rtl8139.h}
{\xe \v rtl8139.h\:TCR_MXDMA_2048}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TCR_MXDMA_2048\~ (7 << 8)}}
\par
{\bkmkstart AAAAAAABCS}
{\bkmkend AAAAAAABCS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 29 of file rtl8139.h.}\par
}
{\xe \v TCR_MXDMA_256\:rtl8139.h}
{\xe \v rtl8139.h\:TCR_MXDMA_256}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TCR_MXDMA_256\~ (4 << 8)}}
\par
{\bkmkstart AAAAAAABCT}
{\bkmkend AAAAAAABCT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 26 of file rtl8139.h.}\par
}
{\xe \v TCR_MXDMA_512\:rtl8139.h}
{\xe \v rtl8139.h\:TCR_MXDMA_512}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TCR_MXDMA_512\~ (5 << 8)}}
\par
{\bkmkstart AAAAAAABCU}
{\bkmkend AAAAAAABCU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 27 of file rtl8139.h.}\par
}
{\xe \v TX_BUFFER_SIZE\:rtl8139.h}
{\xe \v rtl8139.h\:TX_BUFFER_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TX_BUFFER_SIZE\~ 4096}}
\par
{\bkmkstart AAAAAAABCV}
{\bkmkend AAAAAAABCV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 43 of file rtl8139.h.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/net/slirp/slirp.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/net/slirp/slirp.c}
{\xe \v src/net/slirp/slirp.c}
{\bkmkstart AAAAAAABCW}
{\bkmkend AAAAAAABCW}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <aplus.h>}\par
{\f2 #include <aplus/netif.h>}\par
{\f2 #include <aplus/bufio.h>}\par
{\f2 #include <aplus/mm.h>}\par
{\f2 #include <aplus/task.h>}\par
{\f2 #include <aplus/spinlock.h>}\par
{\f2 #include <aplus/list.h>}\par
{\f2 #include <aplus/attribute.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <errno.h>}\par
{\f2 #include "slirp.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b slirpcard}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b slirpcard} {\b slirpcard_t}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b slirp_handler} (void *{\b unused})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b slirp_send} ({\b netif_t} *{\b netif}, void *buf, size_t {\b length}, int {\b type})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b slirp_ifup} ({\b netif_t} *{\b netif})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b slirp_ifdown} ({\b netif_t} *{\b netif})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b slirp_init} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ATTRIBUTE} ("netif", slirp_init)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b slirpcard_t} * {\b slirpcard} = NULL\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v slirpcard_t\:slirp.c}
{\xe \v slirp.c\:slirpcard_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b slirpcard}  {\b slirpcard_t}}}
\par
{\bkmkstart AAAAAAABCX}
{\bkmkend AAAAAAABCX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v ATTRIBUTE\:slirp.c}
{\xe \v slirp.c\:ATTRIBUTE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ATTRIBUTE ("netif" , {\b slirp_init} )}}
\par
{\bkmkstart AAAAAAABCY}
{\bkmkend AAAAAAABCY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v slirp_handler\:slirp.c}
{\xe \v slirp.c\:slirp_handler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void slirp_handler (void * {\i unused})}}
\par
{\bkmkstart AAAAAAABCZ}
{\bkmkend AAAAAAABCZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 28 of file slirp.c.}\par
{
References slirpcard::buffer, d, netif::flags, slirpcard::ioport, ipv4_recv(), kfree(), kmalloc(), kprintf(), slirpcard::netif, NETIF_FLAGS_ENABLE, slirpcard::offset, netif::rx_bytes, netif::rx_errors, netif::rx_packets, serial_recv(), SLIRP_BUFSIZ, SLIRP_PACKET_END, SLIRP_PACKET_ESC, SLIRP_PACKET_ESC_END, SLIRP_PACKET_ESC_ESC, netif::state, uint8_t, and slirpcard::used.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28                                  \{\par
29     if(slirpcard == NULL)\par
30         return;\par
31 \par
32     netif_t* netif = slirpcard->netif;\par
33 \par
34     if((netif->flags & NETIF_FLAGS_ENABLE) == 0)\par
35         return;\par
36     \par
37     kprintf("slirp: received data\\n");\par
38 \par
39     uint8_t d = serial_recv(slirpcard->ioport);\par
40     if(slirpcard->used == 0) \{\par
41         if(d != SLIRP_PACKET_END)\par
42             return;\par
43 \par
44         if(slirpcard->buffer)\par
45             kfree(slirpcard->buffer);\par
46 \par
47         slirpcard->buffer = (uint8_t*) kmalloc(sizeof(uint8_t) * SLIRP_BUFSIZ);\par
48         slirpcard->offset = 0;\par
49         slirpcard->used = 1;\par
50         return;\par
51     \}\par
52 \par
53     if((d == SLIRP_PACKET_END && slirpcard->used) || slirpcard->offset >= SLIRP_BUFSIZ) \{\par
54         slirpcard->used = 0;\par
55             \par
56         if(ipv4_recv(netif, slirpcard->buffer, slirpcard->offset) > 0) \{\par
57             netif->state.rx_packets += 1;\par
58             netif->state.rx_bytes += slirpcard->offset;\par
59         \} else\par
60             netif->state.rx_errors += 1;\par
61 \par
62         slirpcard->offset = 0;\par
63     \}\par
64 \par
65     switch(d) \{\par
66         case SLIRP_PACKET_ESC: \{\par
67             d = serial_recv(slirpcard->ioport);\par
68             switch(d) \{\par
69                 case SLIRP_PACKET_ESC_END:\par
70                     d = SLIRP_PACKET_END;\par
71                     break;\par
72                 case SLIRP_PACKET_ESC_ESC:\par
73                     d = SLIRP_PACKET_ESC;\par
74                     break;\par
75             \}\par
76         \}\par
77 \par
78         default:\par
79             slirpcard->buffer[slirpcard->offset++] = d;\par
80     \}\par
81     \par
82 \}\par
}
}
{\xe \v slirp_ifdown\:slirp.c}
{\xe \v slirp.c\:slirp_ifdown}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int slirp_ifdown ({\b netif_t} * {\i netif})}}
\par
{\bkmkstart AAAAAAABDA}
{\bkmkend AAAAAAABDA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 124 of file slirp.c.}\par
{
References netif::flags, and NETIF_FLAGS_ENABLE.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 124                                  \{\par
125     netif->flags &= ~NETIF_FLAGS_ENABLE;\par
126     return 0;\par
127 \}\par
}
}
{\xe \v slirp_ifup\:slirp.c}
{\xe \v slirp.c\:slirp_ifup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int slirp_ifup ({\b netif_t} * {\i netif})}}
\par
{\bkmkstart AAAAAAABDB}
{\bkmkend AAAAAAABDB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 119 of file slirp.c.}\par
{
References netif::flags, and NETIF_FLAGS_ENABLE.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 119                                \{\par
120     netif->flags |= NETIF_FLAGS_ENABLE;\par
121     return 0;\par
122 \}\par
}
}
{\xe \v slirp_init\:slirp.c}
{\xe \v slirp.c\:slirp_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int slirp_init ()}}
\par
{\bkmkstart AAAAAAABDC}
{\bkmkend AAAAAAABDC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 129 of file slirp.c.}\par
{
References slirpcard::buffer, netif::data, netif::dns, netif::ifdown, netif::ifup, slirpcard::ioport, netif::ipv4, netif::ipv6, irq_set(), kmalloc(), netif::macaddr, slirpcard::magic, netif::mtu, netif::name, slirpcard::netif, netif_add(), netif::netmask, slirpcard::offset, netif::primary, netif::secondary, netif::send, slirp_handler(), slirp_ifdown(), slirp_ifup(), SLIRP_MAGIC, SLIRP_MTU, slirp_send(), and slirpcard::used.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 129                  \{\par
130     \par
131     slirpcard = (slirpcard_t*) kmalloc(sizeof(slirpcard_t));\par
132     slirpcard->magic = SLIRP_MAGIC;\par
133     slirpcard->buffer = NULL;\par
134     slirpcard->offset = 0;\par
135     slirpcard->used = 0;\par
136     slirpcard->ioport = 1;\par
137 \par
138     netif_t* netif = (netif_t*) kmalloc(sizeof(netif_t));\par
139     memset(netif, 0, sizeof(netif_t));\par
140 \par
141 \par
142     strcpy(netif->name, "slp0");\par
143 \par
144 \par
145     netif->macaddr[0] = 10;\par
146     netif->macaddr[1] = 0;\par
147     netif->macaddr[2] = 2;\par
148     netif->macaddr[3] = 0;\par
149     netif->macaddr[4] = 255;\par
150     netif->macaddr[5] = 255;\par
151 \par
152     netif->ipv4[0] = 10;\par
153     netif->ipv4[1] = 0;\par
154     netif->ipv4[2] = 2;\par
155     netif->ipv4[3] = 0;\par
156 \par
157     netif->netmask[0] = 255;\par
158     netif->netmask[1] = 255;\par
159     netif->netmask[2] = 255;\par
160     netif->netmask[3] = 0;\par
161 \par
162     netif->ipv6[0] = 0xfe80;\par
163     netif->ipv6[1] = 0x0000;\par
164     netif->ipv6[2] = 0x0000;\par
165     netif->ipv6[3] = 0x0000;\par
166     netif->ipv6[4] = 0x0000;\par
167     netif->ipv6[5] = 0x10ff;\par
168     netif->ipv6[6] = 0xcef9;\par
169     netif->ipv6[7] = 0x9b70;\par
170 \par
171     netif->dns.primary.ipv4[0] = 8;\par
172     netif->dns.primary.ipv4[1] = 8;\par
173     netif->dns.primary.ipv4[2] = 8;\par
174     netif->dns.primary.ipv4[3] = 8;\par
175 \par
176     netif->dns.secondary.ipv4[0] = 8;\par
177     netif->dns.secondary.ipv4[1] = 8;\par
178     netif->dns.secondary.ipv4[2] = 4;\par
179     netif->dns.secondary.ipv4[3] = 4;\par
180     \par
181 \par
182     netif->dns.primary.ipv6[0] = 0x2001;\par
183     netif->dns.primary.ipv6[1] = 0x4860;\par
184     netif->dns.primary.ipv6[2] = 0x4860;\par
185     netif->dns.primary.ipv6[3] = 0x0000;\par
186     netif->dns.primary.ipv6[4] = 0x0000;\par
187     netif->dns.primary.ipv6[5] = 0x0000;\par
188     netif->dns.primary.ipv6[6] = 0x0000;\par
189     netif->dns.primary.ipv6[7] = 0x8888;\par
190     netif->dns.secondary.ipv6[0] = 0x2001;\par
191     netif->dns.secondary.ipv6[1] = 0x4860;\par
192     netif->dns.secondary.ipv6[2] = 0x4860;\par
193     netif->dns.secondary.ipv6[3] = 0x0000;\par
194     netif->dns.secondary.ipv6[4] = 0x0000;\par
195     netif->dns.secondary.ipv6[5] = 0x0000;\par
196     netif->dns.secondary.ipv6[6] = 0x0000;\par
197     netif->dns.secondary.ipv6[7] = 0x8844;\par
198 \par
199 \par
200     netif->mtu = SLIRP_MTU;\par
201     netif->send = slirp_send;\par
202     netif->ifup = slirp_ifup;\par
203     netif->ifdown = slirp_ifdown;\par
204     netif->data = (void*) slirpcard;\par
205 \par
206     slirpcard->netif = netif;\par
207     netif_add(netif);\par
208     \par
209 \par
210     irq_set(4, slirp_handler);\par
211     irq_set(3, slirp_handler);\par
212     return 0;\par
213 \}\par
}
}
{\xe \v slirp_send\:slirp.c}
{\xe \v slirp.c\:slirp_send}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int slirp_send ({\b netif_t} * {\i netif}, void * {\i buf}, size_t {\i length}, int {\i type})}}
\par
{\bkmkstart AAAAAAABDD}
{\bkmkend AAAAAAABDD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 85 of file slirp.c.}\par
{
References netif::data, netif::flags, slirpcard::ioport, length, slirpcard::magic, NETIF_FLAGS_ENABLE, serial_send(), SLIRP_MAGIC, SLIRP_PACKET_END, SLIRP_PACKET_ESC, SLIRP_PACKET_ESC_END, SLIRP_PACKET_ESC_ESC, and uint8_t.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 85                                                                    \{\par
86     if((netif->flags & NETIF_FLAGS_ENABLE) == 0)\par
87         return 0;\par
88 \par
89     slirpcard_t* slirpcard = (slirpcard_t*) netif->data;\par
90     if(slirpcard->magic != SLIRP_MAGIC)\par
91         return 0;\par
92 \par
93     \par
94     serial_send(slirpcard->ioport, SLIRP_PACKET_END);\par
95 \par
96     uint8_t* b = (uint8_t*) buf;\par
97     for(int i = 0; i < length; i++) \{\par
98         switch(b[i]) \{\par
99             case SLIRP_PACKET_END:\par
100                 serial_send(slirpcard->ioport, SLIRP_PACKET_ESC);\par
101                 serial_send(slirpcard->ioport, SLIRP_PACKET_ESC_END);\par
102                 break;\par
103 \par
104             case SLIRP_PACKET_ESC:\par
105                 serial_send(slirpcard->ioport, SLIRP_PACKET_ESC);\par
106                 serial_send(slirpcard->ioport, SLIRP_PACKET_ESC_ESC);\par
107                 break;\par
108     \par
109             default:\par
110                 serial_send(slirpcard->ioport, b[i]);\par
111                 break;\par
112         \}\par
113     \}\par
114 \par
115     serial_send(slirpcard->ioport, SLIRP_PACKET_END);\par
116     return length;\par
117 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v slirpcard\:slirp.c}
{\xe \v slirp.c\:slirpcard}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b slirpcard_t}* {\b slirpcard} = NULL{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABDE}
{\bkmkend AAAAAAABDE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 26 of file slirp.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/net/slirp/slirp.h File Reference\par \pard\plain 
{\tc\tcl2 \v src/net/slirp/slirp.h}
{\xe \v src/net/slirp/slirp.h}
{\bkmkstart AAAAAAABDF}
{\bkmkend AAAAAAABDF}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SLIRP_PACKET_END}\~ 0xC0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SLIRP_PACKET_ESC}\~ 0xDB\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SLIRP_PACKET_ESC_END}\~ 0xDC\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SLIRP_PACKET_ESC_ESC}\~ 0xDD\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SLIRP_BUFSIZ}\~ 1006\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SLIRP_MTU}\~ 65536\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SLIRP_MAGIC}\~ 0x100200FF\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v SLIRP_BUFSIZ\:slirp.h}
{\xe \v slirp.h\:SLIRP_BUFSIZ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SLIRP_BUFSIZ\~ 1006}}
\par
{\bkmkstart AAAAAAABDG}
{\bkmkend AAAAAAABDG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9 of file slirp.h.}\par
}
{\xe \v SLIRP_MAGIC\:slirp.h}
{\xe \v slirp.h\:SLIRP_MAGIC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SLIRP_MAGIC\~ 0x100200FF}}
\par
{\bkmkstart AAAAAAABDH}
{\bkmkend AAAAAAABDH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 12 of file slirp.h.}\par
}
{\xe \v SLIRP_MTU\:slirp.h}
{\xe \v slirp.h\:SLIRP_MTU}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SLIRP_MTU\~ 65536}}
\par
{\bkmkstart AAAAAAABDI}
{\bkmkend AAAAAAABDI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 10 of file slirp.h.}\par
}
{\xe \v SLIRP_PACKET_END\:slirp.h}
{\xe \v slirp.h\:SLIRP_PACKET_END}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SLIRP_PACKET_END\~ 0xC0}}
\par
{\bkmkstart AAAAAAABDJ}
{\bkmkend AAAAAAABDJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 4 of file slirp.h.}\par
}
{\xe \v SLIRP_PACKET_ESC\:slirp.h}
{\xe \v slirp.h\:SLIRP_PACKET_ESC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SLIRP_PACKET_ESC\~ 0xDB}}
\par
{\bkmkstart AAAAAAABDK}
{\bkmkend AAAAAAABDK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 5 of file slirp.h.}\par
}
{\xe \v SLIRP_PACKET_ESC_END\:slirp.h}
{\xe \v slirp.h\:SLIRP_PACKET_ESC_END}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SLIRP_PACKET_ESC_END\~ 0xDC}}
\par
{\bkmkstart AAAAAAABDL}
{\bkmkend AAAAAAABDL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 6 of file slirp.h.}\par
}
{\xe \v SLIRP_PACKET_ESC_ESC\:slirp.h}
{\xe \v slirp.h\:SLIRP_PACKET_ESC_ESC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SLIRP_PACKET_ESC_ESC\~ 0xDD}}
\par
{\bkmkstart AAAAAAABDM}
{\bkmkend AAAAAAABDM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 7 of file slirp.h.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/net/udp.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/net/udp.c}
{\xe \v src/net/udp.c}
{\bkmkstart AAAAAAABDN}
{\bkmkend AAAAAAABDN}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <aplus.h>}\par
{\f2 #include <aplus/list.h>}\par
{\f2 #include <aplus/netif.h>}\par
{\f2 #include <stddef.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <aplus/net/eth.h>}\par
{\f2 #include <aplus/net/udp.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b udp_recv} ({\b netif_t} *{\b netif}, void *buf, size_t {\b length})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v udp_recv\:udp.c}
{\xe \v udp.c\:udp_recv}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int udp_recv ({\b netif_t} * {\i netif}, void * {\i buf}, size_t {\i length})}}
\par
{\bkmkstart AAAAAAABDO}
{\bkmkend AAAAAAABDO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 12 of file udp.c.}\par
{
References length, netif_packets_add(), netif_packets_create(), and NETIF_UDP.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12                                                        \{\par
13     \par
14     netif_packets_add (\par
15         netif_packets_create (\par
16                             netif,\par
17                             NETIF_UDP, \par
18                             length, \par
19                             sizeof(udp_header_t), \par
20                             buf\par
21         )\par
22     );\par
23 \par
24     return length;\par
25 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/panic.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/panic.c}
{\xe \v src/panic.c}
{\bkmkstart AAAAAAABDP}
{\bkmkend AAAAAAABDP}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <aplus.h>}\par
{\f2 #include <aplus/task.h>}\par
{\f2 #include <aplus/fs.h>}\par
{\f2 #include <aplus/list.h>}\par
{\f2 #include <errno.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b d}(reg)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _d}()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b dump_errno} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Print last error number. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b dump_registers} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Print current registers. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b dump_stacktrace} (int count)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b dump_task} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Print all and current task. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b panic} (char *msg)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Go in Kernel Panic, halt system. }{
}\par
}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b list_t} * {\b task_queue}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
List of all Task. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b task_t} * {\b current_task}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current task address. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b task_t} * {\b kernel_task}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Kernel task address. }{
}\par
}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v _d\:panic.c}
{\xe \v panic.c\:_d}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _d()}}
\par
{\bkmkstart AAAAAAABDQ}
{\bkmkend AAAAAAABDQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ;                               \\\par
        kprintf("\\n");\par
}
}
{\xe \v d\:panic.c}
{\xe \v panic.c\:d}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define d( reg)}}
\par
{\bkmkstart AAAAAAABDR}
{\bkmkend AAAAAAABDR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ;                               \\\par
        kprintf(#reg ": 0x%x\\t\\t", read_##reg());\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v dump_errno\:panic.c}
{\xe \v panic.c\:dump_errno}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void dump_errno (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABDS}
{\bkmkend AAAAAAABDS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Print last error number. }}\par
{
Definition at line 16 of file panic.c.}\par
{
References errno, and kprintf().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 16                          \{\par
17     kprintf("errno: %d - %s\\n", errno, strerror(errno));\par
18 \}\par
}
}
{\xe \v dump_registers\:panic.c}
{\xe \v panic.c\:dump_registers}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void dump_registers (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABDT}
{\bkmkend AAAAAAABDT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Print current registers. }}\par
{
Definition at line 24 of file panic.c.}\par
{
References _d, cs, d, ds, eax, ebp, ebx, ecx, edi, edx, eflags, eip, es, esi, esp, fs, gs, and kprintf().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 24                              \{\par
25 \par
26     kprintf("Registers:\\n");\par
27 \par
28     #define d(reg);                             \\\par
29         kprintf(#reg ": 0x%x\\t\\t", read_##reg());\par
30         \par
31     #define _d();                               \\\par
32         kprintf("\\n");  \par
33             \par
34     d(eax);\par
35     d(ebx);\par
36     d(ecx);\par
37     d(edx);\par
38     d(esi);\par
39     d(edi);\par
40     _d();\par
41     d(eip);\par
42     d(eflags);\par
43     d(esp);\par
44     d(ebp);\par
45     _d();\par
46     d(cs);\par
47     d(ds);\par
48     d(es);\par
49     d(fs);\par
50     d(gs);\par
51     _d();\par
52     d(cr0);\par
53     d(cr2);\par
54     d(cr3);\par
55     d(cr4);\par
56     _d();\par
57     _d();\par
58     \par
59     #undef d\par
60     #undef _d\par
61 \}\par
}
}
{\xe \v dump_stacktrace\:panic.c}
{\xe \v panic.c\:dump_stacktrace}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void dump_stacktrace (int {\i count}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABDU}
{\bkmkend AAAAAAABDU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Print a stacktrace. \par
}{
Definition at line 67 of file panic.c.}\par
{
References kprintf().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 67                                        \{\par
68     kprintf("Stack trace:\\n");\par
69     kprintf("TODO\\n\\n");\par
70 \}\par
}
}
{\xe \v dump_task\:panic.c}
{\xe \v panic.c\:dump_task}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void dump_task (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABDV}
{\bkmkend AAAAAAABDV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Print all and current task. }}\par
{
Definition at line 76 of file panic.c.}\par
{
References task::exe, kprintf(), list_foreach, inode::name, task::pid, and value.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 76                         \{\par
77     kprintf("Task:\\n");\par
78     \par
79     list_foreach(value, task_queue) \{\par
80         task_t* task = (task_t*) value;\par
81         kprintf(" # %d: ", task->pid);\par
82         \par
83         if(task->exe)\par
84             kprintf("%s ", task->exe->name);\par
85         else\par
86             kprintf("unknown ");\par
87             \par
88         if(task == current_task)\par
89             kprintf("(current) ");\par
90             \par
91         if(task == kernel_task)\par
92             kprintf("(kernel) ");\par
93             \par
94         kprintf("\\n\\n");\par
95     \}\par
96 \}\par
}
}
{\xe \v panic\:panic.c}
{\xe \v panic.c\:panic}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void panic (char * {\i msg})}}
\par
{\bkmkstart AAAAAAABDW}
{\bkmkend AAAAAAABDW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Go in Kernel Panic, halt system. }}\par
{
Definition at line 102 of file panic.c.}\par
{
References __asm__(), dump_errno(), dump_registers(), dump_stacktrace(), dump_task(), and kprintf().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 102                       \{\par
103     __asm__ ("cli");\par
104     kprintf("panic: \\"%s\\"\\n", msg);\par
105     \par
106     \par
107     dump_registers();\par
108     dump_stacktrace(6);\par
109     dump_task();\par
110     dump_errno();\par
111     \par
112     for(;;);\par
113 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v current_task\:panic.c}
{\xe \v panic.c\:current_task}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b task_t}* current_task}}
\par
{\bkmkstart AAAAAAABDX}
{\bkmkend AAAAAAABDX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current task address. }}\par
{
Definition at line 35 of file sched.c.}\par
}
{\xe \v kernel_task\:panic.c}
{\xe \v panic.c\:kernel_task}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b task_t}* kernel_task}}
\par
{\bkmkstart AAAAAAABDY}
{\bkmkend AAAAAAABDY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Kernel task address. }}\par
{
Definition at line 40 of file sched.c.}\par
}
{\xe \v task_queue\:panic.c}
{\xe \v panic.c\:task_queue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b list_t}* task_queue}}
\par
{\bkmkstart AAAAAAABDZ}
{\bkmkend AAAAAAABDZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
List of all Task. }}\par
{
Definition at line 46 of file sched.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/sched.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/sched.c}
{\xe \v src/sched.c}
{\bkmkstart AAAAAAABEA}
{\bkmkend AAAAAAABEA}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <aplus.h>}\par
{\f2 #include <aplus/task.h>}\par
{\f2 #include <aplus/fs.h>}\par
{\f2 #include <aplus/spinlock.h>}\par
{\f2 #include <aplus/mm.h>}\par
{\f2 #include <aplus/list.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <sys/types.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b im_superuser} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get root permissions for current task. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b schedule_enable} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enable scheduling. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b schedule_disable} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Disable scheduling. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
pid_t {\b schedule_nextpid} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get a new Process ID. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b schedule_init} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize scheduling. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b task_t} * {\b schedule_next} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get next ready task. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b schedule} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Perform a scheduling and check TTL (Time To Live) for current task. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b schedule_yield} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Perform a forced scheduling. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b schedule_setpriority} (int priority)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set TTL (Time To Live) for current task. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b schedule_wait} ({\b task_t} *child)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Wait for child. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b task_t} * {\b schedule_child} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get Child task for current task. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b schedule_exit2} ({\b task_t} *{\b task}, int status)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Terminate a task with an Exit Value. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b schedule_exit} (int status)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Terminate current task. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
pid_t {\b schedule_getpid} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get Process ID of current task. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b task_t} * {\b schedule_getbypid} (pid_t pid)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get task from his Process ID. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b schedule_sbrk} (ptrdiff_t increment)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Increment address space of current task. }{
}\par
}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b task_t} * {\b current_task}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current task address. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b task_t} * {\b kernel_task}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Kernel task address. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b list_t} * {\b task_queue}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
List of all Task. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b sched_enabled} = 0\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Scheduling enabled status. }{
}\par
}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v im_superuser\:src/sched.c}
{\xe \v src/sched.c\:im_superuser}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int im_superuser ()}}
\par
{\bkmkstart AAAAAAABEB}
{\bkmkend AAAAAAABEB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get root permissions for current task. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true or false. \par
}}{
Definition at line 58 of file sched.c.}\par
{
References task::gid, GID_SUPERUSER, task::uid, and UID_SUPERUSER.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 58                    \{\par
59     if(!current_task)\par
60         return -1;\par
61 \par
62     if(current_task == kernel_task)\par
63         return 1;\par
64         \par
65     if(current_task->uid == UID_SUPERUSER && current_task->gid == GID_SUPERUSER)\par
66         return 1;\par
67     else\par
68         return 0;\par
69 \}\par
}
}
{\xe \v schedule\:src/sched.c}
{\xe \v src/sched.c\:schedule}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void schedule ()}}
\par
{\bkmkstart AAAAAAABEC}
{\bkmkend AAAAAAABEC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Perform a scheduling and check TTL (Time To Live) for current task. }}\par
{
Definition at line 133 of file sched.c.}\par
{
References task::clock, list_empty(), task::priority, sched_enabled, schedule_next(), and task_switch().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 133                 \{\par
134     if(sched_enabled == 0)\par
135         return;\par
136         \par
137     if(list_empty(task_queue))\par
138         return;\par
139 \par
140         \par
141     current_task->clock += 1;\par
142     \par
143     if(current_task->clock % current_task->priority)\par
144         return;\par
145         \par
146     task_switch(schedule_next());\par
147 \}\par
}
}
{\xe \v schedule_child\:src/sched.c}
{\xe \v src/sched.c\:schedule_child}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b task_t}* schedule_child ()}}
\par
{\bkmkstart AAAAAAABED}
{\bkmkend AAAAAAABED}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get Child task for current task. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid child task or NULL in case of error. \par
}}{
Definition at line 193 of file sched.c.}\par
{
References list_foreach, task::parent, and value.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 193                          \{\par
194     if(!current_task)\par
195         return NULL;\par
196         \par
197 \par
198     list_foreach(value, task_queue) \{\par
199         task_t* child = (task_t*) value;\par
200         \par
201         if(child->parent == current_task)\par
202             return child;\par
203     \}\par
204     \par
205     return NULL;\par
206 \}\par
}
}
{\xe \v schedule_disable\:src/sched.c}
{\xe \v src/sched.c\:schedule_disable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void schedule_disable ()}}
\par
{\bkmkstart AAAAAAABEE}
{\bkmkend AAAAAAABEE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Disable scheduling. }}\par
{
Definition at line 82 of file sched.c.}\par
{
References sched_enabled.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 82                         \{\par
83     sched_enabled = 0;\par
84 \}\par
}
}
{\xe \v schedule_enable\:src/sched.c}
{\xe \v src/sched.c\:schedule_enable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void schedule_enable ()}}
\par
{\bkmkstart AAAAAAABEF}
{\bkmkend AAAAAAABEF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enable scheduling. }}\par
{
Definition at line 75 of file sched.c.}\par
{
References sched_enabled.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 75                        \{\par
76     sched_enabled = 1;\par
77 \}\par
}
}
{\xe \v schedule_exit\:src/sched.c}
{\xe \v src/sched.c\:schedule_exit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void schedule_exit (int {\i status})}}
\par
{\bkmkstart AAAAAAABEG}
{\bkmkend AAAAAAABEG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Terminate current task. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i status} \cell }{Exit Value. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b schedule_exit2} \par
}}{
Definition at line 232 of file sched.c.}\par
{
References schedule_exit2().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 232                                \{\par
233     schedule_exit2(current_task, status);\par
234 \}\par
}
}
{\xe \v schedule_exit2\:src/sched.c}
{\xe \v src/sched.c\:schedule_exit2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void schedule_exit2 ({\b task_t} * {\i task}, int {\i status})}}
\par
{\bkmkstart AAAAAAABEH}
{\bkmkend AAAAAAABEH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Terminate a task with an Exit Value. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i task} \cell }{Task to close. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i status} \cell }{Exit Value. \cell }
{\row }
}
}{
Definition at line 213 of file sched.c.}\par
{
References kfree(), list_remove(), schedule_yield(), and TASK_STATE_DEAD.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 213                                               \{\par
214     if(!task)\par
215         return;\par
216         \par
217     list_remove(task_queue, (listval_t) task);\par
218         \par
219     task->state = TASK_STATE_DEAD;\par
220     task->exitcode = status;\par
221     \par
222     kfree((void*) task->image.ptr);\par
223     schedule_yield();\par
224 \}\par
}
}
{\xe \v schedule_getbypid\:src/sched.c}
{\xe \v src/sched.c\:schedule_getbypid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b task_t}* schedule_getbypid (pid_t {\i pid})}}
\par
{\bkmkstart AAAAAAABEI}
{\bkmkend AAAAAAABEI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get task from his Process ID. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid Task or NULL in case of error. \par
}}{
Definition at line 253 of file sched.c.}\par
{
References current_task, list_foreach, task::pid, and value.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 253                                      \{\par
254     if(current_task->pid == pid)\par
255         return current_task;\par
256         \par
257     list_foreach(value, task_queue) \{\par
258         task_t* t = (task_t*) value;\par
259         \par
260         if(t->pid == pid)\par
261             return t;\par
262     \}\par
263     \par
264     return NULL;\par
265 \}\par
}
}
{\xe \v schedule_getpid\:src/sched.c}
{\xe \v src/sched.c\:schedule_getpid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
pid_t schedule_getpid ()}}
\par
{\bkmkstart AAAAAAABEJ}
{\bkmkend AAAAAAABEJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get Process ID of current task. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid Process ID or -1 in case of error. \par
}}{
Definition at line 241 of file sched.c.}\par
{
References task::pid.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 241                         \{\par
242     if(!current_task)\par
243         return -1;\par
244         \par
245     return current_task->pid;\par
246 \}\par
}
}
{\xe \v schedule_init\:src/sched.c}
{\xe \v src/sched.c\:schedule_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int schedule_init ()}}
\par
{\bkmkstart AAAAAAABEK}
{\bkmkend AAAAAAABEK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize scheduling. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid success of initilization. \par
}}{
Definition at line 100 of file sched.c.}\par
{
References list_init, schedule_enable(), and task_init().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 100                     \{\par
101     list_init(task_queue);\par
102     task_init();\par
103     \par
104     \par
105     schedule_enable();\par
106     return 0;\par
107 \}\par
}
}
{\xe \v schedule_next\:src/sched.c}
{\xe \v src/sched.c\:schedule_next}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b task_t}* schedule_next (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABEL}
{\bkmkend AAAAAAABEL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get next ready task. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid A ready task to schedule. \par
}}{
Definition at line 114 of file sched.c.}\par
{
References current_task, list_head(), list_next(), task::state, and TASK_STATE_ALIVE.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 114                                \{\par
115     \par
116     task_t* newtask = current_task;\par
117     \par
118     do \{\par
119         newtask = (task_t*) list_next(task_queue, (listval_t) newtask);\par
120         if(!newtask)\par
121             newtask = (task_t*) list_head(task_queue);\par
122         \par
123     \} while(newtask->state != TASK_STATE_ALIVE);\par
124 \par
125     \par
126     return newtask;\par
127 \}\par
}
}
{\xe \v schedule_nextpid\:src/sched.c}
{\xe \v src/sched.c\:schedule_nextpid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
pid_t schedule_nextpid ()}}
\par
{\bkmkstart AAAAAAABEM}
{\bkmkend AAAAAAABEM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get a new Process ID. }}\par
{
Definition at line 89 of file sched.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 89                          \{\par
90     static pid_t nextpid = 0;\par
91     return nextpid++;\par
92 \}\par
}
}
{\xe \v schedule_sbrk\:src/sched.c}
{\xe \v src/sched.c\:schedule_sbrk}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* schedule_sbrk (ptrdiff_t {\i increment})}}
\par
{\bkmkstart AAAAAAABEN}
{\bkmkend AAAAAAABEN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Increment address space of current task. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i increment} \cell }{Increment in Bytes. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid Current size of address space or NULL in case of error. \par
}}{
Definition at line 272 of file sched.c.}\par
{
References task::context, task::cr3, task::image, krealloc(), task::length, mm_paddr(), task::ptr, uint32_t, task::vaddr, VMM_FLAGS_DEFAULT, and vmm_map().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 272                                          \{\par
273     if(!current_task)\par
274         return NULL;\par
275         \par
276     if(current_task->image.vaddr == 0)\par
277         return NULL;\par
278         \par
279     if(increment == 0)\par
280         return (void*) ((uint32_t) current_task->image.vaddr + current_task->image.length);\par
281 \par
282     current_task->image.length += increment;\par
283     current_task->image.ptr = (uint32_t) krealloc((void*) current_task->image.ptr, current_task->image.length);\par
284     current_task->image.vaddr = vmm_map(current_task->context.cr3, mm_paddr((void*) current_task->image.ptr), current_task->image.vaddr, current_task->image.length, VMM_FLAGS_DEFAULT);\par
285     \par
286     return (void*) ((uint32_t) current_task->image.vaddr + current_task->image.length);\par
287 \}\par
}
}
{\xe \v schedule_setpriority\:src/sched.c}
{\xe \v src/sched.c\:schedule_setpriority}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void schedule_setpriority (int {\i priority})}}
\par
{\bkmkstart AAAAAAABEO}
{\bkmkend AAAAAAABEO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set TTL (Time To Live) for current task. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i priority} \cell }{TTL for current task. \cell }
{\row }
}
}{
Definition at line 168 of file sched.c.}\par
{
References task::priority.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 168                                         \{\par
169     if(!current_task)\par
170         return;\par
171         \par
172     current_task->priority = priority;\par
173 \}\par
}
}
{\xe \v schedule_wait\:src/sched.c}
{\xe \v src/sched.c\:schedule_wait}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int schedule_wait ({\b task_t} * {\i child})}}
\par
{\bkmkstart AAAAAAABEP}
{\bkmkend AAAAAAABEP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Wait for child. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i child} \cell }{Task to wait. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid Exit value of child or -1 in case of error. \par
}}{
Definition at line 181 of file sched.c.}\par
{
References task::exitcode, spinlock_waiton, task::state, and TASK_STATE_DEAD.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 181                                  \{\par
182     if(!child)\par
183         return -1;\par
184         \par
185     spinlock_waiton(child->state != TASK_STATE_DEAD);\par
186     return child->exitcode;\par
187 \}\par
}
}
{\xe \v schedule_yield\:src/sched.c}
{\xe \v src/sched.c\:schedule_yield}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void schedule_yield ()}}
\par
{\bkmkstart AAAAAAABEQ}
{\bkmkend AAAAAAABEQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Perform a forced scheduling. }}\par
{
Definition at line 153 of file sched.c.}\par
{
References list_empty(), sched_enabled, schedule_next(), and task_switch().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 153                       \{\par
154     if(sched_enabled == 0)\par
155         return;\par
156         \par
157     if(list_empty(task_queue))\par
158         return;\par
159         \par
160     task_switch(schedule_next());\par
161 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v current_task\:src/sched.c}
{\xe \v src/sched.c\:current_task}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b task_t}* current_task}}
\par
{\bkmkstart AAAAAAABER}
{\bkmkend AAAAAAABER}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current task address. }}\par
{
Definition at line 35 of file sched.c.}\par
}
{\xe \v kernel_task\:src/sched.c}
{\xe \v src/sched.c\:kernel_task}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b task_t}* kernel_task}}
\par
{\bkmkstart AAAAAAABES}
{\bkmkend AAAAAAABES}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Kernel task address. }}\par
{
Definition at line 40 of file sched.c.}\par
}
{\xe \v sched_enabled\:src/sched.c}
{\xe \v src/sched.c\:sched_enabled}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int sched_enabled = 0{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABET}
{\bkmkend AAAAAAABET}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Scheduling enabled status. }}\par
{
Definition at line 52 of file sched.c.}\par
}
{\xe \v task_queue\:src/sched.c}
{\xe \v src/sched.c\:task_queue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b list_t}* task_queue}}
\par
{\bkmkstart AAAAAAABEU}
{\bkmkend AAAAAAABEU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
List of all Task. }}\par
{
Definition at line 46 of file sched.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
usr/src/libposix/src/sched.c File Reference\par \pard\plain 
{\tc\tcl2 \v usr/src/libposix/src/sched.c}
{\xe \v usr/src/libposix/src/sched.c}
{\bkmkstart AAAAAAABEV}
{\bkmkend AAAAAAABEV}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "config.h"}\par
{\f2 #include <sched.h>}\par
{\f2 #include <sys/types.h>}\par
{\f2 #include <sys/times.h>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <errno.h>}\par
{\f2 #include <time.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef int {\b cpu_set_t}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sched_setscheduler} (pid_t pid, int policy, const struct sched_param *param)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sched_getscheduler} (pid_t pid)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sched_setparam} (pid_t pid, const struct sched_param *param)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sched_getparam} (pid_t pid, struct sched_param *param)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sched_get_priority_max} (int policy)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sched_get_priority_min} (int policy)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sched_rr_get_interval} (pid_t pid, struct timespec *tp)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sched_setaffinity} (pid_t pid, size_t cpusetsize, const {\b cpu_set_t} *mask)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sched_getaffinity} (pid_t pid, size_t cpusetsize, {\b cpu_set_t} *mask)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v cpu_set_t\:usr/src/libposix/src/sched.c}
{\xe \v usr/src/libposix/src/sched.c\:cpu_set_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef int {\b cpu_set_t}}}
\par
{\bkmkstart AAAAAAABEW}
{\bkmkend AAAAAAABEW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 11 of file sched.c.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v sched_get_priority_max\:usr/src/libposix/src/sched.c}
{\xe \v usr/src/libposix/src/sched.c\:sched_get_priority_max}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int sched_get_priority_max (int {\i policy})}}
\par
{\bkmkstart AAAAAAABEX}
{\bkmkend AAAAAAABEX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 60 of file sched.c.}\par
{
References errno.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 60                                        \{\par
61     errno = ENOSYS;\par
62     return -1;\par
63 \}\par
}
}
{\xe \v sched_get_priority_min\:usr/src/libposix/src/sched.c}
{\xe \v usr/src/libposix/src/sched.c\:sched_get_priority_min}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int sched_get_priority_min (int {\i policy})}}
\par
{\bkmkstart AAAAAAABEY}
{\bkmkend AAAAAAABEY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 65 of file sched.c.}\par
{
References errno.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 65                                        \{\par
66     errno = ENOSYS;\par
67     return -1;\par
68 \}\par
}
}
{\xe \v sched_getaffinity\:usr/src/libposix/src/sched.c}
{\xe \v usr/src/libposix/src/sched.c\:sched_getaffinity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int sched_getaffinity (pid_t {\i pid}, size_t {\i cpusetsize}, {\b cpu_set_t} * {\i mask})}}
\par
{\bkmkstart AAAAAAABEZ}
{\bkmkend AAAAAAABEZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 93 of file sched.c.}\par
{
References errno.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 93                                                                      \{\par
94     errno = ENOSYS;\par
95     return -1;\par
96 \}\par
}
}
{\xe \v sched_getparam\:usr/src/libposix/src/sched.c}
{\xe \v usr/src/libposix/src/sched.c\:sched_getparam}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int sched_getparam (pid_t {\i pid}, struct sched_param * {\i param})}}
\par
{\bkmkstart AAAAAAABFA}
{\bkmkend AAAAAAABFA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 50 of file sched.c.}\par
{
References errno.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 50                                                          \{\par
51     if(pid < 0) \{\par
52         errno = EINVAL;\par
53         return -1;\par
54     \}\par
55 \par
56     errno = ENOSYS;\par
57     return -1;\par
58 \}\par
}
}
{\xe \v sched_getscheduler\:usr/src/libposix/src/sched.c}
{\xe \v usr/src/libposix/src/sched.c\:sched_getscheduler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int sched_getscheduler (pid_t {\i pid})}}
\par
{\bkmkstart AAAAAAABFB}
{\bkmkend AAAAAAABFB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 29 of file sched.c.}\par
{
References errno.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 29                                   \{\par
30     errno = ENOSYS;\par
31     return -1;\par
32 \}\par
}
}
{\xe \v sched_rr_get_interval\:usr/src/libposix/src/sched.c}
{\xe \v usr/src/libposix/src/sched.c\:sched_rr_get_interval}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int sched_rr_get_interval (pid_t {\i pid}, struct timespec * {\i tp})}}
\par
{\bkmkstart AAAAAAABFC}
{\bkmkend AAAAAAABFC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 70 of file sched.c.}\par
{
References errno.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 70                                                           \{\par
71     if(pid < 0) \{\par
72         errno = EINVAL;\par
73         return -1;\par
74     \}\par
75 \par
76     if(tp == NULL) \{\par
77         errno = EINVAL;\par
78         return -1;\par
79     \}\par
80 \par
81     tp->tv_sec = 0;\par
82     tp->tv_nsec = CLOCKS_PER_SEC / 1000000000;\par
83 \par
84     return 0;\par
85 \}\par
}
}
{\xe \v sched_setaffinity\:usr/src/libposix/src/sched.c}
{\xe \v usr/src/libposix/src/sched.c\:sched_setaffinity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int sched_setaffinity (pid_t {\i pid}, size_t {\i cpusetsize}, const {\b cpu_set_t} * {\i mask})}}
\par
{\bkmkstart AAAAAAABFD}
{\bkmkend AAAAAAABFD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 88 of file sched.c.}\par
{
References errno.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 88                                                                            \{\par
89     errno = ENOSYS;\par
90     return -1;\par
91 \}\par
}
}
{\xe \v sched_setparam\:usr/src/libposix/src/sched.c}
{\xe \v usr/src/libposix/src/sched.c\:sched_setparam}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int sched_setparam (pid_t {\i pid}, const struct sched_param * {\i param})}}
\par
{\bkmkstart AAAAAAABFE}
{\bkmkend AAAAAAABFE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 35 of file sched.c.}\par
{
References errno.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 35                                                                \{\par
36     if(param == NULL) \{\par
37         errno = EINVAL;\par
38         return -1;\par
39     \}\par
40 \par
41     if(pid < 0) \{\par
42         errno = EINVAL;\par
43         return -1;\par
44     \}\par
45 \par
46     errno = ENOSYS;\par
47     return -1;\par
48 \}\par
}
}
{\xe \v sched_setscheduler\:usr/src/libposix/src/sched.c}
{\xe \v usr/src/libposix/src/sched.c\:sched_setscheduler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int sched_setscheduler (pid_t {\i pid}, int {\i policy}, const struct sched_param * {\i param})}}
\par
{\bkmkstart AAAAAAABFF}
{\bkmkend AAAAAAABFF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 14 of file sched.c.}\par
{
References errno.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14                                                                                \{\par
15     if(param == NULL) \{\par
16         errno = EINVAL;\par
17         return -1;\par
18     \}\par
19 \par
20     if(pid < 0) \{\par
21         errno = EINVAL;\par
22         return -1;\par
23     \}\par
24 \par
25     errno = ENOSYS;\par
26     return -1;\par
27 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/spinlock.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/spinlock.c}
{\xe \v src/spinlock.c}
{\bkmkstart AAAAAAABFG}
{\bkmkend AAAAAAABFG}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
{\f2 #include <aplus/spinlock.h>}\par
{\f2 #include <aplus/list.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b spinlock_lock} ({\b spinlock_t} *spin)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Acquire a spinlock. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b spinlock_unlock} ({\b spinlock_t} *spin)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Unlock a spinlock. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b spinlock_trylock} ({\b spinlock_t} *spin)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Try to acquire a spinlock. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b __spinlock_waiton} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Yield current task if a false condition was given by {\b spinlock_waiton()}. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b __fastlock_waiton} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Put CPU in pause for a while if a false condition was given by {\b fastlock_waiton()}. }{
}\par
}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v __fastlock_waiton\:spinlock.c}
{\xe \v spinlock.c\:__fastlock_waiton}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void __fastlock_waiton ()}}
\par
{\bkmkstart AAAAAAABFH}
{\bkmkend AAAAAAABFH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Put CPU in pause for a while if a false condition was given by {\b fastlock_waiton()}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b fastlock_waiton} \par
}}{
Definition at line 76 of file spinlock.c.}\par
{
References __asm__().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 76                          \{\par
77     __asm__ __volatile__("pause");\par
78 \}\par
}
}
{\xe \v __spinlock_waiton\:spinlock.c}
{\xe \v spinlock.c\:__spinlock_waiton}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void __spinlock_waiton ()}}
\par
{\bkmkstart AAAAAAABFI}
{\bkmkend AAAAAAABFI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Yield current task if a false condition was given by {\b spinlock_waiton()}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b spinlock_waiton} \par
}}{
Definition at line 68 of file spinlock.c.}\par
{
References schedule_yield().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 68                          \{\par
69     schedule_yield();\par
70 \}\par
}
}
{\xe \v spinlock_lock\:spinlock.c}
{\xe \v spinlock.c\:spinlock_lock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void spinlock_lock ({\b spinlock_t} * {\i spin})}}
\par
{\bkmkstart AAAAAAABFJ}
{\bkmkend AAAAAAABFJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Acquire a spinlock. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i spin} \cell }{Spinlock address. \cell }
{\row }
}
}{
Definition at line 31 of file spinlock.c.}\par
{
References fastlock_waiton, SPINLOCK_FLAGS_FASTLOCK, SPINLOCK_FLAGS_LOCKED, and spinlock_waiton.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 31                                      \{\par
32     if((*spin & SPINLOCK_FLAGS_FASTLOCK) == 0)\par
33         spinlock_waiton(*spin & SPINLOCK_FLAGS_LOCKED);\par
34     else\par
35         fastlock_waiton(*spin & SPINLOCK_FLAGS_LOCKED);\par
36 \par
37     *spin |= SPINLOCK_FLAGS_LOCKED;\par
38 \}\par
}
}
{\xe \v spinlock_trylock\:spinlock.c}
{\xe \v spinlock.c\:spinlock_trylock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int spinlock_trylock ({\b spinlock_t} * {\i spin})}}
\par
{\bkmkstart AAAAAAABFK}
{\bkmkend AAAAAAABFK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Try to acquire a spinlock. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i spin} \cell }{Spinlock address. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid 0 for success else -1. \par
}}{
Definition at line 55 of file spinlock.c.}\par
{
References SPINLOCK_FLAGS_LOCKED.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 55                                        \{\par
56     if(*spin & SPINLOCK_FLAGS_LOCKED)\par
57         return -1;\par
58         \par
59     *spin |= SPINLOCK_FLAGS_LOCKED;\par
60     return 0;\par
61 \}\par
}
}
{\xe \v spinlock_unlock\:spinlock.c}
{\xe \v spinlock.c\:spinlock_unlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void spinlock_unlock ({\b spinlock_t} * {\i spin})}}
\par
{\bkmkstart AAAAAAABFL}
{\bkmkend AAAAAAABFL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Unlock a spinlock. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i spin} \cell }{Spinlock address. \cell }
{\row }
}
}{
Definition at line 45 of file spinlock.c.}\par
{
References SPINLOCK_FLAGS_LOCKED.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 45                                        \{\par
46     *spin &= ~SPINLOCK_FLAGS_LOCKED;\par
47 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/syscall/_exit.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/syscall/_exit.c}
{\xe \v src/syscall/_exit.c}
{\bkmkstart AAAAAAABFM}
{\bkmkend AAAAAAABFM}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <aplus.h>}\par
{\f2 #include <aplus/syscall.h>}\par
{\f2 #include <aplus/task.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b sys_exit} (int status)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Terminates the process normally by returning control to the host environment, but without performing any of the regular cleanup tasks for terminating processes (as function exit does).\par
 No object destructors, nor functions registered by atexit or at_quick_exit are called. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSCALL} ({\b sys_exit}, 0)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v sys_exit\:_exit.c}
{\xe \v _exit.c\:sys_exit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void sys_exit (int {\i status})}}
\par
{\bkmkstart AAAAAAABFN}
{\bkmkend AAAAAAABFN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Terminates the process normally by returning control to the host environment, but without performing any of the regular cleanup tasks for terminating processes (as function exit does).\par
 No object destructors, nor functions registered by atexit or at_quick_exit are called. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i status} \cell }{Status code.\par
 If this is 0 or EXIT_SUCCESS, it indicates success.\par
 If it is EXIT_FAILURE, it indicates failure.\par
\cell }
{\row }
}
}{
Definition at line 16 of file _exit.c.}\par
{
References schedule_exit().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 16                           \{\par
17     schedule_exit(status);\par
18 \}\par
}
}
{\xe \v SYSCALL\:_exit.c}
{\xe \v _exit.c\:SYSCALL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SYSCALL ({\b sys_exit} , 0 )}}
\par
{\bkmkstart AAAAAAABFO}
{\bkmkend AAAAAAABFO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/syscall/chown.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/syscall/chown.c}
{\xe \v src/syscall/chown.c}
{\bkmkstart AAAAAAABFP}
{\bkmkend AAAAAAABFP}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <aplus.h>}\par
{\f2 #include <aplus/syscall.h>}\par
{\f2 #include <aplus/task.h>}\par
{\f2 #include <aplus/fs.h>}\par
{\f2 #include <errno.h>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <fcntl.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sys_chown} (char *filename, uid_t owner, gid_t group)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Changes the ownership of the file specified by pathname, which is dereferenced if it is a symbolic link. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSCALL} ({\b sys_chown}, 21)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b task_t} * {\b current_task}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current task address. }{
}\par
}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v sys_chown\:chown.c}
{\xe \v chown.c\:sys_chown}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int sys_chown (char * {\i filename}, uid_t {\i owner}, gid_t {\i group})}}
\par
{\bkmkstart AAAAAAABFQ}
{\bkmkend AAAAAAABFQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Changes the ownership of the file specified by pathname, which is dereferenced if it is a symbolic link. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i filename} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i owner} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i group} \cell }{\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid On success, zero is returned. On error, \'E2\'88\'921 is returned, and errno is set appropriately. \par
}}{
Definition at line 21 of file chown.c.}\par
{
References errno, task::fd, fs_chown(), im_superuser(), kprintf(), and sys_open().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 21                                                         \{\par
22     if(!im_superuser()) \{\par
23         kprintf("sys_chown: only superuser allow to use this function.");\par
24         \par
25         errno = EACCES;\par
26         return -1;\par
27     \}\par
28     \par
29     \par
30     int fd = sys_open(filename, O_RDONLY, 0644);\par
31     if(fd < 0) \{\par
32         kprintf("sys_chown: %s.", strerror(errno));\par
33         return -1;\par
34     \}\par
35     \par
36     inode_t* ino = current_task->fd[fd];\par
37     return fs_chown(ino, owner, group);\par
38 \}\par
}
}
{\xe \v SYSCALL\:chown.c}
{\xe \v chown.c\:SYSCALL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SYSCALL ({\b sys_chown} , 21 )}}
\par
{\bkmkstart AAAAAAABFR}
{\bkmkend AAAAAAABFR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v current_task\:chown.c}
{\xe \v chown.c\:current_task}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b task_t}* current_task}}
\par
{\bkmkstart AAAAAAABFS}
{\bkmkend AAAAAAABFS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current task address. }}\par
{
Definition at line 35 of file sched.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/syscall/clone.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/syscall/clone.c}
{\xe \v src/syscall/clone.c}
{\bkmkstart AAAAAAABFT}
{\bkmkend AAAAAAABFT}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <aplus.h>}\par
{\f2 #include <aplus/syscall.h>}\par
{\f2 #include <aplus/task.h>}\par
{\f2 #include <errno.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sys_clone} (int(*fn)(void *), void *child_stack, int {\b flags}, void *arg)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new process.\par
Unlike fork(2), these calls allow the child process to share parts of its execution context with the calling process, such as the memory space, the table of file descriptors, and the table of signal handlers.\par
The main use of {\b sys_clone()} is to implement threads: multiple threads of control in a program that run concurrently in a shared memory space. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSCALL} ({\b sys_clone}, 22)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b task_t} * {\b current_task}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current task address. }{
}\par
}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v sys_clone\:clone.c}
{\xe \v clone.c\:sys_clone}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int sys_clone (int(*)(void *) {\i fn}, void * {\i child_stack}, int {\i flags}, void * {\i arg})}}
\par
{\bkmkstart AAAAAAABFU}
{\bkmkend AAAAAAABFU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new process.\par
Unlike fork(2), these calls allow the child process to share parts of its execution context with the calling process, such as the memory space, the table of file descriptors, and the table of signal handlers.\par
The main use of {\b sys_clone()} is to implement threads: multiple threads of control in a program that run concurrently in a shared memory space. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fn} \cell }{Is a pointer to a function that is called by the child process at the beginning of its execution. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i child_stack} \cell }{specifies the location of the stack used by the child process.\par
 Since the child and calling process may share memory, it is not possible for the child process to execute in the same stack as the calling process. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i flags} \cell }{\par
{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
CLONE_FILES\par
 The calling process and the child process share the same file descriptor table.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
CLONE_SIGHAND\par
 The calling process and the child process share the same table of signal handlers.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CLONE_VM}\par
 The calling process and the child process run in the same memory space. \par}
\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i arg} \cell }{Argument is passed to the fn function. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid On success, the thread ID of the child process is returned in the caller's thread of execution.\par
 On failure, -1 is returned in the caller's context, no child process will be created, and errno will be set appropriately. \par
}}{
Definition at line 32 of file clone.c.}\par
{
References errno, task::pid, and task_clone().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 32                                                                          \{\par
33     if(!current_task)\par
34         return -1;\par
35     \par
36     if(fn == NULL) \{\par
37         errno = EINVAL;\par
38         return -1;\par
39     \}\par
40 \par
41 \par
42     task_t* child = (task_t*) task_clone(fn, arg, child_stack);\par
43     if(!child) \{\par
44         errno = EFAULT;\par
45         return -1;\par
46     \}\par
47 \par
48     return child->pid;\par
49 \}\par
}
}
{\xe \v SYSCALL\:clone.c}
{\xe \v clone.c\:SYSCALL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SYSCALL ({\b sys_clone} , 22 )}}
\par
{\bkmkstart AAAAAAABFV}
{\bkmkend AAAAAAABFV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v current_task\:clone.c}
{\xe \v clone.c\:current_task}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b task_t}* current_task}}
\par
{\bkmkstart AAAAAAABFW}
{\bkmkend AAAAAAABFW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current task address. }}\par
{
Definition at line 35 of file sched.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/syscall/close.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/syscall/close.c}
{\xe \v src/syscall/close.c}
{\bkmkstart AAAAAAABFX}
{\bkmkend AAAAAAABFX}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <aplus.h>}\par
{\f2 #include <aplus/syscall.h>}\par
{\f2 #include <aplus/fs.h>}\par
{\f2 #include <aplus/task.h>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <fcntl.h>}\par
{\f2 #include <errno.h>}\par
{\f2 #include <sys/stat.h>}\par
{\f2 #include <dirent.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sys_close} (int fd)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function shall deallocate the file descriptor indicated by fildes.\par
To deallocate means to make the file descriptor available for return by subsequent calls to open() or other functions that allocate file descriptors.\par
All outstanding record locks owned by the process on the file associated with the file descriptor shall be removed (that is, unlocked). }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSCALL} ({\b sys_close}, 1)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b task_t} * {\b current_task}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current task address. }{
}\par
}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v sys_close\:close.c}
{\xe \v close.c\:sys_close}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int sys_close (int {\i fd})}}
\par
{\bkmkstart AAAAAAABFY}
{\bkmkend AAAAAAABFY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function shall deallocate the file descriptor indicated by fildes.\par
To deallocate means to make the file descriptor available for return by subsequent calls to open() or other functions that allocate file descriptors.\par
All outstanding record locks owned by the process on the file associated with the file descriptor shall be removed (that is, unlocked). }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fd} \cell }{File descriptor \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid Upon successful completion, 0 shall be returned; otherwise, -1 shall be returned and errno set to indicate the error. \par
}}{
Definition at line 26 of file close.c.}\par
{
References errno, task::fd, and kprintf().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 26                       \{\par
27     if(!current_task)\par
28         return -1;\par
29         \par
30     if(current_task->fd[fd] == 0) \{\par
31         kprintf("sys_close: fd %d not exist.", fd);\par
32         \par
33         errno = EBADF;\par
34         return -1;\par
35     \}\par
36     \par
37     current_task->fd[fd] = 0;\par
38     return 0;\par
39 \}\par
}
}
{\xe \v SYSCALL\:close.c}
{\xe \v close.c\:SYSCALL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SYSCALL ({\b sys_close} , 1 )}}
\par
{\bkmkstart AAAAAAABFZ}
{\bkmkend AAAAAAABFZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v current_task\:close.c}
{\xe \v close.c\:current_task}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b task_t}* current_task}}
\par
{\bkmkstart AAAAAAABGA}
{\bkmkend AAAAAAABGA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current task address. }}\par
{
Definition at line 35 of file sched.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/syscall/execve.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/syscall/execve.c}
{\xe \v src/syscall/execve.c}
{\bkmkstart AAAAAAABGB}
{\bkmkend AAAAAAABGB}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <aplus.h>}\par
{\f2 #include <aplus/task.h>}\par
{\f2 #include <aplus/syscall.h>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <fcntl.h>}\par
{\f2 #include <errno.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sys_execve} (char *filename, char **argv, char **{\b environ})\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Executes the program pointed to by filename.\par
 filename must be either a binary executable, or a script starting with a line of the form.\par
 #! interpreter [optional-arg]. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSCALL} ({\b sys_execve}, 2)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b task_t} * {\b current_task}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current task address. }{
}\par
}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v sys_execve\:execve.c}
{\xe \v execve.c\:sys_execve}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int sys_execve (char * {\i filename}, char ** {\i argv}, char ** {\i environ})}}
\par
{\bkmkstart AAAAAAABGC}
{\bkmkend AAAAAAABGC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Executes the program pointed to by filename.\par
 filename must be either a binary executable, or a script starting with a line of the form.\par
 #! interpreter [optional-arg]. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i filename} \cell }{executable path. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i argv} \cell }{Is an array of argument strings passed to the new program.\par
 By convention, the first of these strings should contain the filename associated with the file being executed. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i environ} \cell }{Is an array of strings, conventionally of the form key=value, which are passed as environment to the new program. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Warning:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid Both argv and environ must be terminated by a null pointer. \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid Does not return on success, and the text, data, bss, and stack of the calling process are overwritten by that of the program loaded. \par
}}{
Definition at line 27 of file execve.c.}\par
{
References task::argv, elf32_load(), environ, task::envp, errno, task::exe, task::fd, kfree(), kmalloc(), size, sys_close(), sys_lseek(), sys_open(), and sys_read().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 27                                                             \{\par
28     \par
29     int fd = sys_open(filename, O_RDONLY, 0644);\par
30     if(fd < 0) \{\par
31         errno = ENOENT;\par
32         return -1;\par
33     \}\par
34 \par
35     sys_lseek(fd, 0, SEEK_END);\par
36     size_t size = sys_lseek(fd, 0, SEEK_CUR);\par
37     sys_lseek(fd, 0, SEEK_SET);\par
38 \par
39     void* image = kmalloc(size);\par
40     if(!image) \{\par
41         sys_close(fd);\par
42 \par
43         errno = ENOMEM;\par
44         return -1;\par
45     \}\par
46 \par
47     if(sys_read(fd, image, size) < size) \{\par
48         sys_close(fd);\par
49         kfree(image);\par
50         \par
51         errno = EIO;\par
52         return -1;\par
53     \}\par
54 \par
55     \par
56 \par
57     void (*entry) () = (void (*) ()) elf32_load(image);\par
58     if(entry) \{\par
59 \par
60         current_task->exe = current_task->fd[fd];\par
61         current_task->argv = argv;\par
62         current_task->envp = environ;\par
63 \par
64         sys_close(fd);\par
65 \par
66 \par
67         entry(); /* never return */\par
68     \}\par
69 \par
70     sys_close(fd);\par
71     kfree(image);\par
72     return -1;\par
73 \}\par
}
}
{\xe \v SYSCALL\:execve.c}
{\xe \v execve.c\:SYSCALL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SYSCALL ({\b sys_execve} , 2 )}}
\par
{\bkmkstart AAAAAAABGD}
{\bkmkend AAAAAAABGD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v current_task\:execve.c}
{\xe \v execve.c\:current_task}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b task_t}* current_task}}
\par
{\bkmkstart AAAAAAABGE}
{\bkmkend AAAAAAABGE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current task address. }}\par
{
Definition at line 35 of file sched.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/syscall/fcntl.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/syscall/fcntl.c}
{\xe \v src/syscall/fcntl.c}
{\bkmkstart AAAAAAABGF}
{\bkmkend AAAAAAABGF}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <aplus.h>}\par
{\f2 #include <aplus/fs.h>}\par
{\f2 #include <aplus/syscall.h>}\par
{\f2 #include <aplus/task.h>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <fcntl.h>}\par
{\f2 #include <errno.h>}\par
{\f2 #include <sys/stat.h>}\par
{\f2 #include <dirent.h>}\par
{\f2 #include <stdio.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sys_fcntl} (int fd, int request, void *buf)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function shall perform the operations described below on open files.\par
 The available values for cmd are defined in <fcntl.h> and are as follows. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSCALL} ({\b sys_fcntl}, 19)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b task_t} * {\b current_task}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current task address. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b inode_t} * {\b vfs_root}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v sys_fcntl\:fcntl.c}
{\xe \v fcntl.c\:sys_fcntl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int sys_fcntl (int {\i fd}, int {\i request}, void * {\i buf})}}
\par
{\bkmkstart AAAAAAABGG}
{\bkmkend AAAAAAABGG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function shall perform the operations described below on open files.\par
 The available values for cmd are defined in <fcntl.h> and are as follows. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
F_DUPFD\par
{
\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
Return a new file descriptor which shall be the lowest numbered available (that is, not already open) file descriptor greater than or equal to the third argument, arg, taken as an integer of type int.\par
 The new file descriptor shall refer to the same open file description as the original file descriptor, and shall share any locks.\par
 The FD_CLOEXEC flag associated with the new file descriptor shall be cleared to keep the file open across calls to one of the exec functions.\par
\par}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
F_GETFD\par
{
\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
Get the file descriptor flags defined in <fcntl.h> that are associated with the file descriptor fildes.\par
 File descriptor flags are associated with a single file descriptor and do not affect other file descriptors that refer to the same file.\par}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
F_SETFD\par
{
\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
Set the file descriptor flags defined in <fcntl.h>, that are associated with fildes, to the third argument, arg, taken as type int.\par
 If the FD_CLOEXEC flag in the third argument is 0, the file shall remain open across the exec functions; otherwise, the file shall be closed upon successful execution of one of the exec functions.\par
\par}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
F_GETFL\par
{
\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
Get the file status flags and file access modes, defined in <fcntl.h>, for the file description associated with fildes. The file access modes can be extracted from the return value using the mask O_ACCMODE, which is defined in <fcntl.h>.\par
 File status flags and file access modes are associated with the file description and do not affect other file descriptors that refer to the same file with different open file descriptions.\par
\par}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
F_SETFL\par
{
\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
Set the file status flags, defined in <fcntl.h>, for the file description associated with fildes from the corresponding bits in the third argument, arg, taken as type int.\par
 Bits corresponding to the file access mode and the file creation flags, as defined in <fcntl.h>, that are set in arg shall be ignored. If any bits in arg other than those mentioned here are changed by the application, the result is unspecified.\par
\par}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
F_GETOWN\par
{
\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
If fildes refers to a socket, get the process or process group ID specified to receive SIGURG signals when out-of-band data is available.\par
 Positive values indicate a process ID; negative values, other than -1, indicate a process group ID.\par
 If fildes does not refer to a socket, the results are unspecified.\par
\par}
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
F_SETOWN\par
{
\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
If fildes refers to a socket, set the process or process group ID specified to receive SIGURG signals when out-of-band data is available, using the value of the third argument, arg, taken as type int.\par
 Positive values indicate a process ID; negative values, other than -1, indicate a process group ID.\par
 If fildes does not refer to a socket, the results are unspecified\par
\par
\par
\par
 {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s63\li1080\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fd} \cell }{File descriptor. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i request} \cell }{Request operation. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i buf} \cell }{Optional arguments. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s64\li1440\widctlpar\ql\adjustright \fs20\cgrid Upon successful completion, the value returned shall depend on cmd.\par
 Otherwise, -1 shall be returned and errno set to indicate the error \par
}\par}
\par}
}{
Definition at line 72 of file fcntl.c.}\par
{
References errno, task::fd, and kprintf().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 72                                               \{\par
73     if(!current_task)\par
74         return -1;\par
75         \par
76     \par
77     inode_t* ino = current_task->fd[fd];\par
78     if(!ino) \{\par
79         errno = EBADF;\par
80         return -1;\par
81     \}\par
82 \par
83 \par
84     /* TODO */\par
85     kprintf("sys_chown: TODO.");\par
86 \par
87     errno = ENOSYS;\par
88     return -1;\par
89 \}\par
}
}
{\xe \v SYSCALL\:fcntl.c}
{\xe \v fcntl.c\:SYSCALL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SYSCALL ({\b sys_fcntl} , 19 )}}
\par
{\bkmkstart AAAAAAABGH}
{\bkmkend AAAAAAABGH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v current_task\:fcntl.c}
{\xe \v fcntl.c\:current_task}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b task_t}* current_task}}
\par
{\bkmkstart AAAAAAABGI}
{\bkmkend AAAAAAABGI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current task address. }}\par
{
Definition at line 35 of file sched.c.}\par
}
{\xe \v vfs_root\:fcntl.c}
{\xe \v fcntl.c\:vfs_root}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b inode_t}* vfs_root}}
\par
{\bkmkstart AAAAAAABGJ}
{\bkmkend AAAAAAABGJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 19 of file vfs.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/syscall/fork.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/syscall/fork.c}
{\xe \v src/syscall/fork.c}
{\bkmkstart AAAAAAABGK}
{\bkmkend AAAAAAABGK}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <aplus.h>}\par
{\f2 #include <aplus/syscall.h>}\par
{\f2 #include <aplus/task.h>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <fcntl.h>}\par
{\f2 #include <errno.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sys_fork} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
fork() creates a new process by duplicating the calling process.\par
 The new process, referred to as the child, is an exact duplicate of the calling process, referred to as the parent. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSCALL} ({\b sys_fork}, 3)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v sys_fork\:fork.c}
{\xe \v fork.c\:sys_fork}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int sys_fork ()}}
\par
{\bkmkstart AAAAAAABGL}
{\bkmkend AAAAAAABGL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
fork() creates a new process by duplicating the calling process.\par
 The new process, referred to as the child, is an exact duplicate of the calling process, referred to as the parent. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid On success, the PID of the child process is returned in the parent, and 0 is returned in the child.\par
 On failure, -1 is returned in the parent, no child process is created, and errno is set appropriately. \par
}}{
Definition at line 19 of file fork.c.}\par
{
References task::pid, and task_fork().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19                \{\par
20     task_t* child = (task_t*) task_fork();\par
21     \par
22     if(child)\par
23         return child->pid;\par
24     else\par
25         return 0;\par
26 \}\par
}
}
{\xe \v SYSCALL\:fork.c}
{\xe \v fork.c\:SYSCALL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SYSCALL ({\b sys_fork} , 3 )}}
\par
{\bkmkstart AAAAAAABGM}
{\bkmkend AAAAAAABGM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/syscall/fstat.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/syscall/fstat.c}
{\xe \v src/syscall/fstat.c}
{\bkmkstart AAAAAAABGN}
{\bkmkend AAAAAAABGN}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <aplus.h>}\par
{\f2 #include <aplus/syscall.h>}\par
{\f2 #include <aplus/fs.h>}\par
{\f2 #include <aplus/task.h>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <fcntl.h>}\par
{\f2 #include <errno.h>}\par
{\f2 #include <sys/stat.h>}\par
{\f2 #include <dirent.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sys_fstat} (int fd, struct stat *st)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function shall obtain information about an open file associated with the file descriptor fildes, and shall write it to the area pointed to by buf. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSCALL} ({\b sys_fstat}, 4)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b task_t} * {\b current_task}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current task address. }{
}\par
}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v sys_fstat\:fstat.c}
{\xe \v fstat.c\:sys_fstat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int sys_fstat (int {\i fd}, struct stat * {\i st})}}
\par
{\bkmkstart AAAAAAABGO}
{\bkmkend AAAAAAABGO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function shall obtain information about an open file associated with the file descriptor fildes, and shall write it to the area pointed to by buf. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fd} \cell }{File descriptor \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i st} \cell }{Stat structure \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid Upon successful completion, 0 shall be returned.\par
 Otherwise, -1 shall be returned and errno set to indicate the error. \par
}}{
Definition at line 24 of file fstat.c.}\par
{
References inode::atime, inode::ctime, inode::dev, errno, task::fd, inode::gid, inode::ino, kprintf(), inode::mode, inode::mtime, inode::nlink, inode::rdev, inode::size, and inode::uid.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 24                                        \{\par
25     if(!st) \{\par
26         errno = EINVAL;\par
27         return -1;\par
28     \}\par
29 \par
30     inode_t* ino = current_task->fd[fd];\par
31     if(!ino) \{\par
32         kprintf("sys_fstat: %s.", strerror(errno));\par
33         errno = EBADF;\par
34         return -1;\par
35     \}\par
36     \par
37     st->st_mode = ino->mode;\par
38     st->st_ino = ino->ino;\par
39     st->st_dev = ino->dev;\par
40     st->st_uid = ino->uid;\par
41     st->st_gid = ino->gid;\par
42     st->st_atime = ino->atime;\par
43     st->st_ctime = ino->ctime;\par
44     st->st_mtime = ino->mtime;\par
45     st->st_nlink = ino->nlink;\par
46     st->st_size = ino->size;\par
47     st->st_rdev = ino->rdev;\par
48     st->st_blksize = 512;\par
49     st->st_blocks = st->st_size / st->st_blksize;\par
50     \par
51     return 0;\par
52 \}\par
}
}
{\xe \v SYSCALL\:fstat.c}
{\xe \v fstat.c\:SYSCALL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SYSCALL ({\b sys_fstat} , 4 )}}
\par
{\bkmkstart AAAAAAABGP}
{\bkmkend AAAAAAABGP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v current_task\:fstat.c}
{\xe \v fstat.c\:current_task}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b task_t}* current_task}}
\par
{\bkmkstart AAAAAAABGQ}
{\bkmkend AAAAAAABGQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current task address. }}\par
{
Definition at line 35 of file sched.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/syscall/getgroups.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/syscall/getgroups.c}
{\xe \v src/syscall/getgroups.c}
{\bkmkstart AAAAAAABGR}
{\bkmkend AAAAAAABGR}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <aplus.h>}\par
{\f2 #include <aplus/syscall.h>}\par
{\f2 #include <aplus/task.h>}\par
{\f2 #include <aplus/fs.h>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <fcntl.h>}\par
{\f2 #include <errno.h>}\par
{\f2 #include <sys/stat.h>}\par
{\f2 #include <dirent.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sys_getgroups} (int {\b length}, gid_t *{\b list})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSCALL} ({\b sys_getgroups}, 81)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b task_t} * {\b current_task}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current task address. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static gid_t {\b __groups} []\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v sys_getgroups\:getgroups.c}
{\xe \v getgroups.c\:sys_getgroups}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int sys_getgroups (int {\i length}, gid_t * {\i list})}}
\par
{\bkmkstart AAAAAAABGS}
{\bkmkend AAAAAAABGS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 18 of file getgroups.c.}\par
{
References __groups, and errno.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18                                            \{\par
19     if(length < 0) \{\par
20         errno = EINVAL;\par
21         return -1;\par
22     \}\par
23 \par
24     if(list == NULL) \{\par
25         errno = EINVAL;\par
26         return -1;\par
27     \}\par
28 \par
29     if(length == 0)\par
30         return sizeof(__groups);\par
31 \par
32     int i = 0;\par
33     for(i = 0; i < sizeof(__groups); i++) \{\par
34         if(i >= length)\par
35             break;\par
36 \par
37         list[i] = __groups[i];\par
38     \}\par
39 \par
40     return i;\par
41 \}\par
}
}
{\xe \v SYSCALL\:getgroups.c}
{\xe \v getgroups.c\:SYSCALL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SYSCALL ({\b sys_getgroups} , 81 )}}
\par
{\bkmkstart AAAAAAABGT}
{\bkmkend AAAAAAABGT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v __groups\:getgroups.c}
{\xe \v getgroups.c\:__groups}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
gid_t __groups[]{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABGU}
{\bkmkend AAAAAAABGU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    GID_SUPERUSER, 0\par
\}\par
}
{
Definition at line 14 of file getgroups.c.}\par
}
{\xe \v current_task\:getgroups.c}
{\xe \v getgroups.c\:current_task}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b task_t}* current_task}}
\par
{\bkmkstart AAAAAAABGV}
{\bkmkend AAAAAAABGV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current task address. }}\par
{
Definition at line 35 of file sched.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/syscall/getpid.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/syscall/getpid.c}
{\xe \v src/syscall/getpid.c}
{\bkmkstart AAAAAAABGW}
{\bkmkend AAAAAAABGW}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <aplus.h>}\par
{\f2 #include <aplus/syscall.h>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <fcntl.h>}\par
{\f2 #include <errno.h>}\par
{\f2 #include <sys/stat.h>}\par
{\f2 #include <dirent.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
pid_t {\b sys_getpid} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSCALL} ({\b sys_getpid}, 5)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v sys_getpid\:getpid.c}
{\xe \v getpid.c\:sys_getpid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
pid_t sys_getpid ()}}
\par
{\bkmkstart AAAAAAABGX}
{\bkmkend AAAAAAABGX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 13 of file getpid.c.}\par
{
References schedule_getpid().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13                    \{\par
14     return schedule_getpid();\par
15 \}\par
}
}
{\xe \v SYSCALL\:getpid.c}
{\xe \v getpid.c\:SYSCALL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SYSCALL ({\b sys_getpid} , 5 )}}
\par
{\bkmkstart AAAAAAABGY}
{\bkmkend AAAAAAABGY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/syscall/gettimeofday.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/syscall/gettimeofday.c}
{\xe \v src/syscall/gettimeofday.c}
{\bkmkstart AAAAAAABGZ}
{\bkmkend AAAAAAABGZ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <aplus.h>}\par
{\f2 #include <aplus/syscall.h>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <fcntl.h>}\par
{\f2 #include <errno.h>}\par
{\f2 #include <sys/stat.h>}\par
{\f2 #include <dirent.h>}\par
{\f2 #include <sys/time.h>}\par
{\f2 #include <sys/times.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sys_gettimeofday} (struct timeval *tv, struct timezone *tz)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSCALL} ({\b sys_gettimeofday}, 18)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v sys_gettimeofday\:gettimeofday.c}
{\xe \v gettimeofday.c\:sys_gettimeofday}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int sys_gettimeofday (struct timeval * {\i tv}, struct timezone * {\i tz})}}
\par
{\bkmkstart AAAAAAABHA}
{\bkmkend AAAAAAABHA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 15 of file gettimeofday.c.}\par
{
References errno, pit_getticks(), and pit_gettime().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15                                                               \{\par
16     if(!tv) \{\par
17         errno = EINVAL;\par
18         return -1;\par
19     \}\par
20     \par
21     tv->tv_sec = pit_gettime();\par
22     tv->tv_usec = pit_getticks() * 1000;\par
23     \par
24     return 0;\par
25 \}\par
}
}
{\xe \v SYSCALL\:gettimeofday.c}
{\xe \v gettimeofday.c\:SYSCALL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SYSCALL ({\b sys_gettimeofday} , 18 )}}
\par
{\bkmkstart AAAAAAABHB}
{\bkmkend AAAAAAABHB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/syscall/ioctl.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/syscall/ioctl.c}
{\xe \v src/syscall/ioctl.c}
{\bkmkstart AAAAAAABHC}
{\bkmkend AAAAAAABHC}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <aplus.h>}\par
{\f2 #include <aplus/syscall.h>}\par
{\f2 #include <aplus/task.h>}\par
{\f2 #include <aplus/fs.h>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <fcntl.h>}\par
{\f2 #include <errno.h>}\par
{\f2 #include <sys/stat.h>}\par
{\f2 #include <dirent.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sys_ioctl} (int fd, int req, void *buf)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSCALL} ({\b sys_ioctl}, 20)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b task_t} * {\b current_task}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current task address. }{
}\par
}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v sys_ioctl\:ioctl.c}
{\xe \v ioctl.c\:sys_ioctl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int sys_ioctl (int {\i fd}, int {\i req}, void * {\i buf})}}
\par
{\bkmkstart AAAAAAABHD}
{\bkmkend AAAAAAABHD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 15 of file ioctl.c.}\par
{
References errno, task::fd, and fs_ioctl().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15                                           \{\par
16 \par
17     inode_t* ino = current_task->fd[fd];\par
18     if(!ino) \{\par
19         errno = EBADF;\par
20         return -1;\par
21     \}\par
22     \par
23 \par
24     return fs_ioctl(ino, req, buf);\par
25 \}\par
}
}
{\xe \v SYSCALL\:ioctl.c}
{\xe \v ioctl.c\:SYSCALL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SYSCALL ({\b sys_ioctl} , 20 )}}
\par
{\bkmkstart AAAAAAABHE}
{\bkmkend AAAAAAABHE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v current_task\:ioctl.c}
{\xe \v ioctl.c\:current_task}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b task_t}* current_task}}
\par
{\bkmkstart AAAAAAABHF}
{\bkmkend AAAAAAABHF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current task address. }}\par
{
Definition at line 35 of file sched.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/syscall/isatty.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/syscall/isatty.c}
{\xe \v src/syscall/isatty.c}
{\bkmkstart AAAAAAABHG}
{\bkmkend AAAAAAABHG}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <aplus.h>}\par
{\f2 #include <aplus/syscall.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sys_isatty} (int fd)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSCALL} ({\b sys_isatty}, 6)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v sys_isatty\:isatty.c}
{\xe \v isatty.c\:sys_isatty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int sys_isatty (int {\i fd})}}
\par
{\bkmkstart AAAAAAABHH}
{\bkmkend AAAAAAABHH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 5 of file isatty.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5                        \{\par
6     return (fd < 3);\par
7 \}\par
}
}
{\xe \v SYSCALL\:isatty.c}
{\xe \v isatty.c\:SYSCALL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SYSCALL ({\b sys_isatty} , 6 )}}
\par
{\bkmkstart AAAAAAABHI}
{\bkmkend AAAAAAABHI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/syscall/kill.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/syscall/kill.c}
{\xe \v src/syscall/kill.c}
{\bkmkstart AAAAAAABHJ}
{\bkmkend AAAAAAABHJ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <aplus.h>}\par
{\f2 #include <aplus/syscall.h>}\par
{\f2 #include <aplus/task.h>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <fcntl.h>}\par
{\f2 #include <errno.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sys_kill} (pid_t pid, int signal)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSCALL} ({\b sys_kill}, 7)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v sys_kill\:kill.c}
{\xe \v kill.c\:sys_kill}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int sys_kill (pid_t {\i pid}, int {\i signal})}}
\par
{\bkmkstart AAAAAAABHK}
{\bkmkend AAAAAAABHK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 10 of file kill.c.}\par
{
References errno, schedule_getbypid(), and task::signal_sig.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10                                     \{\par
11     task_t* task = (task_t*) schedule_getbypid(pid);\par
12     if(!task) \{\par
13         errno = ESRCH;\par
14         return -1;\par
15     \}\par
16     \par
17     task->signal_sig = signal;\par
18     return 0;\par
19 \}\par
}
}
{\xe \v SYSCALL\:kill.c}
{\xe \v kill.c\:SYSCALL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SYSCALL ({\b sys_kill} , 7 )}}
\par
{\bkmkstart AAAAAAABHL}
{\bkmkend AAAAAAABHL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/syscall/link.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/syscall/link.c}
{\xe \v src/syscall/link.c}
{\bkmkstart AAAAAAABHM}
{\bkmkend AAAAAAABHM}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <aplus.h>}\par
{\f2 #include <aplus/syscall.h>}\par
{\f2 #include <aplus/task.h>}\par
{\f2 #include <aplus/fs.h>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <fcntl.h>}\par
{\f2 #include <errno.h>}\par
{\f2 #include <sys/stat.h>}\par
{\f2 #include <dirent.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sys_link} (char *filename, char *link)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSCALL} ({\b sys_link}, 8)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v sys_link\:link.c}
{\xe \v link.c\:sys_link}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int sys_link (char * {\i filename}, char * {\i link})}}
\par
{\bkmkstart AAAAAAABHN}
{\bkmkend AAAAAAABHN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 14 of file link.c.}\par
{
References errno, and kprintf().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14                                          \{\par
15     /* TODO */\par
16     kprintf("sys_link: TODO");\par
17 \par
18     errno = ENOSYS;\par
19     return -1;\par
20 \}\par
}
}
{\xe \v SYSCALL\:link.c}
{\xe \v link.c\:SYSCALL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SYSCALL ({\b sys_link} , 8 )}}
\par
{\bkmkstart AAAAAAABHO}
{\bkmkend AAAAAAABHO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/syscall/lseek.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/syscall/lseek.c}
{\xe \v src/syscall/lseek.c}
{\bkmkstart AAAAAAABHP}
{\bkmkend AAAAAAABHP}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <aplus.h>}\par
{\f2 #include <aplus/syscall.h>}\par
{\f2 #include <aplus/fs.h>}\par
{\f2 #include <aplus/task.h>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <fcntl.h>}\par
{\f2 #include <errno.h>}\par
{\f2 #include <sys/stat.h>}\par
{\f2 #include <dirent.h>}\par
{\f2 #include <stdio.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sys_lseek} (int fd, int pos, int dir)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSCALL} ({\b sys_lseek}, 9)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b task_t} * {\b current_task}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current task address. }{
}\par
}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v sys_lseek\:lseek.c}
{\xe \v lseek.c\:sys_lseek}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int sys_lseek (int {\i fd}, int {\i pos}, int {\i dir})}}
\par
{\bkmkstart AAAAAAABHQ}
{\bkmkend AAAAAAABHQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 18 of file lseek.c.}\par
{
References errno, task::fd, inode::position, and inode::size.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18                                         \{\par
19     inode_t* ino = current_task->fd[fd];\par
20     if(!ino) \{\par
21         errno = EBADF;\par
22         return -1;\par
23     \}\par
24     \par
25     \par
26     if(pos > ino->size)\par
27         pos = ino->size;\par
28     \par
29     switch(dir) \{\par
30         case SEEK_SET:\par
31             ino->position = pos;\par
32             break;\par
33         case SEEK_END:\par
34             ino->position = ino->size - pos;\par
35             break;\par
36         case SEEK_CUR:\par
37             ino->position = (ino->position + pos > ino->size ? ino->size : ino->position + pos);\par
38             break;\par
39         default:\par
40             errno = EINVAL;\par
41             return -1;\par
42     \}\par
43     \par
44     return ino->position;\par
45 \}\par
}
}
{\xe \v SYSCALL\:lseek.c}
{\xe \v lseek.c\:SYSCALL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SYSCALL ({\b sys_lseek} , 9 )}}
\par
{\bkmkstart AAAAAAABHR}
{\bkmkend AAAAAAABHR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v current_task\:lseek.c}
{\xe \v lseek.c\:current_task}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b task_t}* current_task}}
\par
{\bkmkstart AAAAAAABHS}
{\bkmkend AAAAAAABHS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current task address. }}\par
{
Definition at line 35 of file sched.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/syscall/mount.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/syscall/mount.c}
{\xe \v src/syscall/mount.c}
{\bkmkstart AAAAAAABHT}
{\bkmkend AAAAAAABHT}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <aplus.h>}\par
{\f2 #include <aplus/fs.h>}\par
{\f2 #include <aplus/task.h>}\par
{\f2 #include <aplus/list.h>}\par
{\f2 #include <aplus/attribute.h>}\par
{\f2 #include <aplus/syscall.h>}\par
{\f2 #include <aplus/fsys.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <dirent.h>}\par
{\f2 #include <fcntl.h>}\par
{\f2 #include <sys/types.h>}\par
{\f2 #include <errno.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sys_mount} (const char *dev, const char *dir, const char *fstype, int options, const void *{\b data})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSCALL} ({\b sys_mount}, 24)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b task_t} * {\b current_task}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current task address. }{
}\par
}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v sys_mount\:mount.c}
{\xe \v mount.c\:sys_mount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int sys_mount (const char * {\i dev}, const char * {\i dir}, const char * {\i fstype}, int {\i options}, const void * {\i data})}}
\par
{\bkmkstart AAAAAAABHU}
{\bkmkend AAAAAAABHU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 22 of file mount.c.}\par
{
References attribute(), inode::dev, errno, task::fd, fs, im_superuser(), inode::ino, list_destroy, list_empty(), list_foreach, inode::mode, fsys::mount, fsys::name, O_DIRECTORY, sys_close(), sys_open(), and value.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 22                                                                                                    \{\par
23     if(!current_task)\par
24         return -1;\par
25 \par
26 \par
27     if(!im_superuser()) \{\par
28         errno = EPERM;\par
29         return -1;\par
30     \}\par
31 \par
32 \par
33     if(dir == NULL || strlen(dir) == 0) \{\par
34         errno = EINVAL;\par
35         return -1;\par
36     \}\par
37 \par
38     inode_t* idev = NULL;\par
39     inode_t* idir = NULL;\par
40 \par
41 \par
42     if(dev && strlen(dev) > 0) \{\par
43         int dfd = sys_open(dev, O_RDONLY, 0644);\par
44         if(dfd < 0) \{\par
45             errno = ENOENT;\par
46             return -1;\par
47         \}\par
48 \par
49         idev = current_task->fd[dfd];\par
50         sys_close(dfd);\par
51     \}\par
52 \par
53 \par
54     int sfd = sys_open(dir, O_CREAT | O_DIRECTORY | O_RDONLY, S_IFDIR);\par
55     if(sfd < 0) \{\par
56         errno = ENOENT;\par
57         return -1;\par
58     \}\par
59 \par
60     idir = current_task->fd[sfd];\par
61     sys_close(sfd);\par
62 \par
63     list_t* fs = attribute("fs");\par
64     if(list_empty(fs)) \{\par
65         errno = ENODEV;\par
66         return -1;\par
67     \}\par
68     \par
69 \par
70     fsys_t* found = NULL;\par
71 \par
72     list_foreach(value, fs) \{\par
73         fsys_t* f = (fsys_t*) value;\par
74 \par
75         if(strcmp(f->name, fstype) == 0)\par
76             found = f;\par
77     \}\par
78 \par
79     list_destroy(fs);\par
80 \par
81     if(found == NULL) \{\par
82         errno = ENODEV;\par
83         return -1;\par
84     \}\par
85 \par
86     idir->mode |= S_IFMT;\par
87     idir->dev = idev->ino;\par
88 \par
89     if(found->mount(idev, idir, options) < 0) \{\par
90 \par
91         idir->mode &= ~S_IFMT;\par
92         idir->dev = 0;      \par
93 \par
94         errno = ENODEV;\par
95         return -1;\par
96     \}\par
97 \par
98     return 0;\par
99 \}\par
}
}
{\xe \v SYSCALL\:mount.c}
{\xe \v mount.c\:SYSCALL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SYSCALL ({\b sys_mount} , 24 )}}
\par
{\bkmkstart AAAAAAABHV}
{\bkmkend AAAAAAABHV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v current_task\:mount.c}
{\xe \v mount.c\:current_task}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b task_t}* current_task}}
\par
{\bkmkstart AAAAAAABHW}
{\bkmkend AAAAAAABHW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current task address. }}\par
{
Definition at line 35 of file sched.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/syscall/open.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/syscall/open.c}
{\xe \v src/syscall/open.c}
{\bkmkstart AAAAAAABHX}
{\bkmkend AAAAAAABHX}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <aplus.h>}\par
{\f2 #include <aplus/syscall.h>}\par
{\f2 #include <aplus/fs.h>}\par
{\f2 #include <aplus/task.h>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <fcntl.h>}\par
{\f2 #include <errno.h>}\par
{\f2 #include <sys/stat.h>}\par
{\f2 #include <dirent.h>}\par
{\f2 #include <stdio.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static char * {\b dupstr} (char *s)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b inode_t} * {\b ino_open} (char *filename, int {\b flags}, mode_t mode)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sys_open} (char *filename, int {\b flags}, mode_t mode)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSCALL} ({\b sys_open}, 10)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b task_t} * {\b current_task}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current task address. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b inode_t} * {\b vfs_root}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v dupstr\:open.c}
{\xe \v open.c\:dupstr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static char* dupstr (char * {\i s}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABHY}
{\bkmkend AAAAAAABHY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 19 of file open.c.}\par
{
References kmalloc().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19                              \{\par
20     char* p = (char*) kmalloc(strlen(s));\par
21     strcpy(p, s);\par
22 \par
23     return p;\par
24 \}\par
}
}
{\xe \v ino_open\:open.c}
{\xe \v open.c\:ino_open}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b inode_t}* ino_open (char * {\i filename}, int {\i flags}, mode_t {\i mode}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABHZ}
{\bkmkend AAAAAAABHZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 27 of file open.c.}\par
{
References task::cwd, errno, fs_creat(), fs_finddir(), kprintf(), inode::link, inode::mode, O_DIRECTORY, O_NOFOLLOW, and vfs_root.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 27                                                                  \{\par
28     inode_t* cwd = NULL;\par
29 \par
30     if(filename[0] == '/')\par
31         cwd = vfs_root;\par
32     else\par
33         cwd = current_task->cwd;\par
34     \par
35     if(!cwd) \{\par
36         if(!vfs_root) \{\par
37             kprintf("sys_open: no root found for cwd.");\par
38         \par
39             errno = ENOENT;\par
40             return NULL;\par
41         \}\par
42         \par
43         cwd = vfs_root;\par
44     \}\par
45     \par
46     \par
47     if(filename[0] == '/')\par
48         filename++;\par
49         \par
50     if(filename[0] == 0)\par
51         return cwd;\par
52         \par
53     \par
54     char* s = filename;\par
55     char* p = s;\par
56     \par
57     while(*s) \{\par
58         if((p = strchr(s, '/'))) \{\par
59             *p++ = 0;\par
60         \par
61             cwd = (inode_t*) fs_finddir(cwd, s);\par
62             if(!cwd) \{\par
63                 errno = ENOENT;\par
64                 return NULL;\par
65             \}\par
66 \par
67             while(S_ISLNK(cwd->mode))\par
68                 if(cwd->link)\par
69                     cwd = cwd->link;\par
70                 else\par
71                     break;\par
72 \par
73             s = p;\par
74         \} else\par
75             break;\par
76     \}\par
77 \par
78     if(*s == 0) \{\par
79         errno = ENOENT;\par
80         return NULL;\par
81     \}\par
82 \par
83     inode_t* ent = (inode_t*) fs_finddir(cwd, s);\par
84 \par
85     if(flags & O_EXCL) \{\par
86         if(ent) \{\par
87             errno = EEXIST;\par
88             return NULL;\par
89         \}\par
90     \}\par
91 \par
92 \par
93     if(flags & O_CREAT)\par
94         if(!ent)\par
95             ent = (inode_t*) fs_creat(cwd, s, mode);\par
96         \par
97 \par
98     if(!ent) \{\par
99         errno = ENOENT;\par
100         return NULL;\par
101     \}\par
102 \par
103     if(!(flags & O_NOFOLLOW)) \{\par
104         while(S_ISLNK(ent->mode)) \{\par
105             if(ent == ent->link) \{\par
106                 errno = ELOOP;\par
107                 return NULL;\par
108             \}           \par
109 \par
110             if(ent->link)\par
111                 ent = ent->link;\par
112             else\par
113                 break;\par
114         \}\par
115     \}\par
116 \par
117     if(flags & O_DIRECTORY) \{\par
118         if(!(S_ISDIR(ent->mode))) \{\par
119             errno = ENOTDIR;\par
120             return NULL;\par
121         \}\par
122     \}\par
123 \par
124     return ent;\par
125 \}\par
}
}
{\xe \v sys_open\:open.c}
{\xe \v open.c\:sys_open}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int sys_open (char * {\i filename}, int {\i flags}, mode_t {\i mode})}}
\par
{\bkmkstart AAAAAAABIA}
{\bkmkend AAAAAAABIA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 127 of file open.c.}\par
{
References dupstr(), errno, task::fd, ino_open(), kfree(), and TASK_MAX_FD.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 127                                                      \{\par
128     if(!current_task)\par
129         return -1;\par
130 \par
131     char* p = dupstr(filename);\par
132     inode_t* ino = ino_open(p, flags, mode);\par
133 \par
134     kfree(p);\par
135 \par
136     if(!ino)\par
137         return -1;\par
138     \par
139     \par
140     inode_t** fd = NULL;\par
141     for(int i = 0; i < TASK_MAX_FD; i++) \{\par
142         if(current_task->fd[i] == 0) \{\par
143             fd = &current_task->fd[i];\par
144             break;\par
145         \}\par
146     \}\par
147     \par
148     if(fd == NULL) \{\par
149         errno = EMFILE;\par
150         return -1;\par
151     \}\par
152     \par
153     *fd = ino;\par
154     return 0;\par
155 \}\par
}
}
{\xe \v SYSCALL\:open.c}
{\xe \v open.c\:SYSCALL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SYSCALL ({\b sys_open} , 10 )}}
\par
{\bkmkstart AAAAAAABIB}
{\bkmkend AAAAAAABIB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v current_task\:open.c}
{\xe \v open.c\:current_task}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b task_t}* current_task}}
\par
{\bkmkstart AAAAAAABIC}
{\bkmkend AAAAAAABIC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current task address. }}\par
{
Definition at line 35 of file sched.c.}\par
}
{\xe \v vfs_root\:open.c}
{\xe \v open.c\:vfs_root}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b inode_t}* vfs_root}}
\par
{\bkmkstart AAAAAAABID}
{\bkmkend AAAAAAABID}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 19 of file vfs.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/syscall/read.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/syscall/read.c}
{\xe \v src/syscall/read.c}
{\bkmkstart AAAAAAABIE}
{\bkmkend AAAAAAABIE}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <aplus.h>}\par
{\f2 #include <aplus/fs.h>}\par
{\f2 #include <aplus/syscall.h>}\par
{\f2 #include <aplus/task.h>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <fcntl.h>}\par
{\f2 #include <errno.h>}\par
{\f2 #include <sys/stat.h>}\par
{\f2 #include <dirent.h>}\par
{\f2 #include <stdio.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sys_read} (int fd, void *ptr, size_t {\b size})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSCALL} ({\b sys_read}, 11)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b task_t} * {\b current_task}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current task address. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b inode_t} * {\b vfs_root}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v sys_read\:read.c}
{\xe \v read.c\:sys_read}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int sys_read (int {\i fd}, void * {\i ptr}, size_t {\i size})}}
\par
{\bkmkstart AAAAAAABIF}
{\bkmkend AAAAAAABIF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 19 of file read.c.}\par
{
References errno, task::fd, and fs_read().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19                                              \{\par
20     if(!current_task)\par
21         return -1;\par
22         \par
23     \par
24     inode_t* ino = current_task->fd[fd];\par
25     if(!ino) \{\par
26         errno = EBADF;\par
27         return -1;\par
28     \}\par
29 \par
30 \par
31     return fs_read(ino, ptr, size);\par
32 \}\par
}
}
{\xe \v SYSCALL\:read.c}
{\xe \v read.c\:SYSCALL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SYSCALL ({\b sys_read} , 11 )}}
\par
{\bkmkstart AAAAAAABIG}
{\bkmkend AAAAAAABIG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v current_task\:read.c}
{\xe \v read.c\:current_task}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b task_t}* current_task}}
\par
{\bkmkstart AAAAAAABIH}
{\bkmkend AAAAAAABIH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current task address. }}\par
{
Definition at line 35 of file sched.c.}\par
}
{\xe \v vfs_root\:read.c}
{\xe \v read.c\:vfs_root}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b inode_t}* vfs_root}}
\par
{\bkmkstart AAAAAAABII}
{\bkmkend AAAAAAABII}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 19 of file vfs.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/syscall/readdir.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/syscall/readdir.c}
{\xe \v src/syscall/readdir.c}
{\bkmkstart AAAAAAABIJ}
{\bkmkend AAAAAAABIJ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <aplus.h>}\par
{\f2 #include <aplus/syscall.h>}\par
{\f2 #include <aplus/task.h>}\par
{\f2 #include <errno.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b dirent} * {\b sys_readdir} (int fd, int position)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSCALL} ({\b sys_readdir}, 80)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b task_t} * {\b current_task}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current task address. }{
}\par
}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v sys_readdir\:src/syscall/readdir.c}
{\xe \v src/syscall/readdir.c\:sys_readdir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b dirent}* sys_readdir (int {\i fd}, int {\i position})}}
\par
{\bkmkstart AAAAAAABIK}
{\bkmkend AAAAAAABIK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9 of file readdir.c.}\par
{
References errno, task::fd, and fs_readdir().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 9                                                  \{\par
10     if(!current_task)\par
11         return NULL;\par
12         \par
13     \par
14     inode_t* ino = current_task->fd[fd];\par
15     if(!ino) \{\par
16         errno = EBADF;\par
17         return NULL;\par
18     \}\par
19 \par
20 \par
21     return (struct dirent*) fs_readdir(ino, position);\par
22 \}\par
}
}
{\xe \v SYSCALL\:src/syscall/readdir.c}
{\xe \v src/syscall/readdir.c\:SYSCALL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SYSCALL ({\b sys_readdir} , 80 )}}
\par
{\bkmkstart AAAAAAABIL}
{\bkmkend AAAAAAABIL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v current_task\:src/syscall/readdir.c}
{\xe \v src/syscall/readdir.c\:current_task}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b task_t}* current_task}}
\par
{\bkmkstart AAAAAAABIM}
{\bkmkend AAAAAAABIM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current task address. }}\par
{
Definition at line 35 of file sched.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
usr/src/libposix/src/readdir.c File Reference\par \pard\plain 
{\tc\tcl2 \v usr/src/libposix/src/readdir.c}
{\xe \v usr/src/libposix/src/readdir.c}
{\bkmkstart AAAAAAABIN}
{\bkmkend AAAAAAABIN}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <dirent.h>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <fcntl.h>}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <errno.h>}\par
{\f2 #include "config.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b dirent} * {\b readdir} ({\b DIR} *{\b d})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v readdir\:usr/src/libposix/src/readdir.c}
{\xe \v usr/src/libposix/src/readdir.c\:readdir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b dirent}* readdir ({\b DIR} * {\i d})}}
\par
{\bkmkstart AAAAAAABIO}
{\bkmkend AAAAAAABIO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 15 of file readdir.c.}\par
{
References errno.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15                                \{\par
16     if(d == NULL) \{\par
17         errno = EINVAL;\par
18         return NULL;\par
19     \}\par
20 \par
21     return __os_readdir(d);\par
22 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/syscall/sbrk.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/syscall/sbrk.c}
{\xe \v src/syscall/sbrk.c}
{\bkmkstart AAAAAAABIP}
{\bkmkend AAAAAAABIP}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <aplus.h>}\par
{\f2 #include <aplus/syscall.h>}\par
{\f2 #include <aplus/task.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b sys_sbrk} (ptrdiff_t increment)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSCALL} ({\b sys_sbrk}, 12)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v sys_sbrk\:sbrk.c}
{\xe \v sbrk.c\:sys_sbrk}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* sys_sbrk (ptrdiff_t {\i increment})}}
\par
{\bkmkstart AAAAAAABIQ}
{\bkmkend AAAAAAABIQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 6 of file sbrk.c.}\par
{
References schedule_sbrk().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6                                     \{\par
7     return (void*) schedule_sbrk(increment);\par
8 \}\par
}
}
{\xe \v SYSCALL\:sbrk.c}
{\xe \v sbrk.c\:SYSCALL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SYSCALL ({\b sys_sbrk} , 12 )}}
\par
{\bkmkstart AAAAAAABIR}
{\bkmkend AAAAAAABIR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/syscall/stat.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/syscall/stat.c}
{\xe \v src/syscall/stat.c}
{\bkmkstart AAAAAAABIS}
{\bkmkend AAAAAAABIS}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <aplus.h>}\par
{\f2 #include <aplus/syscall.h>}\par
{\f2 #include <aplus/fs.h>}\par
{\f2 #include <aplus/task.h>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <fcntl.h>}\par
{\f2 #include <errno.h>}\par
{\f2 #include <sys/stat.h>}\par
{\f2 #include <dirent.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sys_stat} (const char *filename, struct stat *st)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSCALL} ({\b sys_stat}, 13)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b task_t} * {\b current_task}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current task address. }{
}\par
}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v sys_stat\:stat.c}
{\xe \v stat.c\:sys_stat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int sys_stat (const char * {\i filename}, struct stat * {\i st})}}
\par
{\bkmkstart AAAAAAABIT}
{\bkmkend AAAAAAABIT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 15 of file stat.c.}\par
{
References errno, kprintf(), sys_close(), sys_fstat(), and sys_open().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15                                                     \{\par
16     int fd = sys_open(filename, O_RDONLY, 0644);\par
17     if(fd < 0) \{\par
18         kprintf("sys_stat: %s.", strerror(errno));      \par
19         return -1;\par
20     \}\par
21     int ret = sys_fstat(fd, st);\par
22     sys_close(fd);\par
23 \par
24     return ret;\par
25 \}\par
}
}
{\xe \v SYSCALL\:stat.c}
{\xe \v stat.c\:SYSCALL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SYSCALL ({\b sys_stat} , 13 )}}
\par
{\bkmkstart AAAAAAABIU}
{\bkmkend AAAAAAABIU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v current_task\:stat.c}
{\xe \v stat.c\:current_task}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b task_t}* current_task}}
\par
{\bkmkstart AAAAAAABIV}
{\bkmkend AAAAAAABIV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current task address. }}\par
{
Definition at line 35 of file sched.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/syscall/time.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/syscall/time.c}
{\xe \v src/syscall/time.c}
{\bkmkstart AAAAAAABIW}
{\bkmkend AAAAAAABIW}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <aplus.h>}\par
{\f2 #include <aplus/syscall.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <time.h>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <sys/time.h>}\par
{\f2 #include <sys/times.h>}\par
{\f2 #include <sys/types.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
time_t {\b sys_time} (time_t *ptr)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v sys_time\:time.c}
{\xe \v time.c\:sys_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
time_t sys_time (time_t * {\i ptr})}}
\par
{\bkmkstart AAAAAAABIX}
{\bkmkend AAAAAAABIX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 12 of file time.c.}\par
{
References sys_gettimeofday().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12                              \{\par
13     \par
14     struct timeval tv;\par
15     struct timezone tz;\par
16 \par
17     sys_gettimeofday(&tv, &tz);\par
18 \par
19 \par
20     if(ptr)\par
21         *ptr = tv.tv_sec;\par
22 \par
23     return tv.tv_sec;\par
24 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/syscall/times.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/syscall/times.c}
{\xe \v src/syscall/times.c}
{\bkmkstart AAAAAAABIY}
{\bkmkend AAAAAAABIY}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <aplus.h>}\par
{\f2 #include <aplus/syscall.h>}\par
{\f2 #include <aplus/fs.h>}\par
{\f2 #include <aplus/task.h>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <fcntl.h>}\par
{\f2 #include <errno.h>}\par
{\f2 #include <sys/times.h>}\par
{\f2 #include <time.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
clock_t {\b sys_times} (struct tms *tm)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSCALL} ({\b sys_times}, 14)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b task_t} * {\b current_task}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current task address. }{
}\par
}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v sys_times\:times.c}
{\xe \v times.c\:sys_times}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
clock_t sys_times (struct tms * {\i tm})}}
\par
{\bkmkstart AAAAAAABIZ}
{\bkmkend AAAAAAABIZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 15 of file times.c.}\par
{
References task::clock, pit_getticks(), and schedule_child().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15                                   \{\par
16     if(tm == NULL) \par
17         return (clock_t) pit_getticks();\par
18     \par
19 \par
20     tm->tms_utime = current_task->clock;\par
21     tm->tms_stime = 0;\par
22     tm->tms_cstime = 0;\par
23 \par
24     \par
25     task_t* child = (task_t*) schedule_child();\par
26     if(child)\par
27         tm->tms_cutime = current_task->clock + child->clock;\par
28      else \par
29         tm->tms_cutime = 0;\par
30 \par
31 \par
32     return (clock_t) pit_getticks();\par
33 \}\par
}
}
{\xe \v SYSCALL\:times.c}
{\xe \v times.c\:SYSCALL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SYSCALL ({\b sys_times} , 14 )}}
\par
{\bkmkstart AAAAAAABJA}
{\bkmkend AAAAAAABJA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v current_task\:times.c}
{\xe \v times.c\:current_task}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b task_t}* current_task}}
\par
{\bkmkstart AAAAAAABJB}
{\bkmkend AAAAAAABJB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current task address. }}\par
{
Definition at line 35 of file sched.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/syscall/umount.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/syscall/umount.c}
{\xe \v src/syscall/umount.c}
{\bkmkstart AAAAAAABJC}
{\bkmkend AAAAAAABJC}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <aplus.h>}\par
{\f2 #include <aplus/fs.h>}\par
{\f2 #include <aplus/task.h>}\par
{\f2 #include <aplus/list.h>}\par
{\f2 #include <aplus/attribute.h>}\par
{\f2 #include <aplus/syscall.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <dirent.h>}\par
{\f2 #include <fcntl.h>}\par
{\f2 #include <sys/types.h>}\par
{\f2 #include <errno.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sys_umount2} (const char *file, int {\b flags})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sys_umount} (const char *file)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSCALL} ({\b sys_umount}, 25)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSCALL} ({\b sys_umount2}, 26)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b task_t} * {\b current_task}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current task address. }{
}\par
}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v sys_umount\:umount.c}
{\xe \v umount.c\:sys_umount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int sys_umount (const char * {\i file})}}
\par
{\bkmkstart AAAAAAABJD}
{\bkmkend AAAAAAABJD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 48 of file umount.c.}\par
{
References sys_umount2().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 48                                  \{\par
49     return sys_umount2(file, 0);\par
50 \}\par
}
}
{\xe \v sys_umount2\:umount.c}
{\xe \v umount.c\:sys_umount2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int sys_umount2 (const char * {\i file}, int {\i flags})}}
\par
{\bkmkstart AAAAAAABJE}
{\bkmkend AAAAAAABJE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 20 of file umount.c.}\par
{
References inode::chown, inode::creat, inode::dev, errno, task::fd, inode::finddir, inode::flush, inode::mode, inode::readdir, sys_close(), sys_open(), and inode::unlink.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20                                              \{\par
21     if(!file) \{\par
22         errno = EINVAL;\par
23         return -1;\par
24     \}\par
25 \par
26     int fd = sys_open(file, O_RDONLY, 0644);\par
27     if(fd < 0) \{\par
28         errno = ENOENT;\par
29         return -1;\par
30     \}\par
31 \par
32     inode_t* ino = current_task->fd[fd];\par
33     sys_close(fd);\par
34 \par
35     ino->readdir = NULL;\par
36     ino->finddir = NULL;\par
37     ino->creat = NULL;\par
38     ino->unlink = NULL;\par
39     ino->flush = NULL;\par
40     ino->chown = NULL;\par
41 \par
42     ino->dev = (dev_t) 0;\par
43     ino->mode &= ~S_IFMT;\par
44 \par
45     return 0;\par
46 \}\par
}
}
{\xe \v SYSCALL\:umount.c}
{\xe \v umount.c\:SYSCALL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SYSCALL ({\b sys_umount} , 25 )}}
\par
{\bkmkstart AAAAAAABJF}
{\bkmkend AAAAAAABJF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v SYSCALL\:umount.c}
{\xe \v umount.c\:SYSCALL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SYSCALL ({\b sys_umount2} , 26 )}}
\par
{\bkmkstart AAAAAAABJG}
{\bkmkend AAAAAAABJG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v current_task\:umount.c}
{\xe \v umount.c\:current_task}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b task_t}* current_task}}
\par
{\bkmkstart AAAAAAABJH}
{\bkmkend AAAAAAABJH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current task address. }}\par
{
Definition at line 35 of file sched.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/syscall/unlink.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/syscall/unlink.c}
{\xe \v src/syscall/unlink.c}
{\bkmkstart AAAAAAABJI}
{\bkmkend AAAAAAABJI}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <aplus.h>}\par
{\f2 #include <aplus/syscall.h>}\par
{\f2 #include <aplus/fs.h>}\par
{\f2 #include <aplus/task.h>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <fcntl.h>}\par
{\f2 #include <errno.h>}\par
{\f2 #include <sys/stat.h>}\par
{\f2 #include <dirent.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sys_unlink} (const char *pathname)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSCALL} ({\b sys_unlink}, 15)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v sys_unlink\:unlink.c}
{\xe \v unlink.c\:sys_unlink}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int sys_unlink (const char * {\i pathname})}}
\par
{\bkmkstart AAAAAAABJJ}
{\bkmkend AAAAAAABJJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 13 of file unlink.c.}\par
{
References errno, and kprintf().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13                                      \{\par
14     /* TODO */\par
15     kprintf("sys_unlink: TODO");\par
16 \par
17     errno = ENOSYS;\par
18     return -1;\par
19 \}\par
}
}
{\xe \v SYSCALL\:unlink.c}
{\xe \v unlink.c\:SYSCALL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SYSCALL ({\b sys_unlink} , 15 )}}
\par
{\bkmkstart AAAAAAABJK}
{\bkmkend AAAAAAABJK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/syscall/wait.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/syscall/wait.c}
{\xe \v src/syscall/wait.c}
{\bkmkstart AAAAAAABJL}
{\bkmkend AAAAAAABJL}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <aplus.h>}\par
{\f2 #include <aplus/syscall.h>}\par
{\f2 #include <aplus/fs.h>}\par
{\f2 #include <aplus/task.h>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <fcntl.h>}\par
{\f2 #include <errno.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sys_wait} (int *status)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSCALL} ({\b sys_wait}, 16)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b task_t} * {\b current_task}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current task address. }{
}\par
}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v sys_wait\:wait.c}
{\xe \v wait.c\:sys_wait}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int sys_wait (int * {\i status})}}
\par
{\bkmkstart AAAAAAABJM}
{\bkmkend AAAAAAABJM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 12 of file wait.c.}\par
{
References errno, task::pid, schedule_child(), and schedule_wait().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12                           \{\par
13     if(current_task == NULL) \{\par
14         errno = EFAULT;\par
15         return -1;\par
16     \}\par
17 \par
18     task_t* child = (task_t*) schedule_child();\par
19     if(child == NULL) \{\par
20         errno = ECHILD;\par
21         return -1;\par
22     \}\par
23 \par
24     int exitcode = schedule_wait(child);\par
25 \par
26     if(status)\par
27         *status = exitcode;\par
28 \par
29     return child->pid;\par
30 \}\par
}
}
{\xe \v SYSCALL\:wait.c}
{\xe \v wait.c\:SYSCALL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SYSCALL ({\b sys_wait} , 16 )}}
\par
{\bkmkstart AAAAAAABJN}
{\bkmkend AAAAAAABJN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v current_task\:wait.c}
{\xe \v wait.c\:current_task}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b task_t}* current_task}}
\par
{\bkmkstart AAAAAAABJO}
{\bkmkend AAAAAAABJO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current task address. }}\par
{
Definition at line 35 of file sched.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/syscall/write.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/syscall/write.c}
{\xe \v src/syscall/write.c}
{\bkmkstart AAAAAAABJP}
{\bkmkend AAAAAAABJP}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <aplus.h>}\par
{\f2 #include <aplus/fs.h>}\par
{\f2 #include <aplus/syscall.h>}\par
{\f2 #include <aplus/task.h>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <fcntl.h>}\par
{\f2 #include <errno.h>}\par
{\f2 #include <sys/stat.h>}\par
{\f2 #include <dirent.h>}\par
{\f2 #include <stdio.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sys_write} (int fd, void *ptr, size_t {\b size})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSCALL} ({\b sys_write}, 17)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b task_t} * {\b current_task}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current task address. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b inode_t} * {\b vfs_root}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v sys_write\:write.c}
{\xe \v write.c\:sys_write}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int sys_write (int {\i fd}, void * {\i ptr}, size_t {\i size})}}
\par
{\bkmkstart AAAAAAABJQ}
{\bkmkend AAAAAAABJQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 19 of file write.c.}\par
{
References errno, task::fd, and fs_write().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19                                               \{\par
20     if(!current_task)\par
21         return -1;\par
22         \par
23     \par
24     inode_t* ino = current_task->fd[fd];\par
25     if(!ino) \{\par
26         errno = EBADF;\par
27         return -1;\par
28     \}\par
29 \par
30 \par
31     return fs_write(ino, ptr, size);\par
32 \}\par
}
}
{\xe \v SYSCALL\:write.c}
{\xe \v write.c\:SYSCALL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SYSCALL ({\b sys_write} , 17 )}}
\par
{\bkmkstart AAAAAAABJR}
{\bkmkend AAAAAAABJR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v current_task\:write.c}
{\xe \v write.c\:current_task}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b task_t}* current_task}}
\par
{\bkmkstart AAAAAAABJS}
{\bkmkend AAAAAAABJS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current task address. }}\par
{
Definition at line 35 of file sched.c.}\par
}
{\xe \v vfs_root\:write.c}
{\xe \v write.c\:vfs_root}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b inode_t}* vfs_root}}
\par
{\bkmkstart AAAAAAABJT}
{\bkmkend AAAAAAABJT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 19 of file vfs.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/syscall/yield.c File Reference\par \pard\plain 
{\tc\tcl2 \v src/syscall/yield.c}
{\xe \v src/syscall/yield.c}
{\bkmkstart AAAAAAABJU}
{\bkmkend AAAAAAABJU}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <aplus.h>}\par
{\f2 #include <aplus/syscall.h>}\par
{\f2 #include <aplus/task.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b sys_yield} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SYSCALL} ({\b sys_yield}, 82)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v sys_yield\:yield.c}
{\xe \v yield.c\:sys_yield}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void sys_yield ()}}
\par
{\bkmkstart AAAAAAABJV}
{\bkmkend AAAAAAABJV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 6 of file yield.c.}\par
{
References schedule_yield().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6                  \{\par
7     schedule_yield();\par
8 \}\par
}
}
{\xe \v SYSCALL\:yield.c}
{\xe \v yield.c\:SYSCALL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SYSCALL ({\b sys_yield} , 82 )}}
\par
{\bkmkstart AAAAAAABJW}
{\bkmkend AAAAAAABJW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
usr/src/libcrt0/src/crt0.c File Reference\par \pard\plain 
{\tc\tcl2 \v usr/src/libcrt0/src/crt0.c}
{\xe \v usr/src/libcrt0/src/crt0.c}
{\bkmkstart AAAAAAABJX}
{\bkmkend AAAAAAABJX}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "syscalls.c"}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <signal.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} (int, char **, char **)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b __sigtramp} (int sig)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b __default_sighandler__} (int sig)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b __init_traps} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b __attribute__} ((noreturn))\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char ** {\b environ}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b __bss_start}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b _end}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v __attribute__\:crt0.c}
{\xe \v crt0.c\:__attribute__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__attribute__ ((noreturn) )}}
\par
{\bkmkstart AAAAAAABJY}
{\bkmkend AAAAAAABJY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 61 of file crt0.c.}\par
{
References __bss_start, __init_traps(), __sigtramp(), _end, environ, and main().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 62               \{\par
63     \par
64     int i;\par
65     for(i = (int) &__bss_start; i < (int) &_end; i++)\par
66         *(char*) i = 0;\par
67 \par
68 \par
69     environ = (char**) aplus_envp();\par
70     char** argv = (char**) aplus_argv();\par
71 \par
72     int argc = 0;\par
73     while(argv[argc])\par
74         argc += 1;\par
75 \par
76 \par
77     open("/dev/stdin", 0, 0644);\par
78     open("/dev/stdout", 0, 0644);\par
79     open("/dev/stderr", 0, 0644);\par
80 \par
81 \par
82     aplus_install_sighandler(__sigtramp);\par
83     _init_signal();\par
84     __init_traps();\par
85 \par
86 #if 0\par
87     atexit(__do_global_dtors);\par
88     __do_global_ctors();\par
89 #endif\par
90 \par
91     exit(main(argc, argv, environ));\par
92 \}\par
}
}
{\xe \v __default_sighandler__\:crt0.c}
{\xe \v crt0.c\:__default_sighandler__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int __default_sighandler__ (int {\i sig}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABJZ}
{\bkmkend AAAAAAABJZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 17 of file crt0.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17                                            \{\par
18     signal(sig, __default_sighandler__);\par
19     exit(sig);\par
20 \}\par
}
}
{\xe \v __init_traps\:crt0.c}
{\xe \v crt0.c\:__init_traps}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void __init_traps (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABKA}
{\bkmkend AAAAAAABKA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 51 of file crt0.c.}\par
{
References __default_sighandler__().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 51                            \{\par
52     signal(SIGABRT, __default_sighandler__);\par
53     signal(SIGFPE, __default_sighandler__);\par
54     signal(SIGILL, __default_sighandler__);\par
55     signal(SIGINT, __default_sighandler__);\par
56     signal(SIGSEGV, __default_sighandler__);\par
57     signal(SIGTERM, __default_sighandler__);\par
58 \}\par
}
}
{\xe \v __sigtramp\:crt0.c}
{\xe \v crt0.c\:__sigtramp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int __sigtramp (int {\i sig})}}
\par
{\bkmkstart AAAAAAABKB}
{\bkmkend AAAAAAABKB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v main\:crt0.c}
{\xe \v crt0.c\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main (int , char ** , char ** )}}
\par
{\bkmkstart AAAAAAABKC}
{\bkmkend AAAAAAABKC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v __bss_start\:crt0.c}
{\xe \v crt0.c\:__bss_start}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int __bss_start}}
\par
{\bkmkstart AAAAAAABKD}
{\bkmkend AAAAAAABKD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _end\:crt0.c}
{\xe \v crt0.c\:_end}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int _end}}
\par
{\bkmkstart AAAAAAABKE}
{\bkmkend AAAAAAABKE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v environ\:crt0.c}
{\xe \v crt0.c\:environ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char** environ}}
\par
{\bkmkstart AAAAAAABKF}
{\bkmkend AAAAAAABKF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3 of file environ.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
usr/src/libcrt0/src/syscalls.c File Reference\par \pard\plain 
{\tc\tcl2 \v usr/src/libcrt0/src/syscalls.c}
{\xe \v usr/src/libcrt0/src/syscalls.c}
{\bkmkstart AAAAAAABKG}
{\bkmkend AAAAAAABKG}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <errno.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SYSCODE}\~ "int $0x80"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b syscall0}(n, h)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b syscall1}(n, h)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b syscall2}(n, h)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b syscall3}(n, h)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b syscall4}(n, h)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b syscall5}(n, h)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v syscall0\:syscalls.c}
{\xe \v syscalls.c\:syscall0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define syscall0( n,  h)}}
\par
{\bkmkstart AAAAAAABKH}
{\bkmkend AAAAAAABKH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid h() \{                               \\\par
        int r, e;                           \\\par
        __asm__ __volatile__ (          \\\par
            SYSCODE                     \\\par
            : "=a"(r), "=b"(e)  \\\par
            : "a"(n)                    \\\par
        );                              \\\par
        errno = e;                      \\\par
        return r;                       \\\par
    \}\par
}
{
Definition at line 5 of file syscalls.c.}\par
}
{\xe \v syscall1\:syscalls.c}
{\xe \v syscalls.c\:syscall1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define syscall1( n,  h)}}
\par
{\bkmkstart AAAAAAABKI}
{\bkmkend AAAAAAABKI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid h(p1) \{                             \\\par
        int r, e;                           \\\par
        __asm__ __volatile__ (          \\\par
            SYSCODE                     \\\par
            : "=a"(r), "=b"(e)  \\\par
            : "a"(n), "b"(p1)           \\\par
        );                              \\\par
        errno = e;                      \\\par
        return r;                       \\\par
    \}\par
}
{
Definition at line 17 of file syscalls.c.}\par
}
{\xe \v syscall2\:syscalls.c}
{\xe \v syscalls.c\:syscall2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define syscall2( n,  h)}}
\par
{\bkmkstart AAAAAAABKJ}
{\bkmkend AAAAAAABKJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid h(p1, p2) \{                         \\\par
        int r, e;                           \\\par
        __asm__ __volatile__ (          \\\par
            SYSCODE                     \\\par
            : "=a"(r), "=b"(e)  \\\par
            : "a"(n), "b"(p1), "c"(p2)  \\\par
        );                              \\\par
        errno = e;                      \\\par
        return r;                       \\\par
    \}\par
}
{
Definition at line 29 of file syscalls.c.}\par
}
{\xe \v syscall3\:syscalls.c}
{\xe \v syscalls.c\:syscall3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define syscall3( n,  h)}}
\par
{\bkmkstart AAAAAAABKK}
{\bkmkend AAAAAAABKK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid h(p1, p2, p3) \{                     \\\par
        int r, e;                           \\\par
        __asm__ __volatile__ (          \\\par
            SYSCODE                     \\\par
            : "=a"(r), "=b"(e)  \\\par
            : "a"(n), "b"(p1), "c"(p2), \\\par
              "d"(p3)                   \\\par
        );                              \\\par
        errno = e;                      \\\par
        return r;                       \\\par
    \}\par
}
{
Definition at line 41 of file syscalls.c.}\par
}
{\xe \v syscall4\:syscalls.c}
{\xe \v syscalls.c\:syscall4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define syscall4( n,  h)}}
\par
{\bkmkstart AAAAAAABKL}
{\bkmkend AAAAAAABKL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid h(p1, p2, p3, p4) \{                 \\\par
        int r, e;                           \\\par
        __asm__ __volatile__ (          \\\par
            SYSCODE                     \\\par
            : "=a"(r), "=b"(e)  \\\par
            : "a"(n), "b"(p1), "c"(p2), \\\par
              "d"(p3), "S"(p4)          \\\par
        );                              \\\par
        errno = e;                      \\\par
        return r;                       \\\par
    \}\par
}
{
Definition at line 54 of file syscalls.c.}\par
}
{\xe \v syscall5\:syscalls.c}
{\xe \v syscalls.c\:syscall5}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define syscall5( n,  h)}}
\par
{\bkmkstart AAAAAAABKM}
{\bkmkend AAAAAAABKM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid h(p1, p2, p3, p4, p5) \{             \\\par
        int r, e;                           \\\par
        __asm__ __volatile__ (          \\\par
            SYSCODE                     \\\par
            : "=a"(r), "=b"(e)  \\\par
            : "a"(n), "b"(p1), "c"(p2), \\\par
              "d"(p3), "S"(p4), "D"(p5) \\\par
        );                              \\\par
        errno = e;                      \\\par
        return r;                       \\\par
    \}\par
}
{
Definition at line 67 of file syscalls.c.}\par
}
{\xe \v SYSCODE\:syscalls.c}
{\xe \v syscalls.c\:SYSCODE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SYSCODE\~ "int $0x80"}}
\par
{\bkmkstart AAAAAAABKN}
{\bkmkend AAAAAAABKN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3 of file syscalls.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
usr/src/libposix/include/sys/dirent.h File Reference\par \pard\plain 
{\tc\tcl2 \v usr/src/libposix/include/sys/dirent.h}
{\xe \v usr/src/libposix/include/sys/dirent.h}
{\bkmkstart AAAAAAABKO}
{\bkmkend AAAAAAABKO}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <unistd.h>}\par
{\f2 #include <sys/types.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b __DIR}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b dirent}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b O_DIRECTORY}\~ 00200000\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b O_NOFOLLOW}\~ 00400000\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b __DIR} {\b DIR}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b alphasort} (const struct {\b dirent} **a, const struct {\b dirent} **b)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b closedir} ({\b DIR} *{\b d})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DIR} * {\b opendir} (const char *path)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b dirent} * {\b readdir} ({\b DIR} *{\b d})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b rewinddir} ({\b DIR} *{\b d})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b scandir} (const char *pathname, struct {\b dirent} ***namelist, int(*select)(const struct {\b dirent} *), int(*compar)(const struct {\b dirent} **, const struct {\b dirent} **))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b seekdir} ({\b DIR} *{\b d}, off_t {\b offset})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
off_t {\b telldir} ({\b DIR} *{\b d})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v O_DIRECTORY\:dirent.h}
{\xe \v dirent.h\:O_DIRECTORY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define O_DIRECTORY\~ 00200000}}
\par
{\bkmkstart AAAAAAABKP}
{\bkmkend AAAAAAABKP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 42 of file dirent.h.}\par
}
{\xe \v O_NOFOLLOW\:dirent.h}
{\xe \v dirent.h\:O_NOFOLLOW}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define O_NOFOLLOW\~ 00400000}}
\par
{\bkmkstart AAAAAAABKQ}
{\bkmkend AAAAAAABKQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 46 of file dirent.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v DIR\:dirent.h}
{\xe \v dirent.h\:DIR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b __DIR}  {\b DIR}}}
\par
{\bkmkstart AAAAAAABKR}
{\bkmkend AAAAAAABKR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v alphasort\:dirent.h}
{\xe \v dirent.h\:alphasort}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int alphasort (const struct {\b dirent} ** {\i a}, const struct {\b dirent} ** {\i b})}}
\par
{\bkmkstart AAAAAAABKS}
{\bkmkend AAAAAAABKS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 12 of file alphasort.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12                                                                 \{\par
13     return strcoll((*a)->d_name, (*b)->d_name);\par
14 \}\par
}
}
{\xe \v closedir\:dirent.h}
{\xe \v dirent.h\:closedir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int closedir ({\b DIR} * {\i d})}}
\par
{\bkmkstart AAAAAAABKT}
{\bkmkend AAAAAAABKT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 11 of file closedir.c.}\par
{
References errno, __DIR::fd, and __DIR::position.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11                      \{\par
12     if(d == NULL) \{\par
13         errno = EINVAL;\par
14         return -1;\par
15     \}\par
16 \par
17     close(d->fd);\par
18 \par
19     d->fd = -1;\par
20     d->position = -1;\par
21 \par
22     return 0;\par
23 \}\par
}
}
{\xe \v opendir\:dirent.h}
{\xe \v dirent.h\:opendir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DIR}* opendir (const char * {\i path})}}
\par
{\bkmkstart AAAAAAABKU}
{\bkmkend AAAAAAABKU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 13 of file opendir.c.}\par
{
References d, errno, __DIR::fd, O_DIRECTORY, and __DIR::position.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13                                \{\par
14     int fd = open(path, O_RDONLY | O_DIRECTORY, 0644);\par
15     if(fd < 0) \{\par
16         errno = ENOENT;\par
17         return NULL;\par
18     \}\par
19 \par
20     DIR* d = (DIR*) malloc(sizeof(DIR));\par
21     d->fd = fd;\par
22     d->position = 0;\par
23 \par
24     return d;\par
25 \}\par
}
}
{\xe \v readdir\:dirent.h}
{\xe \v dirent.h\:readdir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b dirent}* readdir ({\b DIR} * {\i d})}}
\par
{\bkmkstart AAAAAAABKV}
{\bkmkend AAAAAAABKV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 15 of file readdir.c.}\par
{
References errno.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15                                \{\par
16     if(d == NULL) \{\par
17         errno = EINVAL;\par
18         return NULL;\par
19     \}\par
20 \par
21     return __os_readdir(d);\par
22 \}\par
}
}
{\xe \v rewinddir\:dirent.h}
{\xe \v dirent.h\:rewinddir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void rewinddir ({\b DIR} * {\i d})}}
\par
{\bkmkstart AAAAAAABKW}
{\bkmkend AAAAAAABKW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 11 of file rewinddir.c.}\par
{
References __DIR::position.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11                        \{\par
12     if(d)\par
13         d->position = 0;\par
14 \}\par
}
}
{\xe \v scandir\:dirent.h}
{\xe \v dirent.h\:scandir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int scandir (const char * {\i pathname}, struct {\b dirent} *** {\i namelist}, int(*)(const struct {\b dirent} *) {\i select}, int(*)(const struct {\b dirent} **, const struct {\b dirent} **) {\i compar})}}
\par
{\bkmkstart AAAAAAABKX}
{\bkmkend AAAAAAABKX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 11 of file scandir.c.}\par
{
References d, errno, opendir(), and readdir().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11                                                                                                                                                                   \{\par
12     DIR* d = opendir(pathname);\par
13     if(d == NULL) \{\par
14         errno = ENOENT;\par
15         return -1;\par
16     \}\par
17 \par
18     if(namelist == NULL) \{\par
19         errno = EINVAL;\par
20         return -1;\par
21     \}\par
22 \par
23     const struct dirent* ent = NULL;\par
24     const struct dirent** lst = (const struct dirent**) *namelist;\par
25 \par
26     int index = 0;\par
27 \par
28 \par
29     while((ent = readdir(d))) \{\par
30         if(select)\par
31             if(select(ent) != 0)\par
32                 continue;\par
33 \par
34         \par
35         if((index > 0) && (compar) && (compar(&lst[index - 1], &ent) > 0)) \{\par
36             lst[index] = lst[index - 1];\par
37             lst[index - 1] = ent;\par
38         \} else\par
39             lst[index] = ent;\par
40 \par
41         index += 1;\par
42     \}\par
43 \par
44     return index;\par
45 \}\par
}
}
{\xe \v seekdir\:dirent.h}
{\xe \v dirent.h\:seekdir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void seekdir ({\b DIR} * {\i d}, off_t {\i offset})}}
\par
{\bkmkstart AAAAAAABKY}
{\bkmkend AAAAAAABKY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 13 of file seekdir.c.}\par
{
References offset, and __DIR::position.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13                                    \{\par
14     if(d)\par
15         d->position = offset;\par
16 \}\par
}
}
{\xe \v telldir\:dirent.h}
{\xe \v dirent.h\:telldir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
off_t telldir ({\b DIR} * {\i d})}}
\par
{\bkmkstart AAAAAAABKZ}
{\bkmkend AAAAAAABKZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 11 of file telldir.c.}\par
{
References errno, and __DIR::position.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11                       \{\par
12     if(d == NULL) \{\par
13         errno = EINVAL;\par
14         return -1;\par
15     \}\par
16 \par
17     return d->position;\par
18 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
usr/src/libposix/src/_execve.c File Reference\par \pard\plain 
{\tc\tcl2 \v usr/src/libposix/src/_execve.c}
{\xe \v usr/src/libposix/src/_execve.c}
{\bkmkstart AAAAAAABLA}
{\bkmkend AAAAAAABLA}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <unistd.h>}\par
{\f2 #include <sys/types.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b execve} (const char *filename, char *const args[], char *const env[])\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b _execve} (const char *filename, char *const args[], char *const env[])\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v _execve\:_execve.c}
{\xe \v _execve.c\:_execve}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int _execve (const char * {\i filename}, char *const {\i args}[], char *const {\i env}[])}}
\par
{\bkmkstart AAAAAAABLB}
{\bkmkend AAAAAAABLB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 8 of file _execve.c.}\par
{
References execve().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 8                                                                          \{\par
9     return execve(filename, args, env);\par
10 \}\par
}
}
{\xe \v execve\:_execve.c}
{\xe \v _execve.c\:execve}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int execve (const char * {\i filename}, char *const {\i args}[], char *const {\i env}[])}}
\par
{\bkmkstart AAAAAAABLC}
{\bkmkend AAAAAAABLC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
usr/src/libposix/src/alarm.c File Reference\par \pard\plain 
{\tc\tcl2 \v usr/src/libposix/src/alarm.c}
{\xe \v usr/src/libposix/src/alarm.c}
{\bkmkstart AAAAAAABLD}
{\bkmkend AAAAAAABLD}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <unistd.h>}\par
{\f2 #include <signal.h>}\par
{\f2 #include <errno.h>}\par
{\f2 #include "config.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned {\b alarm} (unsigned seconds)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v alarm\:alarm.c}
{\xe \v alarm.c\:alarm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned alarm (unsigned {\i seconds})}}
\par
{\bkmkstart AAAAAAABLE}
{\bkmkend AAAAAAABLE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 20 of file alarm.c.}\par
{
References errno, pthread_create(), and pthread_detach().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20                                  \{\par
21 #ifdef USE_PTHREAD\par
22     static pthread_t thr = -1;\par
23 \par
24     if(thr != -1)\par
25         if(pthread_detach(thr) != 0)\par
26             return -1;\par
27 \par
28     if(seconds > 0)\par
29         if(pthread_create(&thr, NULL, alarm_thread, seconds) != 0)\par
30             return -1;\par
31     return 0;\par
32 \par
33 #else\par
34     errno = ENOSYS;\par
35     return -1;\par
36 #endif\par
37 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
usr/src/libposix/src/alphasort.c File Reference\par \pard\plain 
{\tc\tcl2 \v usr/src/libposix/src/alphasort.c}
{\xe \v usr/src/libposix/src/alphasort.c}
{\bkmkstart AAAAAAABLF}
{\bkmkend AAAAAAABLF}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <dirent.h>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <fcntl.h>}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <errno.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b alphasort} (const struct {\b dirent} **a, const struct {\b dirent} **b)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v alphasort\:alphasort.c}
{\xe \v alphasort.c\:alphasort}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int alphasort (const struct {\b dirent} ** {\i a}, const struct {\b dirent} ** {\i b})}}
\par
{\bkmkstart AAAAAAABLG}
{\bkmkend AAAAAAABLG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 12 of file alphasort.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12                                                                 \{\par
13     return strcoll((*a)->d_name, (*b)->d_name);\par
14 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
usr/src/libposix/src/closedir.c File Reference\par \pard\plain 
{\tc\tcl2 \v usr/src/libposix/src/closedir.c}
{\xe \v usr/src/libposix/src/closedir.c}
{\bkmkstart AAAAAAABLH}
{\bkmkend AAAAAAABLH}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <dirent.h>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <fcntl.h>}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <errno.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b closedir} ({\b DIR} *{\b d})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v closedir\:closedir.c}
{\xe \v closedir.c\:closedir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int closedir ({\b DIR} * {\i d})}}
\par
{\bkmkstart AAAAAAABLI}
{\bkmkend AAAAAAABLI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 11 of file closedir.c.}\par
{
References errno, __DIR::fd, and __DIR::position.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11                      \{\par
12     if(d == NULL) \{\par
13         errno = EINVAL;\par
14         return -1;\par
15     \}\par
16 \par
17     close(d->fd);\par
18 \par
19     d->fd = -1;\par
20     d->position = -1;\par
21 \par
22     return 0;\par
23 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
usr/src/libposix/src/config.h File Reference\par \pard\plain 
{\tc\tcl2 \v usr/src/libposix/src/config.h}
{\xe \v usr/src/libposix/src/config.h}
{\bkmkstart AAAAAAABLJ}
{\bkmkend AAAAAAABLJ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <sys/types.h>}\par
{\f2 #include <unistd.h>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
usr/src/libposix/src/dup2.c File Reference\par \pard\plain 
{\tc\tcl2 \v usr/src/libposix/src/dup2.c}
{\xe \v usr/src/libposix/src/dup2.c}
{\bkmkstart AAAAAAABLK}
{\bkmkend AAAAAAABLK}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <fcntl.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b dup2} (int oldfd, int newfd)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v dup2\:dup2.c}
{\xe \v dup2.c\:dup2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int dup2 (int {\i oldfd}, int {\i newfd})}}
\par
{\bkmkstart AAAAAAABLL}
{\bkmkend AAAAAAABLL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3 of file dup2.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3                                \{\par
4     return fcntl(oldfd, F_DUPFD, newfd);\par
5 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
usr/src/libposix/src/environ.c File Reference\par \pard\plain 
{\tc\tcl2 \v usr/src/libposix/src/environ.c}
{\xe \v usr/src/libposix/src/environ.c}
{\bkmkstart AAAAAAABLM}
{\bkmkend AAAAAAABLM}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static char * {\b p_environ} [] = \{ 0 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char ** {\b environ} = {\b p_environ}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v environ\:environ.c}
{\xe \v environ.c\:environ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char** environ = {\b p_environ}}}
\par
{\bkmkstart AAAAAAABLN}
{\bkmkend AAAAAAABLN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3 of file environ.c.}\par
}
{\xe \v p_environ\:environ.c}
{\xe \v environ.c\:p_environ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* p_environ[] = \{ 0 \}{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABLO}
{\bkmkend AAAAAAABLO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 2 of file environ.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
usr/src/libposix/src/errno.c File Reference\par \pard\plain 
{\tc\tcl2 \v usr/src/libposix/src/errno.c}
{\xe \v usr/src/libposix/src/errno.c}
{\bkmkstart AAAAAAABLP}
{\bkmkend AAAAAAABLP}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <errno.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b errno} = 0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v errno\:errno.c}
{\xe \v errno.c\:errno}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int errno = 0}}
\par
{\bkmkstart AAAAAAABLQ}
{\bkmkend AAAAAAABLQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3 of file errno.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
usr/src/libposix/src/execl.c File Reference\par \pard\plain 
{\tc\tcl2 \v usr/src/libposix/src/execl.c}
{\xe \v usr/src/libposix/src/execl.c}
{\bkmkstart AAAAAAABLR}
{\bkmkend AAAAAAABLR}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <_ansi.h>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <varargs.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b _execve} (const char *filename, char *const args[], char *const env[])\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b _DEFUN} (execl,(path, arg0, va_alist), _CONST char *path _AND _CONST char *arg0 _AND va_dcl)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static char *** {\b p_environ} = &{\b environ}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v _DEFUN\:execl.c}
{\xe \v execl.c\:_DEFUN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int _DEFUN (execl , (path, arg0, va_alist) , _CONST char *path _AND _CONST char *arg0 _AND {\i va_dcl})}}
\par
{\bkmkstart AAAAAAABLS}
{\bkmkend AAAAAAABLS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 29 of file execl.c.}\par
{
References _execve(), and p_environ.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 36 \{\par
37   int i;\par
38   va_list args;\par
39   _CONST char *argv[256];\par
40 \par
41   va_start (args, arg0);\par
42   argv[0] = arg0;\par
43   i = 1;\par
44   do\par
45       argv[i] = va_arg (args, _CONST char *);\par
46   while (argv[i++] != NULL);\par
47   va_end (args);\par
48 \par
49   return _execve (path, (char * _CONST  *) argv, *p_environ);\par
50 \}\par
}
}
{\xe \v _execve\:execl.c}
{\xe \v execl.c\:_execve}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int _execve (const char * {\i filename}, char *const {\i args}[], char *const {\i env}[])}}
\par
{\bkmkstart AAAAAAABLT}
{\bkmkend AAAAAAABLT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 8 of file _execve.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 8                                                                          \{\par
9     return execve(filename, args, env);\par
10 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v p_environ\:execl.c}
{\xe \v execl.c\:p_environ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char*** p_environ = &{\b environ}{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABLU}
{\bkmkend AAAAAAABLU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 12 of file execl.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
usr/src/libposix/src/execle.c File Reference\par \pard\plain 
{\tc\tcl2 \v usr/src/libposix/src/execle.c}
{\xe \v usr/src/libposix/src/execle.c}
{\bkmkstart AAAAAAABLV}
{\bkmkend AAAAAAABLV}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <_ansi.h>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <varargs.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b _execve} (const char *filename, char *const args[], char *const env[])\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b _DEFUN} (execle,(path, arg0, va_alist), _CONST char *path _AND _CONST char *arg0 _AND va_dcl)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v _DEFUN\:execle.c}
{\xe \v execle.c\:_DEFUN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int _DEFUN (execle , (path, arg0, va_alist) , _CONST char *path _AND _CONST char *arg0 _AND {\i va_dcl})}}
\par
{\bkmkstart AAAAAAABLW}
{\bkmkend AAAAAAABLW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 25 of file execle.c.}\par
{
References _execve().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 32 \{\par
33   int i;\par
34   va_list args;\par
35   _CONST char * _CONST *envp;\par
36   _CONST char *argv[256];\par
37 \par
38   va_start (args, arg0);\par
39   argv[0] = arg0;\par
40   i = 1;\par
41   do\par
42     argv[i] = va_arg (args, _CONST char *);\par
43   while (argv[i++] != NULL);\par
44   envp = va_arg (args, _CONST char * _CONST *);\par
45   va_end (args);\par
46 \par
47   return _execve (path, (char * _CONST *) argv, (char * _CONST *) envp);\par
48 \}\par
}
}
{\xe \v _execve\:execle.c}
{\xe \v execle.c\:_execve}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int _execve (const char * {\i filename}, char *const {\i args}[], char *const {\i env}[])}}
\par
{\bkmkstart AAAAAAABLX}
{\bkmkend AAAAAAABLX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 8 of file _execve.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 8                                                                          \{\par
9     return execve(filename, args, env);\par
10 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
usr/src/libposix/src/execlp.c File Reference\par \pard\plain 
{\tc\tcl2 \v usr/src/libposix/src/execlp.c}
{\xe \v usr/src/libposix/src/execlp.c}
{\bkmkstart AAAAAAABLY}
{\bkmkend AAAAAAABLY}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <_ansi.h>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <varargs.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b _execve} (const char *filename, char *const args[], char *const env[])\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b _DEFUN} (execlp,(path, arg0, va_alist), _CONST char *path _AND _CONST char *arg0 _AND va_dcl)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v _DEFUN\:execlp.c}
{\xe \v execlp.c\:_DEFUN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int _DEFUN (execlp , (path, arg0, va_alist) , _CONST char *path _AND _CONST char *arg0 _AND {\i va_dcl})}}
\par
{\bkmkstart AAAAAAABLZ}
{\bkmkend AAAAAAABLZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 25 of file execlp.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 32 \{\par
33   int i;\par
34   va_list args;\par
35   _CONST char *argv[256];\par
36 \par
37   va_start (args, arg0);\par
38   argv[0] = arg0;\par
39   i = 1;\par
40   do\par
41       argv[i] = va_arg (args, _CONST char *);\par
42   while (argv[i++] != NULL);\par
43   va_end (args);\par
44 \par
45   return execvp (path, (char * _CONST *) argv);\par
46 \}\par
}
}
{\xe \v _execve\:execlp.c}
{\xe \v execlp.c\:_execve}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int _execve (const char * {\i filename}, char *const {\i args}[], char *const {\i env}[])}}
\par
{\bkmkstart AAAAAAABMA}
{\bkmkend AAAAAAABMA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 8 of file _execve.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 8                                                                          \{\par
9     return execve(filename, args, env);\par
10 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
usr/src/libposix/src/execv.c File Reference\par \pard\plain 
{\tc\tcl2 \v usr/src/libposix/src/execv.c}
{\xe \v usr/src/libposix/src/execv.c}
{\bkmkstart AAAAAAABMB}
{\bkmkend AAAAAAABMB}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <_ansi.h>}\par
{\f2 #include <unistd.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b _execve} (const char *filename, char *const args[], char *const env[])\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b _DEFUN} (execv,(path, argv), const char *path _AND char *const argv[])\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static char *** {\b p_environ} = &{\b environ}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v _DEFUN\:execv.c}
{\xe \v execv.c\:_DEFUN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int _DEFUN (execv , (path, argv) , const char *path _AND char *const {\i argv}[])}}
\par
{\bkmkstart AAAAAAABMC}
{\bkmkend AAAAAAABMC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 17 of file execv.c.}\par
{
References _execve(), and p_environ.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20 \{\par
21   return _execve (path, (char * _CONST *) argv, *p_environ);\par
22 \}\par
}
}
{\xe \v _execve\:execv.c}
{\xe \v execv.c\:_execve}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int _execve (const char * {\i filename}, char *const {\i args}[], char *const {\i env}[])}}
\par
{\bkmkstart AAAAAAABMD}
{\bkmkend AAAAAAABMD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 8 of file _execve.c.}\par
{
References execve().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 8                                                                          \{\par
9     return execve(filename, args, env);\par
10 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v p_environ\:execv.c}
{\xe \v execv.c\:p_environ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char*** p_environ = &{\b environ}{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABME}
{\bkmkend AAAAAAABME}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 13 of file execv.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
usr/src/libposix/src/execvp.c File Reference\par \pard\plain 
{\tc\tcl2 \v usr/src/libposix/src/execvp.c}
{\xe \v usr/src/libposix/src/execvp.c}
{\bkmkstart AAAAAAABMF}
{\bkmkend AAAAAAABMF}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <_ansi.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <dirent.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <errno.h>}\par
{\f2 #include <ctype.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PATH_DELIM}\~ ':'\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static char * {\b _DEFUN} (strccpy,(s1, s2, c), char *s1 _AND char *s2 _AND char c)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b _DEFUN} (execvp,(file, argv), _CONST char *file _AND char *_CONST argv[])\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v PATH_DELIM\:execvp.c}
{\xe \v execvp.c\:PATH_DELIM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PATH_DELIM\~ ':'}}
\par
{\bkmkstart AAAAAAABMG}
{\bkmkend AAAAAAABMG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 16 of file execvp.c.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v _DEFUN\:execvp.c}
{\xe \v execvp.c\:_DEFUN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static char* _DEFUN (strccpy , (s1, s2, c) , char *s1 _AND char *s2 _AND char {\i c}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABMH}
{\bkmkend AAAAAAABMH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 24 of file execvp.c.}\par
{
References dest.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28 \{\par
29   char *dest = s1;\par
30 \par
31   while (*s2 && *s2 != c)\par
32     *s1++ = *s2++;\par
33   *s1 = 0;\par
34 \par
35   return dest;\par
36 \}\par
}
}
{\xe \v _DEFUN\:execvp.c}
{\xe \v execvp.c\:_DEFUN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int _DEFUN (execvp , (file, argv) , _CONST char *file _AND char *_CONST {\i argv}[])}}
\par
{\bkmkstart AAAAAAABMI}
{\bkmkend AAAAAAABMI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 39 of file execvp.c.}\par
{
References PATH_DELIM.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 42 \{\par
43   char *path = getenv ("PATH");\par
44   char buf[MAXNAMLEN];\par
45 \par
46   /* If $PATH doesn't exist, just pass FILE on unchanged.  */\par
47   if (!path)\par
48     return execv (file, argv);\par
49 \par
50   /* If FILE contains a directory, don't search $PATH.  */\par
51   if (strchr (file, '/')\par
52       )\par
53     return execv (file, argv);\par
54 \par
55   while (*path)\par
56     \{\par
57       strccpy (buf, path, PATH_DELIM);\par
58       /* An empty entry means the current directory.  */\par
59       if (*buf != 0 && buf[strlen(buf) - 1] != '/')\par
60     strcat (buf, "/");\par
61       strcat (buf, file);\par
62       if(execv (buf, argv) == 0)\par
63         return 0;       \par
64 \par
65       while (*path && *path != PATH_DELIM)\par
66     path++;\par
67       if (*path == PATH_DELIM)\par
68     path++;         /* skip over delim */\par
69     \}\par
70 \par
71   return -1;\par
72 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
usr/src/libposix/src/getcwd.c File Reference\par \pard\plain 
{\tc\tcl2 \v usr/src/libposix/src/getcwd.c}
{\xe \v usr/src/libposix/src/getcwd.c}
{\bkmkstart AAAAAAABMJ}
{\bkmkend AAAAAAABMJ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <unistd.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <dirent.h>}\par
{\f2 #include <sys/stat.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static char * {\b strcat_inv} (char *{\b dest}, char *str)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b getcwd} (char *buf, size_t {\b size})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v getcwd\:getcwd.c}
{\xe \v getcwd.c\:getcwd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* getcwd (char * {\i buf}, size_t {\i size})}}
\par
{\bkmkstart AAAAAAABMK}
{\bkmkend AAAAAAABMK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 17 of file getcwd.c.}\par
{
References closedir(), dirent::d_ino, dirent::d_name, opendir(), readdir(), and strcat_inv().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17                                      \{\par
18     struct stat st;\par
19     char tmpbuf[1024];\par
20 \par
21     int root_ino = 0;\par
22     int curr_ino = 0;\par
23 \par
24     if(stat("/", &st) != 0)\par
25         return NULL;\par
26     root_ino = st.st_ino;\par
27 \par
28     if(stat(".", &st) != 0)\par
29         return NULL;\par
30     curr_ino = st.st_ino;\par
31 \par
32 \par
33     memset(buf, 0, size);\par
34     memset(tmpbuf, 0, 1024);\par
35     strcat(tmpbuf, ".");\par
36 \par
37     if(curr_ino == root_ino) \{\par
38         strcat_inv(buf, "/");\par
39         return buf;\par
40     \}\par
41 \par
42 \par
43     while(curr_ino != root_ino) \{\par
44         if(stat(tmpbuf, &st) != 0)\par
45             return NULL;\par
46 \par
47         curr_ino = st.st_ino;\par
48 \par
49         if(curr_ino == root_ino)\par
50             break;\par
51 \par
52         strcat(tmpbuf, "/..");\par
53         DIR* dir = opendir(tmpbuf);\par
54         if(!dir)\par
55             return NULL;\par
56 \par
57         struct dirent* ent;\par
58         while((ent = readdir(dir))) \{\par
59             if(ent->d_ino == curr_ino) \{\par
60                 strcat_inv(buf, ent->d_name);\par
61                 strcat_inv(buf, "/");           \par
62             \}\par
63 \par
64             free(ent);\par
65         \}\par
66 \par
67         closedir(dir);\par
68     \}\par
69 \par
70     return buf;\par
71 \}\par
}
}
{\xe \v strcat_inv\:getcwd.c}
{\xe \v getcwd.c\:strcat_inv}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static char* strcat_inv (char * {\i dest}, char * {\i str}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABML}
{\bkmkend AAAAAAABML}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 7 of file getcwd.c.}\par
{
References dest.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7                                                \{\par
8     char* res = malloc(strlen(dest) + strlen(str));\par
9     strcpy(res, str);   \par
10     strcat(res, dest);\par
11     strcpy(dest, res);\par
12 \par
13     free(res);\par
14     return dest;\par
15 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
usr/src/libposix/src/gid.c File Reference\par \pard\plain 
{\tc\tcl2 \v usr/src/libposix/src/gid.c}
{\xe \v usr/src/libposix/src/gid.c}
{\bkmkstart AAAAAAABMM}
{\bkmkend AAAAAAABMM}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <unistd.h>}\par
{\f2 #include <sys/stat.h>}\par
{\f2 #include "config.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gid_t {\b getgid} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gid_t {\b getegid} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b getgroups} (int len, gid_t *{\b list})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v getegid\:gid.c}
{\xe \v gid.c\:getegid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
gid_t getegid (void )}}
\par
{\bkmkstart AAAAAAABMN}
{\bkmkend AAAAAAABMN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 14 of file gid.c.}\par
{
References getgid().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14                     \{\par
15     return getgid();\par
16 \}\par
}
}
{\xe \v getgid\:gid.c}
{\xe \v gid.c\:getgid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
gid_t getgid (void )}}
\par
{\bkmkstart AAAAAAABMO}
{\bkmkend AAAAAAABMO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 6 of file gid.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6                    \{\par
7     struct stat st;\par
8     if(fstat(STDIN_FILENO, &st) != 0)\par
9         return -1;\par
10 \par
11     return st.st_gid;\par
12 \}\par
}
}
{\xe \v getgroups\:gid.c}
{\xe \v gid.c\:getgroups}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int getgroups (int {\i len}, gid_t * {\i list})}}
\par
{\bkmkstart AAAAAAABMP}
{\bkmkend AAAAAAABMP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 18 of file gid.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18                                     \{\par
19     return __os_getgroups(len, list);\par
20 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
usr/src/libposix/src/lstat.c File Reference\par \pard\plain 
{\tc\tcl2 \v usr/src/libposix/src/lstat.c}
{\xe \v usr/src/libposix/src/lstat.c}
{\bkmkstart AAAAAAABMQ}
{\bkmkend AAAAAAABMQ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <fcntl.h>}\par
{\f2 #include <dirent.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b lstat} (const char *filename, struct stat *st)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v lstat\:lstat.c}
{\xe \v lstat.c\:lstat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int lstat (const char * {\i filename}, struct stat * {\i st})}}
\par
{\bkmkstart AAAAAAABMR}
{\bkmkend AAAAAAABMR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 5 of file lstat.c.}\par
{
References O_NOFOLLOW.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5                                                  \{\par
6     int fd = open(filename, O_RDONLY | O_NOFOLLOW, 0644);\par
7     if(fd < 0)\par
8         return -1;\par
9 \par
10     int ret = fstat(fd, st);\par
11     close(fd);\par
12     return ret;\par
13 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
usr/src/libposix/src/nanosleep.c File Reference\par \pard\plain 
{\tc\tcl2 \v usr/src/libposix/src/nanosleep.c}
{\xe \v usr/src/libposix/src/nanosleep.c}
{\bkmkstart AAAAAAABMS}
{\bkmkend AAAAAAABMS}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <sys/times.h>}\par
{\f2 #include <sys/time.h>}\par
{\f2 #include <errno.h>}\par
{\f2 #include <sched.h>}\par
{\f2 #include <stdlib.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sched_yield} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b nanosleep} (const struct timespec *req, struct timespec *rem)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v nanosleep\:nanosleep.c}
{\xe \v nanosleep.c\:nanosleep}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int nanosleep (const struct timespec * {\i req}, struct timespec * {\i rem})}}
\par
{\bkmkstart AAAAAAABMT}
{\bkmkend AAAAAAABMT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 10 of file nanosleep.c.}\par
{
References errno, and sched_yield().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10                                                                 \{\par
11     if(req->tv_sec > 999999999) \{\par
12         errno = EINVAL;\par
13         return -1;\par
14     \}\par
15 \par
16     struct timeval* tm = malloc(sizeof(struct timeval));\par
17     struct timezone* tz = malloc(sizeof(struct timezone));\par
18 \par
19     if(!tm && !tz) \{\par
20         errno = ENOMEM;\par
21         return -1;\par
22     \}\par
23 \par
24     if(gettimeofday(tm, tz) != 0)\par
25             return -1;\par
26 \par
27     int t0 = req->tv_sec + tm->tv_sec;\par
28     int t1 = req->tv_nsec + tm->tv_usec;\par
29 \par
30 \par
31     while(1) \{\par
32         if(gettimeofday(tm, tz) != 0)\par
33             return -1;\par
34 \par
35         if(tm->tv_sec > t0 && tm->tv_usec > t1)\par
36             break;\par
37 \par
38         if(rem) \{\par
39             rem->tv_sec = t0 - tm->tv_sec;\par
40             rem->tv_nsec = t1 - tm->tv_usec;\par
41         \}\par
42 \par
43         sched_yield();\par
44     \}\par
45 \par
46 \par
47     free(tm);\par
48     free(tz);\par
49 \par
50     return 0;\par
51 \}\par
}
}
{\xe \v sched_yield\:nanosleep.c}
{\xe \v nanosleep.c\:sched_yield}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int sched_yield (void )}}
\par
{\bkmkstart AAAAAAABMU}
{\bkmkend AAAAAAABMU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
usr/src/libposix/src/opendir.c File Reference\par \pard\plain 
{\tc\tcl2 \v usr/src/libposix/src/opendir.c}
{\xe \v usr/src/libposix/src/opendir.c}
{\bkmkstart AAAAAAABMV}
{\bkmkend AAAAAAABMV}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <dirent.h>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <fcntl.h>}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <errno.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DIR} * {\b opendir} (const char *path)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v opendir\:opendir.c}
{\xe \v opendir.c\:opendir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DIR}* opendir (const char * {\i path})}}
\par
{\bkmkstart AAAAAAABMW}
{\bkmkend AAAAAAABMW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 13 of file opendir.c.}\par
{
References d, errno, __DIR::fd, O_DIRECTORY, and __DIR::position.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13                                \{\par
14     int fd = open(path, O_RDONLY | O_DIRECTORY, 0644);\par
15     if(fd < 0) \{\par
16         errno = ENOENT;\par
17         return NULL;\par
18     \}\par
19 \par
20     DIR* d = (DIR*) malloc(sizeof(DIR));\par
21     d->fd = fd;\par
22     d->position = 0;\par
23 \par
24     return d;\par
25 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
usr/src/libposix/src/rewinddir.c File Reference\par \pard\plain 
{\tc\tcl2 \v usr/src/libposix/src/rewinddir.c}
{\xe \v usr/src/libposix/src/rewinddir.c}
{\bkmkstart AAAAAAABMX}
{\bkmkend AAAAAAABMX}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <dirent.h>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <fcntl.h>}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <errno.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b rewinddir} ({\b DIR} *{\b d})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v rewinddir\:rewinddir.c}
{\xe \v rewinddir.c\:rewinddir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void rewinddir ({\b DIR} * {\i d})}}
\par
{\bkmkstart AAAAAAABMY}
{\bkmkend AAAAAAABMY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 11 of file rewinddir.c.}\par
{
References __DIR::position.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11                        \{\par
12     if(d)\par
13         d->position = 0;\par
14 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
usr/src/libposix/src/scandir.c File Reference\par \pard\plain 
{\tc\tcl2 \v usr/src/libposix/src/scandir.c}
{\xe \v usr/src/libposix/src/scandir.c}
{\bkmkstart AAAAAAABMZ}
{\bkmkend AAAAAAABMZ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <dirent.h>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <fcntl.h>}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <errno.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b scandir} (const char *pathname, struct {\b dirent} ***namelist, int(*select)(const struct {\b dirent} *), int(*compar)(const struct {\b dirent} **, const struct {\b dirent} **))\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v scandir\:scandir.c}
{\xe \v scandir.c\:scandir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int scandir (const char * {\i pathname}, struct {\b dirent} *** {\i namelist}, int(*)(const struct {\b dirent} *) {\i select}, int(*)(const struct {\b dirent} **, const struct {\b dirent} **) {\i compar})}}
\par
{\bkmkstart AAAAAAABNA}
{\bkmkend AAAAAAABNA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 11 of file scandir.c.}\par
{
References d, errno, opendir(), and readdir().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11                                                                                                                                                                   \{\par
12     DIR* d = opendir(pathname);\par
13     if(d == NULL) \{\par
14         errno = ENOENT;\par
15         return -1;\par
16     \}\par
17 \par
18     if(namelist == NULL) \{\par
19         errno = EINVAL;\par
20         return -1;\par
21     \}\par
22 \par
23     const struct dirent* ent = NULL;\par
24     const struct dirent** lst = (const struct dirent**) *namelist;\par
25 \par
26     int index = 0;\par
27 \par
28 \par
29     while((ent = readdir(d))) \{\par
30         if(select)\par
31             if(select(ent) != 0)\par
32                 continue;\par
33 \par
34         \par
35         if((index > 0) && (compar) && (compar(&lst[index - 1], &ent) > 0)) \{\par
36             lst[index] = lst[index - 1];\par
37             lst[index - 1] = ent;\par
38         \} else\par
39             lst[index] = ent;\par
40 \par
41         index += 1;\par
42     \}\par
43 \par
44     return index;\par
45 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
usr/src/libposix/src/seekdir.c File Reference\par \pard\plain 
{\tc\tcl2 \v usr/src/libposix/src/seekdir.c}
{\xe \v usr/src/libposix/src/seekdir.c}
{\bkmkstart AAAAAAABNB}
{\bkmkend AAAAAAABNB}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <dirent.h>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <fcntl.h>}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <errno.h>}\par
{\f2 #include <sys/types.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b seekdir} ({\b DIR} *{\b d}, off_t {\b offset})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v seekdir\:seekdir.c}
{\xe \v seekdir.c\:seekdir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void seekdir ({\b DIR} * {\i d}, off_t {\i offset})}}
\par
{\bkmkstart AAAAAAABNC}
{\bkmkend AAAAAAABNC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 13 of file seekdir.c.}\par
{
References offset, and __DIR::position.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13                                    \{\par
14     if(d)\par
15         d->position = offset;\par
16 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
usr/src/libposix/src/sleep.c File Reference\par \pard\plain 
{\tc\tcl2 \v usr/src/libposix/src/sleep.c}
{\xe \v usr/src/libposix/src/sleep.c}
{\bkmkstart AAAAAAABND}
{\bkmkend AAAAAAABND}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <errno.h>}\par
{\f2 #include <time.h>}\par
{\f2 #include <unistd.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b nanosleep} (struct timespec *ts, struct timespec *tr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned {\b sleep} (unsigned seconds)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v nanosleep\:sleep.c}
{\xe \v sleep.c\:nanosleep}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int nanosleep (struct timespec * {\i ts}, struct timespec * {\i tr})}}
\par
{\bkmkstart AAAAAAABNE}
{\bkmkend AAAAAAABNE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v sleep\:sleep.c}
{\xe \v sleep.c\:sleep}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned sleep (unsigned {\i seconds})}}
\par
{\bkmkstart AAAAAAABNF}
{\bkmkend AAAAAAABNF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 8 of file sleep.c.}\par
{
References errno, and nanosleep().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 8                                  \{\par
9     struct timespec ts;\par
10 \par
11     ts.tv_sec = seconds;\par
12     ts.tv_nsec = 0;\par
13     if (!nanosleep(&ts,&ts)) return 0;\par
14     if (errno == EINTR) return ts.tv_sec;\par
15     return -1;\par
16 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
usr/src/libposix/src/telldir.c File Reference\par \pard\plain 
{\tc\tcl2 \v usr/src/libposix/src/telldir.c}
{\xe \v usr/src/libposix/src/telldir.c}
{\bkmkstart AAAAAAABNG}
{\bkmkend AAAAAAABNG}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <dirent.h>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <fcntl.h>}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <errno.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
off_t {\b telldir} ({\b DIR} *{\b d})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v telldir\:telldir.c}
{\xe \v telldir.c\:telldir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
off_t telldir ({\b DIR} * {\i d})}}
\par
{\bkmkstart AAAAAAABNH}
{\bkmkend AAAAAAABNH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 11 of file telldir.c.}\par
{
References errno, and __DIR::position.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11                       \{\par
12     if(d == NULL) \{\par
13         errno = EINVAL;\par
14         return -1;\par
15     \}\par
16 \par
17     return d->position;\par
18 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
usr/src/libposix/src/uid.c File Reference\par \pard\plain 
{\tc\tcl2 \v usr/src/libposix/src/uid.c}
{\xe \v usr/src/libposix/src/uid.c}
{\bkmkstart AAAAAAABNI}
{\bkmkend AAAAAAABNI}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <unistd.h>}\par
{\f2 #include <sys/stat.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uid_t {\b getuid} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uid_t {\b geteuid} (void)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v geteuid\:uid.c}
{\xe \v uid.c\:geteuid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uid_t geteuid (void )}}
\par
{\bkmkstart AAAAAAABNJ}
{\bkmkend AAAAAAABNJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 13 of file uid.c.}\par
{
References getuid().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13                     \{\par
14     return getuid();\par
15 \}\par
}
}
{\xe \v getuid\:uid.c}
{\xe \v uid.c\:getuid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uid_t getuid (void )}}
\par
{\bkmkstart AAAAAAABNK}
{\bkmkend AAAAAAABNK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 5 of file uid.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5                    \{\par
6     struct stat st;\par
7     if(fstat(STDIN_FILENO, &st) != 0)\par
8         return -1;\par
9 \par
10     return st.st_uid;\par
11 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
usr/src/libposix/src/usleep.c File Reference\par \pard\plain 
{\tc\tcl2 \v usr/src/libposix/src/usleep.c}
{\xe \v usr/src/libposix/src/usleep.c}
{\bkmkstart AAAAAAABNL}
{\bkmkend AAAAAAABNL}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <errno.h>}\par
{\f2 #include <time.h>}\par
{\f2 #include <unistd.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b nanosleep} (struct timespec *ts, struct timespec *tr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b usleep} (useconds_t useconds)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v nanosleep\:usleep.c}
{\xe \v usleep.c\:nanosleep}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int nanosleep (struct timespec * {\i ts}, struct timespec * {\i tr})}}
\par
{\bkmkstart AAAAAAABNM}
{\bkmkend AAAAAAABNM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v usleep\:usleep.c}
{\xe \v usleep.c\:usleep}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int usleep (useconds_t {\i useconds})}}
\par
{\bkmkstart AAAAAAABNN}
{\bkmkend AAAAAAABNN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 7 of file usleep.c.}\par
{
References errno, and nanosleep().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7                                 \{\par
8     struct timespec ts;\par
9 \par
10     ts.tv_sec = (long int)useconds / 1000000;\par
11     ts.tv_nsec = ((long int)useconds % 1000000);\par
12     if (!nanosleep(&ts,&ts)) return 0;\par
13     if (errno == EINTR) return ts.tv_sec;\par
14     return -1;\par
15 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
usr/src/libpthread/include/pthread.h File Reference\par \pard\plain 
{\tc\tcl2 \v usr/src/libpthread/include/pthread.h}
{\xe \v usr/src/libpthread/include/pthread.h}
{\bkmkstart AAAAAAABNO}
{\bkmkend AAAAAAABNO}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
{\f2 #include <sys/types.h>}\par
{\f2 #include <sys/time.h>}\par
{\f2 #include <sched.h>}\par
{\f2 #include <unistd.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b pthread_attr}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b pthread_once}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b pthread_mutexattr}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b pthread_mutex}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b pthread_condattr}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b pthread_cond}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b pthread_barrierattr}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b pthread_barrier}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b pthread_rwlockattr}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b pthread_rwlock}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b pthread_spinlock}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _POSIX_THREADS}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PTHREAD_CREATE_JOINABLE}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PTHREAD_CREATE_DETACHED}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PTHREAD_INHERIT_SCHED}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PTHREAD_EXPLICIT_SCHED}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PTHREAD_SCOPE_PROCESS}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PTHREAD_SCOPE_SYSTEM}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PTHREAD_CANCEL_ENABLE}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PTHREAD_CANCEL_DISABLE}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PTHREAD_PROCESS_PRIVATE}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PTHREAD_PROCESS_SHARED}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PTHREAD_ONCE_INIT}\~ \{ 0, -1 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PTHREAD_MUTEX_NORMAL}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PTHREAD_MUTEX_RECURSIVE}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PTHREAD_MUTEX_ERRORCHECK}\~ 2\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PTHREAD_MUTEX_DEFAULT}\~ {\b PTHREAD_MUTEX_NORMAL}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PTHREAD_MUTEX_INITIALIZER}\~ \{ 0, 0, -1, -1, -1 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP}\~ \{ 0, 0, -1, -1, -1 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PTHREAD_COND_INITIALIZER}\~ (({\b pthread_cond_t}) -1)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PTHREAD_BARRIER_SERIAL_THREAD}\~ ~0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PTHREAD_RWLOCK_INITIALIZER}\~ \{ {\b PTHREAD_MUTEX_INITIALIZER}, 0, 0, 0, 0, 0, 0 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SPINLOCK_UNLOCKED}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SPINLOCK_LOCKED}\~ 2\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SPINLOCK_USEMUTEX}\~ 3\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PTHREAD_SPINLOCK_INITIALIZER}\~ \{ 0, 0 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b uint32_t} {\b tls_t}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b uint32_t} {\b handle_t}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b handle_t} {\b pthread_t}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b tls_t} {\b pthread_key_t}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b pthread_attr} {\b pthread_attr_t}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b pthread_once} {\b pthread_once_t}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b pthread_mutexattr} {\b pthread_mutexattr_t}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b pthread_mutex} {\b pthread_mutex_t}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b pthread_condattr} {\b pthread_condattr_t}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b pthread_cond} {\b pthread_cond_t}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b pthread_barrierattr} {\b pthread_barrierattr_t}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b pthread_barrier} {\b pthread_barrier_t}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b pthread_rwlockattr} {\b pthread_rwlockattr_t}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b pthread_rwlock} {\b pthread_rwlock_t}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b pthread_spinlock} {\b pthread_spinlock_t}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_attr_init} ({\b pthread_attr_t} *attr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_attr_destroy} ({\b pthread_attr_t} *attr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_attr_getdetachstate} (const {\b pthread_attr_t} *attr, int *detachstate)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_attr_setdetachstate} ({\b pthread_attr_t} *attr, int detachstate)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_attr_getstackaddr} (const {\b pthread_attr_t} *attr, void **stackaddr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_attr_setstackaddr} ({\b pthread_attr_t} *attr, void *stackaddr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_attr_getstacksize} (const {\b pthread_attr_t} *attr, size_t *stacksize)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_attr_setstacksize} ({\b pthread_attr_t} *attr, size_t stacksize)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_attr_getschedparam} (const {\b pthread_attr_t} *attr, struct sched_param *param)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_attr_setschedparam} ({\b pthread_attr_t} *attr, const struct sched_param *param)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_attr_getschedpolicy} ({\b pthread_attr_t} *attr, int *policy)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_attr_setschedpolicy} ({\b pthread_attr_t} *attr, int policy)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_attr_getinheritsched} ({\b pthread_attr_t} *attr, int *inheritsched)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_attr_setinheritsched} ({\b pthread_attr_t} *attr, int inheritsched)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_attr_getscope} (const {\b pthread_attr_t} *attr, int *contentionscope)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_attr_setscope} ({\b pthread_attr_t} *attr, int contentionscope)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_create} ({\b pthread_t} *thread, const {\b pthread_attr_t} *attr, void *(*start)(void *), void *arg)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_detach} ({\b pthread_t} thread)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_equal} ({\b pthread_t} t1, {\b pthread_t} t2)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b pthread_exit} (void *value_ptr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_join} ({\b pthread_t} thread, void **value_ptr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b pthread_t} {\b pthread_self} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_cancel} ({\b pthread_t} thread)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_setcancelstate} (int state, int *oldstate)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_setcanceltype} (int {\b type}, int *oldtype)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b pthread_testcancel} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_once} ({\b pthread_once_t} *once_control, void(*init_routine)(void))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_setschedparam} ({\b pthread_t} thread, int policy, const struct sched_param *param)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_getschedparam} ({\b pthread_t} thread, int *policy, struct sched_param *param)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_setconcurrency} (int level)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_getconcurrency} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_key_create} ({\b pthread_key_t} *key, void(*destructor)(void *))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_key_delete} ({\b pthread_key_t} key)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_setspecific} ({\b pthread_key_t} key, const void *{\b value})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b pthread_getspecific} ({\b pthread_key_t} key)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_mutexattr_init} ({\b pthread_mutexattr_t} *attr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_mutexattr_destroy} ({\b pthread_mutexattr_t} *attr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_mutexattr_getpshared} (const {\b pthread_mutexattr_t} *attr, int *pshared)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_mutexattr_setpshared} ({\b pthread_mutexattr_t} *attr, int pshared)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_mutexattr_gettype} ({\b pthread_mutexattr_t} *attr, int *kind)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_mutexattr_settype} ({\b pthread_mutexattr_t} *attr, int kind)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_mutex_init} ({\b pthread_mutex_t} *mutex, const {\b pthread_mutexattr_t} *attr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_mutex_destroy} ({\b pthread_mutex_t} *mutex)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_mutex_lock} ({\b pthread_mutex_t} *mutex)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_mutex_timedlock} ({\b pthread_mutex_t} *mutex, const struct timespec *abstime)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_mutex_trylock} ({\b pthread_mutex_t} *mutex)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_mutex_unlock} ({\b pthread_mutex_t} *mutex)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_condattr_init} ({\b pthread_condattr_t} *attr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_condattr_destroy} ({\b pthread_condattr_t} *attr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_condattr_getpshared} (const {\b pthread_condattr_t} *attr, int *pshared)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_condattr_setpshared} ({\b pthread_condattr_t} *attr, int pshared)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_cond_init} ({\b pthread_cond_t} *cond, const {\b pthread_condattr_t} *attr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_cond_destroy} ({\b pthread_cond_t} *cond)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_cond_wait} ({\b pthread_cond_t} *cond, {\b pthread_mutex_t} *mutex)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_cond_timedwait} ({\b pthread_cond_t} *cond, {\b pthread_mutex_t} *mutex, const struct timespec *abstime)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_cond_signal} ({\b pthread_cond_t} *cond)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_cond_broadcast} ({\b pthread_cond_t} *cond)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_barrierattr_init} ({\b pthread_barrierattr_t} *attr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_barrierattr_destroy} ({\b pthread_barrierattr_t} *attr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_barrierattr_getpshared} (const {\b pthread_barrierattr_t} *attr, int *pshared)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_barrierattr_setpshared} ({\b pthread_barrierattr_t} *attr, int pshared)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_barrier_init} ({\b pthread_barrier_t} *barrier, const {\b pthread_barrierattr_t} *attr, unsigned int count)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_barrier_destroy} ({\b pthread_barrier_t} *barrier)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_barrier_wait} ({\b pthread_barrier_t} *barrier)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_rwlockattr_init} ({\b pthread_rwlockattr_t} *attr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_rwlockattr_destroy} ({\b pthread_rwlockattr_t} *attr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_rwlockattr_getpshared} (const {\b pthread_rwlockattr_t} *attr, int *pshared)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_rwlockattr_setpshared} ({\b pthread_rwlockattr_t} *attr, int pshared)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_rwlock_init} ({\b pthread_rwlock_t} *{\b lock}, const {\b pthread_rwlockattr_t} *attr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_rwlock_destroy} ({\b pthread_rwlock_t} *{\b lock})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_rwlock_tryrdlock} ({\b pthread_rwlock_t} *{\b lock})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_rwlock_trywrlock} ({\b pthread_rwlock_t} *{\b lock})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_rwlock_rdlock} ({\b pthread_rwlock_t} *{\b lock})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_rwlock_timedrdlock} ({\b pthread_rwlock_t} *{\b lock}, const struct timespec *abstime)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_rwlock_wrlock} ({\b pthread_rwlock_t} *{\b lock})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_rwlock_timedwrlock} ({\b pthread_rwlock_t} *{\b lock}, const struct timespec *abstime)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_rwlock_unlock} ({\b pthread_rwlock_t} *{\b lock})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_spin_init} ({\b pthread_spinlock_t} *{\b lock}, int pshared)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_spin_destroy} ({\b pthread_spinlock_t} *{\b lock})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_spin_lock} ({\b pthread_spinlock_t} *{\b lock})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_spin_trylock} ({\b pthread_spinlock_t} *{\b lock})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pthread_spin_unlock} ({\b pthread_spinlock_t} *{\b lock})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v _POSIX_THREADS\:pthread.h}
{\xe \v pthread.h\:_POSIX_THREADS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _POSIX_THREADS}}
\par
{\bkmkstart AAAAAAABNP}
{\bkmkend AAAAAAABNP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 32 of file pthread.h.}\par
}
{\xe \v PTHREAD_BARRIER_SERIAL_THREAD\:pthread.h}
{\xe \v pthread.h\:PTHREAD_BARRIER_SERIAL_THREAD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PTHREAD_BARRIER_SERIAL_THREAD\~ ~0}}
\par
{\bkmkstart AAAAAAABNQ}
{\bkmkend AAAAAAABNQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 114 of file pthread.h.}\par
}
{\xe \v PTHREAD_CANCEL_DISABLE\:pthread.h}
{\xe \v pthread.h\:PTHREAD_CANCEL_DISABLE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PTHREAD_CANCEL_DISABLE\~ 1}}
\par
{\bkmkstart AAAAAAABNR}
{\bkmkend AAAAAAABNR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 50 of file pthread.h.}\par
}
{\xe \v PTHREAD_CANCEL_ENABLE\:pthread.h}
{\xe \v pthread.h\:PTHREAD_CANCEL_ENABLE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PTHREAD_CANCEL_ENABLE\~ 0}}
\par
{\bkmkstart AAAAAAABNS}
{\bkmkend AAAAAAABNS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 49 of file pthread.h.}\par
}
{\xe \v PTHREAD_COND_INITIALIZER\:pthread.h}
{\xe \v pthread.h\:PTHREAD_COND_INITIALIZER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PTHREAD_COND_INITIALIZER\~ (({\b pthread_cond_t}) -1)}}
\par
{\bkmkstart AAAAAAABNT}
{\bkmkend AAAAAAABNT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 110 of file pthread.h.}\par
}
{\xe \v PTHREAD_CREATE_DETACHED\:pthread.h}
{\xe \v pthread.h\:PTHREAD_CREATE_DETACHED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PTHREAD_CREATE_DETACHED\~ 1}}
\par
{\bkmkstart AAAAAAABNU}
{\bkmkend AAAAAAABNU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 41 of file pthread.h.}\par
}
{\xe \v PTHREAD_CREATE_JOINABLE\:pthread.h}
{\xe \v pthread.h\:PTHREAD_CREATE_JOINABLE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PTHREAD_CREATE_JOINABLE\~ 0}}
\par
{\bkmkstart AAAAAAABNV}
{\bkmkend AAAAAAABNV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 40 of file pthread.h.}\par
}
{\xe \v PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP\:pthread.h}
{\xe \v pthread.h\:PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP\~ \{ 0, 0, -1, -1, -1 \}}}
\par
{\bkmkstart AAAAAAABNW}
{\bkmkend AAAAAAABNW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 98 of file pthread.h.}\par
}
{\xe \v PTHREAD_EXPLICIT_SCHED\:pthread.h}
{\xe \v pthread.h\:PTHREAD_EXPLICIT_SCHED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PTHREAD_EXPLICIT_SCHED\~ 1}}
\par
{\bkmkstart AAAAAAABNX}
{\bkmkend AAAAAAABNX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 44 of file pthread.h.}\par
}
{\xe \v PTHREAD_INHERIT_SCHED\:pthread.h}
{\xe \v pthread.h\:PTHREAD_INHERIT_SCHED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PTHREAD_INHERIT_SCHED\~ 0}}
\par
{\bkmkstart AAAAAAABNY}
{\bkmkend AAAAAAABNY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 43 of file pthread.h.}\par
}
{\xe \v PTHREAD_MUTEX_DEFAULT\:pthread.h}
{\xe \v pthread.h\:PTHREAD_MUTEX_DEFAULT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PTHREAD_MUTEX_DEFAULT\~ {\b PTHREAD_MUTEX_NORMAL}}}
\par
{\bkmkstart AAAAAAABNZ}
{\bkmkend AAAAAAABNZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 79 of file pthread.h.}\par
}
{\xe \v PTHREAD_MUTEX_ERRORCHECK\:pthread.h}
{\xe \v pthread.h\:PTHREAD_MUTEX_ERRORCHECK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PTHREAD_MUTEX_ERRORCHECK\~ 2}}
\par
{\bkmkstart AAAAAAABOA}
{\bkmkend AAAAAAABOA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 78 of file pthread.h.}\par
}
{\xe \v PTHREAD_MUTEX_INITIALIZER\:pthread.h}
{\xe \v pthread.h\:PTHREAD_MUTEX_INITIALIZER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PTHREAD_MUTEX_INITIALIZER\~ \{ 0, 0, -1, -1, -1 \}}}
\par
{\bkmkstart AAAAAAABOB}
{\bkmkend AAAAAAABOB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 97 of file pthread.h.}\par
}
{\xe \v PTHREAD_MUTEX_NORMAL\:pthread.h}
{\xe \v pthread.h\:PTHREAD_MUTEX_NORMAL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PTHREAD_MUTEX_NORMAL\~ 0}}
\par
{\bkmkstart AAAAAAABOC}
{\bkmkend AAAAAAABOC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 76 of file pthread.h.}\par
}
{\xe \v PTHREAD_MUTEX_RECURSIVE\:pthread.h}
{\xe \v pthread.h\:PTHREAD_MUTEX_RECURSIVE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PTHREAD_MUTEX_RECURSIVE\~ 1}}
\par
{\bkmkstart AAAAAAABOD}
{\bkmkend AAAAAAABOD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 77 of file pthread.h.}\par
}
{\xe \v PTHREAD_ONCE_INIT\:pthread.h}
{\xe \v pthread.h\:PTHREAD_ONCE_INIT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PTHREAD_ONCE_INIT\~ \{ 0, -1 \}}}
\par
{\bkmkstart AAAAAAABOE}
{\bkmkend AAAAAAABOE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 72 of file pthread.h.}\par
}
{\xe \v PTHREAD_PROCESS_PRIVATE\:pthread.h}
{\xe \v pthread.h\:PTHREAD_PROCESS_PRIVATE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PTHREAD_PROCESS_PRIVATE\~ 0}}
\par
{\bkmkstart AAAAAAABOF}
{\bkmkend AAAAAAABOF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 52 of file pthread.h.}\par
}
{\xe \v PTHREAD_PROCESS_SHARED\:pthread.h}
{\xe \v pthread.h\:PTHREAD_PROCESS_SHARED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PTHREAD_PROCESS_SHARED\~ 1}}
\par
{\bkmkstart AAAAAAABOG}
{\bkmkend AAAAAAABOG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 53 of file pthread.h.}\par
}
{\xe \v PTHREAD_RWLOCK_INITIALIZER\:pthread.h}
{\xe \v pthread.h\:PTHREAD_RWLOCK_INITIALIZER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PTHREAD_RWLOCK_INITIALIZER\~ \{ {\b PTHREAD_MUTEX_INITIALIZER}, 0, 0, 0, 0, 0, 0 \}}}
\par
{\bkmkstart AAAAAAABOH}
{\bkmkend AAAAAAABOH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 142 of file pthread.h.}\par
}
{\xe \v PTHREAD_SCOPE_PROCESS\:pthread.h}
{\xe \v pthread.h\:PTHREAD_SCOPE_PROCESS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PTHREAD_SCOPE_PROCESS\~ 0}}
\par
{\bkmkstart AAAAAAABOI}
{\bkmkend AAAAAAABOI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 46 of file pthread.h.}\par
}
{\xe \v PTHREAD_SCOPE_SYSTEM\:pthread.h}
{\xe \v pthread.h\:PTHREAD_SCOPE_SYSTEM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PTHREAD_SCOPE_SYSTEM\~ 1}}
\par
{\bkmkstart AAAAAAABOJ}
{\bkmkend AAAAAAABOJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 47 of file pthread.h.}\par
}
{\xe \v PTHREAD_SPINLOCK_INITIALIZER\:pthread.h}
{\xe \v pthread.h\:PTHREAD_SPINLOCK_INITIALIZER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PTHREAD_SPINLOCK_INITIALIZER\~ \{ 0, 0 \}}}
\par
{\bkmkstart AAAAAAABOK}
{\bkmkend AAAAAAABOK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 154 of file pthread.h.}\par
}
{\xe \v SPINLOCK_LOCKED\:pthread.h}
{\xe \v pthread.h\:SPINLOCK_LOCKED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SPINLOCK_LOCKED\~ 2}}
\par
{\bkmkstart AAAAAAABOL}
{\bkmkend AAAAAAABOL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 146 of file pthread.h.}\par
}
{\xe \v SPINLOCK_UNLOCKED\:pthread.h}
{\xe \v pthread.h\:SPINLOCK_UNLOCKED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SPINLOCK_UNLOCKED\~ 1}}
\par
{\bkmkstart AAAAAAABOM}
{\bkmkend AAAAAAABOM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 145 of file pthread.h.}\par
}
{\xe \v SPINLOCK_USEMUTEX\:pthread.h}
{\xe \v pthread.h\:SPINLOCK_USEMUTEX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SPINLOCK_USEMUTEX\~ 3}}
\par
{\bkmkstart AAAAAAABON}
{\bkmkend AAAAAAABON}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 147 of file pthread.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v handle_t\:pthread.h}
{\xe \v pthread.h\:handle_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b uint32_t} {\b handle_t}}}
\par
{\bkmkstart AAAAAAABOO}
{\bkmkend AAAAAAABOO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 36 of file pthread.h.}\par
}
{\xe \v pthread_attr_t\:pthread.h}
{\xe \v pthread.h\:pthread_attr_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b pthread_attr}  {\b pthread_attr_t}}}
\par
{\bkmkstart AAAAAAABOP}
{\bkmkend AAAAAAABOP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v pthread_barrier_t\:pthread.h}
{\xe \v pthread.h\:pthread_barrier_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b pthread_barrier}  {\b pthread_barrier_t}}}
\par
{\bkmkstart AAAAAAABOQ}
{\bkmkend AAAAAAABOQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v pthread_barrierattr_t\:pthread.h}
{\xe \v pthread.h\:pthread_barrierattr_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b pthread_barrierattr}  {\b pthread_barrierattr_t}}}
\par
{\bkmkstart AAAAAAABOR}
{\bkmkend AAAAAAABOR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v pthread_cond_t\:pthread.h}
{\xe \v pthread.h\:pthread_cond_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b pthread_cond}  {\b pthread_cond_t}}}
\par
{\bkmkstart AAAAAAABOS}
{\bkmkend AAAAAAABOS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v pthread_condattr_t\:pthread.h}
{\xe \v pthread.h\:pthread_condattr_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b pthread_condattr}  {\b pthread_condattr_t}}}
\par
{\bkmkstart AAAAAAABOT}
{\bkmkend AAAAAAABOT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v pthread_key_t\:pthread.h}
{\xe \v pthread.h\:pthread_key_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b tls_t} {\b pthread_key_t}}}
\par
{\bkmkstart AAAAAAABOU}
{\bkmkend AAAAAAABOU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 38 of file pthread.h.}\par
}
{\xe \v pthread_mutex_t\:pthread.h}
{\xe \v pthread.h\:pthread_mutex_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b pthread_mutex}  {\b pthread_mutex_t}}}
\par
{\bkmkstart AAAAAAABOV}
{\bkmkend AAAAAAABOV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v pthread_mutexattr_t\:pthread.h}
{\xe \v pthread.h\:pthread_mutexattr_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b pthread_mutexattr}  {\b pthread_mutexattr_t}}}
\par
{\bkmkstart AAAAAAABOW}
{\bkmkend AAAAAAABOW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v pthread_once_t\:pthread.h}
{\xe \v pthread.h\:pthread_once_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b pthread_once}  {\b pthread_once_t}}}
\par
{\bkmkstart AAAAAAABOX}
{\bkmkend AAAAAAABOX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v pthread_rwlock_t\:pthread.h}
{\xe \v pthread.h\:pthread_rwlock_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b pthread_rwlock}  {\b pthread_rwlock_t}}}
\par
{\bkmkstart AAAAAAABOY}
{\bkmkend AAAAAAABOY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v pthread_rwlockattr_t\:pthread.h}
{\xe \v pthread.h\:pthread_rwlockattr_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b pthread_rwlockattr}  {\b pthread_rwlockattr_t}}}
\par
{\bkmkstart AAAAAAABOZ}
{\bkmkend AAAAAAABOZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v pthread_spinlock_t\:pthread.h}
{\xe \v pthread.h\:pthread_spinlock_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b pthread_spinlock}  {\b pthread_spinlock_t}}}
\par
{\bkmkstart AAAAAAABPA}
{\bkmkend AAAAAAABPA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v pthread_t\:pthread.h}
{\xe \v pthread.h\:pthread_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b handle_t} {\b pthread_t}}}
\par
{\bkmkstart AAAAAAABPB}
{\bkmkend AAAAAAABPB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 37 of file pthread.h.}\par
}
{\xe \v tls_t\:pthread.h}
{\xe \v pthread.h\:tls_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b uint32_t} {\b tls_t}}}
\par
{\bkmkstart AAAAAAABPC}
{\bkmkend AAAAAAABPC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 35 of file pthread.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v pthread_attr_destroy\:pthread.h}
{\xe \v pthread.h\:pthread_attr_destroy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_attr_destroy ({\b pthread_attr_t} * {\i attr})}}
\par
{\bkmkstart AAAAAAABPD}
{\bkmkend AAAAAAABPD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 28 of file pthread_attr.c.}\par
{
References errno.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28                                                       \{\par
29     if(!attr) \{\par
30         errno = EINVAL;\par
31         return 1;\par
32     \}\par
33 \par
34     memset(attr, 0, sizeof(pthread_attr_t));\par
35     return 0;\par
36 \}\par
}
}
{\xe \v pthread_attr_getdetachstate\:pthread.h}
{\xe \v pthread.h\:pthread_attr_getdetachstate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_attr_getdetachstate (const {\b pthread_attr_t} * {\i attr}, int * {\i detachstate})}}
\par
{\bkmkstart AAAAAAABPE}
{\bkmkend AAAAAAABPE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 38 of file pthread_attr.c.}\par
{
References pthread_attr::detachstate, and errno.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 38                                                                                      \{\par
39     if(!attr) \{\par
40         errno = EINVAL;\par
41         return 1;\par
42     \}\par
43 \par
44     *detachstate = attr->detachstate;\par
45     return 0;\par
46 \}\par
}
}
{\xe \v pthread_attr_getinheritsched\:pthread.h}
{\xe \v pthread.h\:pthread_attr_getinheritsched}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_attr_getinheritsched ({\b pthread_attr_t} * {\i attr}, int * {\i inheritsched})}}
\par
{\bkmkstart AAAAAAABPF}
{\bkmkend AAAAAAABPF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 133 of file pthread_attr.c.}\par
{
References errno, and pthread_attr::inheritsched.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 133                                                                                  \{\par
134     if(!attr) \{\par
135         errno = EINVAL;\par
136         return 1;\par
137     \}\par
138 \par
139     *inheritsched = attr->inheritsched;\par
140     return 0;\par
141 \}\par
}
}
{\xe \v pthread_attr_getschedparam\:pthread.h}
{\xe \v pthread.h\:pthread_attr_getschedparam}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_attr_getschedparam (const {\b pthread_attr_t} * {\i attr}, struct sched_param * {\i param})}}
\par
{\bkmkstart AAAAAAABPG}
{\bkmkend AAAAAAABPG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 100 of file pthread_attr.c.}\par
{
References errno, and pthread_attr::param.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 100                                                                                              \{\par
101     if(!attr) \{\par
102         errno = EINVAL;\par
103         return 1;\par
104     \}\par
105 \par
106     memcpy(param, &attr->param, sizeof(struct sched_param));\par
107     return 0; \par
108 \}\par
}
}
{\xe \v pthread_attr_getschedpolicy\:pthread.h}
{\xe \v pthread.h\:pthread_attr_getschedpolicy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_attr_getschedpolicy ({\b pthread_attr_t} * {\i attr}, int * {\i policy})}}
\par
{\bkmkstart AAAAAAABPH}
{\bkmkend AAAAAAABPH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 123 of file pthread_attr.c.}\par
{
References errno.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 123                                                                           \{\par
124     errno = ENOSYS;\par
125     return 1;\par
126 \}\par
}
}
{\xe \v pthread_attr_getscope\:pthread.h}
{\xe \v pthread.h\:pthread_attr_getscope}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_attr_getscope (const {\b pthread_attr_t} * {\i attr}, int * {\i contentionscope})}}
\par
{\bkmkstart AAAAAAABPI}
{\bkmkend AAAAAAABPI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 153 of file pthread_attr.c.}\par
{
References pthread_attr::contentionscope, and errno.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 153                                                                                    \{\par
154     if(!attr) \{\par
155         errno = EINVAL;\par
156         return 1;\par
157     \}\par
158 \par
159     *contentionscope = attr->contentionscope;\par
160     return 0;\par
161 \}\par
}
}
{\xe \v pthread_attr_getstackaddr\:pthread.h}
{\xe \v pthread.h\:pthread_attr_getstackaddr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_attr_getstackaddr (const {\b pthread_attr_t} * {\i attr}, void ** {\i stackaddr})}}
\par
{\bkmkstart AAAAAAABPJ}
{\bkmkend AAAAAAABPJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 58 of file pthread_attr.c.}\par
{
References errno, and pthread_attr::stackaddr.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 58                                                                                    \{\par
59     if(!attr) \{\par
60         errno = EINVAL;\par
61         return 1;\par
62     \}\par
63 \par
64     *stackaddr = attr->stackaddr;\par
65     return 0;\par
66 \}\par
}
}
{\xe \v pthread_attr_getstacksize\:pthread.h}
{\xe \v pthread.h\:pthread_attr_getstacksize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_attr_getstacksize (const {\b pthread_attr_t} * {\i attr}, size_t * {\i stacksize})}}
\par
{\bkmkstart AAAAAAABPK}
{\bkmkend AAAAAAABPK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 79 of file pthread_attr.c.}\par
{
References errno, and pthread_attr::stacksize.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 79                                                                                     \{\par
80     if(!attr) \{\par
81         errno = EINVAL;\par
82         return 1;\par
83     \}\par
84 \par
85     *stacksize = attr->stacksize;\par
86     return 0;\par
87 \}\par
}
}
{\xe \v pthread_attr_init\:pthread.h}
{\xe \v pthread.h\:pthread_attr_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_attr_init ({\b pthread_attr_t} * {\i attr})}}
\par
{\bkmkstart AAAAAAABPL}
{\bkmkend AAAAAAABPL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 12 of file pthread_attr.c.}\par
{
References pthread_attr::contentionscope, pthread_attr::detachstate, errno, pthread_attr::inheritsched, pthread_attr::param, PTHREAD_STACK_MIN, pthread_attr::stackaddr, and pthread_attr::stacksize.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12                                                    \{\par
13     if(!attr) \{\par
14         errno = EINVAL;\par
15         return 1;\par
16     \}\par
17 \par
18     attr->stackaddr = 0;\par
19     attr->stacksize = PTHREAD_STACK_MIN;\par
20     attr->detachstate = 0;\par
21     attr->param.sched_priority = 0;\par
22     attr->inheritsched = 0;\par
23     attr->contentionscope = 0;\par
24     \par
25     return 0;\par
26 \}\par
}
}
{\xe \v pthread_attr_setdetachstate\:pthread.h}
{\xe \v pthread.h\:pthread_attr_setdetachstate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_attr_setdetachstate ({\b pthread_attr_t} * {\i attr}, int {\i detachstate})}}
\par
{\bkmkstart AAAAAAABPM}
{\bkmkend AAAAAAABPM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 48 of file pthread_attr.c.}\par
{
References pthread_attr::detachstate, and errno.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 48                                                                               \{\par
49     if(!attr) \{\par
50         errno = EINVAL;\par
51         return 1;\par
52     \}\par
53 \par
54     attr->detachstate = detachstate;\par
55     return 0;\par
56 \}\par
}
}
{\xe \v pthread_attr_setinheritsched\:pthread.h}
{\xe \v pthread.h\:pthread_attr_setinheritsched}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_attr_setinheritsched ({\b pthread_attr_t} * {\i attr}, int {\i inheritsched})}}
\par
{\bkmkstart AAAAAAABPN}
{\bkmkend AAAAAAABPN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 143 of file pthread_attr.c.}\par
{
References errno, and pthread_attr::inheritsched.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 143                                                                                 \{\par
144     if(!attr) \{\par
145         errno = EINVAL;\par
146         return 1;\par
147     \}\par
148 \par
149     attr->inheritsched = inheritsched;\par
150     return 0;\par
151 \}\par
}
}
{\xe \v pthread_attr_setschedparam\:pthread.h}
{\xe \v pthread.h\:pthread_attr_setschedparam}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_attr_setschedparam ({\b pthread_attr_t} * {\i attr}, const struct sched_param * {\i param})}}
\par
{\bkmkstart AAAAAAABPO}
{\bkmkend AAAAAAABPO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 112 of file pthread_attr.c.}\par
{
References errno, and pthread_attr::param.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 112                                                                                              \{\par
113     if(!attr) \{\par
114         errno = EINVAL;\par
115         return 1;\par
116     \}\par
117 \par
118     memcpy(&attr->param, param, sizeof(struct sched_param));\par
119     return 0; \par
120 \}\par
}
}
{\xe \v pthread_attr_setschedpolicy\:pthread.h}
{\xe \v pthread.h\:pthread_attr_setschedpolicy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_attr_setschedpolicy ({\b pthread_attr_t} * {\i attr}, int {\i policy})}}
\par
{\bkmkstart AAAAAAABPP}
{\bkmkend AAAAAAABPP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 128 of file pthread_attr.c.}\par
{
References errno.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 128                                                                          \{\par
129     errno = ENOSYS;\par
130     return 1;\par
131 \}\par
}
}
{\xe \v pthread_attr_setscope\:pthread.h}
{\xe \v pthread.h\:pthread_attr_setscope}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_attr_setscope ({\b pthread_attr_t} * {\i attr}, int {\i contentionscope})}}
\par
{\bkmkstart AAAAAAABPQ}
{\bkmkend AAAAAAABPQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 163 of file pthread_attr.c.}\par
{
References pthread_attr::contentionscope, and errno.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 163                                                                             \{\par
164     if(!attr) \{\par
165         errno = EINVAL;\par
166         return 1;\par
167     \}\par
168 \par
169     attr->contentionscope = contentionscope;\par
170     return 0;\par
171 \}\par
}
}
{\xe \v pthread_attr_setstackaddr\:pthread.h}
{\xe \v pthread.h\:pthread_attr_setstackaddr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_attr_setstackaddr ({\b pthread_attr_t} * {\i attr}, void * {\i stackaddr})}}
\par
{\bkmkstart AAAAAAABPR}
{\bkmkend AAAAAAABPR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 68 of file pthread_attr.c.}\par
{
References errno, and pthread_attr::stackaddr.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 68                                                                             \{\par
69     if(!attr) \{\par
70         errno = EINVAL;\par
71         return 1;\par
72     \}\par
73 \par
74     attr->stackaddr = stackaddr;\par
75     return 0;\par
76 \}\par
}
}
{\xe \v pthread_attr_setstacksize\:pthread.h}
{\xe \v pthread.h\:pthread_attr_setstacksize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_attr_setstacksize ({\b pthread_attr_t} * {\i attr}, size_t {\i stacksize})}}
\par
{\bkmkstart AAAAAAABPS}
{\bkmkend AAAAAAABPS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 89 of file pthread_attr.c.}\par
{
References errno, and pthread_attr::stacksize.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 89                                                                              \{\par
90     if(!attr) \{\par
91         errno = EINVAL;\par
92         return 1;\par
93     \}\par
94 \par
95     attr->stacksize = stacksize;\par
96     return 0;\par
97 \}\par
}
}
{\xe \v pthread_barrier_destroy\:pthread.h}
{\xe \v pthread.h\:pthread_barrier_destroy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_barrier_destroy ({\b pthread_barrier_t} * {\i barrier})}}
\par
{\bkmkstart AAAAAAABPT}
{\bkmkend AAAAAAABPT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 28 of file pthread_barrier.c.}\par
{
References pthread_barrier::curr_height, errno, and pthread_barrier::init_height.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28                                                                \{\par
29     if(barrier == NULL) \{\par
30         errno = EINVAL;\par
31         return 1;\par
32     \}\par
33 \par
34     barrier->curr_height = 0;\par
35     barrier->init_height = 0;\par
36     \par
37 \par
38     return 0;\par
39 \}\par
}
}
{\xe \v pthread_barrier_init\:pthread.h}
{\xe \v pthread.h\:pthread_barrier_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_barrier_init ({\b pthread_barrier_t} * {\i barrier}, const {\b pthread_barrierattr_t} * {\i attr}, unsigned int {\i count})}}
\par
{\bkmkstart AAAAAAABPU}
{\bkmkend AAAAAAABPU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9 of file pthread_barrier.c.}\par
{
References pthread_barrier::curr_height, errno, and pthread_barrier::init_height.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 9                                                                                                                    \{\par
10     if(barrier == NULL) \{\par
11         errno = EINVAL;\par
12         return 1;\par
13     \}\par
14 \par
15     if(count == 0) \{\par
16         errno = EINVAL;\par
17         return 1;\par
18     \}\par
19 \par
20     barrier->curr_height = 0;\par
21     barrier->init_height = count;\par
22     \par
23 \par
24     return 0;\par
25 \}\par
}
}
{\xe \v pthread_barrier_wait\:pthread.h}
{\xe \v pthread.h\:pthread_barrier_wait}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_barrier_wait ({\b pthread_barrier_t} * {\i barrier})}}
\par
{\bkmkstart AAAAAAABPV}
{\bkmkend AAAAAAABPV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 42 of file pthread_barrier.c.}\par
{
References pthread_barrier::curr_height, errno, pthread_barrier::init_height, and sched_yield().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 42                                                             \{\par
43     if(barrier == NULL) \{\par
44         errno = EINVAL;\par
45         return 1;\par
46     \}\par
47 \par
48     barrier->curr_height += 1;\par
49 \par
50     while(barrier->curr_height < barrier->init_height)\par
51         sched_yield();\par
52 \par
53     return 0;\par
54 \}\par
}
}
{\xe \v pthread_barrierattr_destroy\:pthread.h}
{\xe \v pthread.h\:pthread_barrierattr_destroy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_barrierattr_destroy ({\b pthread_barrierattr_t} * {\i attr})}}
\par
{\bkmkstart AAAAAAABPW}
{\bkmkend AAAAAAABPW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 20 of file pthread_barrierattr.c.}\par
{
References errno, and pthread_barrierattr::pshared.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20                                                                     \{\par
21     if(attr == NULL) \{\par
22         errno = EINVAL;\par
23         return 1;\par
24     \}\par
25 \par
26     attr->pshared = 0;\par
27     return 0;\par
28 \}\par
}
}
{\xe \v pthread_barrierattr_getpshared\:pthread.h}
{\xe \v pthread.h\:pthread_barrierattr_getpshared}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_barrierattr_getpshared (const {\b pthread_barrierattr_t} * {\i attr}, int * {\i pshared})}}
\par
{\bkmkstart AAAAAAABPX}
{\bkmkend AAAAAAABPX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 31 of file pthread_barrierattr.c.}\par
{
References errno, and pthread_barrierattr::pshared.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 31                                                                                            \{\par
32     if(attr == NULL) \{\par
33         errno = EINVAL;\par
34         return 1;\par
35     \}\par
36 \par
37     if(pshared == NULL) \{\par
38         errno = EINVAL;\par
39         return 1;\par
40     \}\par
41     \par
42     *pshared = attr->pshared;\par
43     return 0;\par
44 \}\par
}
}
{\xe \v pthread_barrierattr_init\:pthread.h}
{\xe \v pthread.h\:pthread_barrierattr_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_barrierattr_init ({\b pthread_barrierattr_t} * {\i attr})}}
\par
{\bkmkstart AAAAAAABPY}
{\bkmkend AAAAAAABPY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9 of file pthread_barrierattr.c.}\par
{
References errno, and pthread_barrierattr::pshared.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 9                                                                  \{\par
10     if(attr == NULL) \{\par
11         errno = EINVAL;\par
12         return 1;\par
13     \}\par
14 \par
15     attr->pshared = 0;\par
16     return 0;\par
17 \}\par
}
}
{\xe \v pthread_barrierattr_setpshared\:pthread.h}
{\xe \v pthread.h\:pthread_barrierattr_setpshared}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_barrierattr_setpshared ({\b pthread_barrierattr_t} * {\i attr}, int {\i pshared})}}
\par
{\bkmkstart AAAAAAABPZ}
{\bkmkend AAAAAAABPZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 47 of file pthread_barrierattr.c.}\par
{
References errno, and pthread_barrierattr::pshared.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 47                                                                                     \{\par
48     if(attr == NULL) \{\par
49         errno = EINVAL;\par
50         return 1;\par
51     \}\par
52 \par
53     attr->pshared = pshared;\par
54     return 0;\par
55 \}\par
}
}
{\xe \v pthread_cancel\:pthread.h}
{\xe \v pthread.h\:pthread_cancel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_cancel ({\b pthread_t} {\i thread})}}
\par
{\bkmkstart AAAAAAABQA}
{\bkmkend AAAAAAABQA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 7 of file pthread_cancel.c.}\par
{
References pthread_detach().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7                                             \{\par
8     return pthread_detach(thread);\par
9 \}\par
}
}
{\xe \v pthread_cond_broadcast\:pthread.h}
{\xe \v pthread.h\:pthread_cond_broadcast}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_cond_broadcast ({\b pthread_cond_t} * {\i cond})}}
\par
{\bkmkstart AAAAAAABQB}
{\bkmkend AAAAAAABQB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 116 of file pthread_cond.c.}\par
{
References __pthread_queue, pthread_context::cond, errno, pthread_context::next, pthread_cond::semaphore, and pthread_cond::waiting.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 116                                                         \{\par
117     if(!__pthread_queue) \{\par
118         errno = ESRCH;\par
119         return -1;\par
120     \}\par
121 \par
122 \par
123     pthread_context_t* tmp = __pthread_queue;\par
124     while(tmp) \{\par
125         if(tmp->cond == cond) \{\par
126             if(tmp->cond->waiting) \{\par
127                 tmp->cond->semaphore = 0;       \par
128             \}\par
129         \}\par
130 \par
131         tmp = tmp->next;\par
132     \}\par
133 \par
134 \par
135     return 0;\par
136 \}\par
}
}
{\xe \v pthread_cond_destroy\:pthread.h}
{\xe \v pthread.h\:pthread_cond_destroy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_cond_destroy ({\b pthread_cond_t} * {\i cond})}}
\par
{\bkmkstart AAAAAAABQC}
{\bkmkend AAAAAAABQC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 25 of file pthread_cond.c.}\par
{
References errno, pthread_cond::semaphore, and pthread_cond::waiting.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25                                                       \{\par
26     if(!cond) \{\par
27         errno = EINVAL;\par
28         return 1;\par
29     \}\par
30 \par
31     if(cond->waiting) \{\par
32         errno = EBUSY;\par
33         return 1;\par
34     \}\par
35 \par
36 \par
37     cond->waiting = 0;\par
38     cond->semaphore = 0;        \par
39     \par
40     return 0;\par
41 \}\par
}
}
{\xe \v pthread_cond_init\:pthread.h}
{\xe \v pthread.h\:pthread_cond_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_cond_init ({\b pthread_cond_t} * {\i cond}, const {\b pthread_condattr_t} * {\i attr})}}
\par
{\bkmkstart AAAAAAABQD}
{\bkmkend AAAAAAABQD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 13 of file pthread_cond.c.}\par
{
References errno, pthread_cond::semaphore, and pthread_cond::waiting.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13                                                                                    \{\par
14     if(!cond) \{\par
15         errno = EINVAL;\par
16         return 1;\par
17     \}\par
18 \par
19     cond->waiting = 0;\par
20     cond->semaphore = 0;\par
21 \par
22     return 0;\par
23 \}\par
}
}
{\xe \v pthread_cond_signal\:pthread.h}
{\xe \v pthread.h\:pthread_cond_signal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_cond_signal ({\b pthread_cond_t} * {\i cond})}}
\par
{\bkmkstart AAAAAAABQE}
{\bkmkend AAAAAAABQE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 93 of file pthread_cond.c.}\par
{
References __pthread_queue, pthread_context::cond, errno, pthread_context::next, pthread_cond::semaphore, and pthread_cond::waiting.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 93                                                      \{\par
94     if(!__pthread_queue) \{\par
95         errno = ESRCH;\par
96         return -1;\par
97     \}\par
98 \par
99 \par
100     pthread_context_t* tmp = __pthread_queue;\par
101     while(tmp) \{\par
102         if(tmp->cond == cond) \{\par
103             if(tmp->cond->waiting) \{\par
104                 tmp->cond->semaphore = 0;\par
105                 return 0;           \par
106             \}\par
107         \}\par
108 \par
109         tmp = tmp->next;\par
110     \}\par
111 \par
112     errno = ESRCH;\par
113     return -1;\par
114 \}\par
}
}
{\xe \v pthread_cond_timedwait\:pthread.h}
{\xe \v pthread.h\:pthread_cond_timedwait}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_cond_timedwait ({\b pthread_cond_t} * {\i cond}, {\b pthread_mutex_t} * {\i mutex}, const struct timespec * {\i abstime})}}
\par
{\bkmkstart AAAAAAABQF}
{\bkmkend AAAAAAABQF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 44 of file pthread_cond.c.}\par
{
References pthread_context::cond, errno, pthread_mutex::owner, pthread_mutex_unlock(), pthread_self(), sched_yield(), pthread_cond::semaphore, and pthread_cond::waiting.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 44                                                                                                                 \{\par
45         if(!cond) \{\par
46         errno = EINVAL;\par
47         return 1;\par
48     \}\par
49 \par
50     if(!mutex) \{\par
51         errno = EINVAL;\par
52         return 1;\par
53     \}\par
54 \par
55     if(mutex->owner != pthread_self()) \{\par
56         errno = EINVAL;\par
57         return 1;\par
58     \}\par
59 \par
60     pthread_context_t* ctx = (pthread_context_t*) pthread_self();\par
61     if(!ctx) \{\par
62         errno = EINVAL;\par
63         return -1;\par
64     \}\par
65 \par
66     ctx->cond = cond;\par
67     ctx->cond->waiting = 1;\par
68     ctx->cond->semaphore = 1;\par
69 \par
70     int t0;\par
71     if(abstime)\par
72         t0 = time(NULL) + abstime->tv_sec;\par
73     else\par
74         t0 = ~0;\par
75 \par
76     while(ctx->cond->semaphore == 1 && (time(NULL) < t0))\par
77         sched_yield();\par
78 \par
79     ctx->cond->waiting = 0;\par
80     ctx->cond->semaphore = 0;\par
81     ctx->cond = 0;\par
82 \par
83     pthread_mutex_unlock(mutex);\par
84 \par
85     return 0;\par
86 \}\par
}
}
{\xe \v pthread_cond_wait\:pthread.h}
{\xe \v pthread.h\:pthread_cond_wait}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_cond_wait ({\b pthread_cond_t} * {\i cond}, {\b pthread_mutex_t} * {\i mutex})}}
\par
{\bkmkstart AAAAAAABQG}
{\bkmkend AAAAAAABQG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 88 of file pthread_cond.c.}\par
{
References pthread_cond_timedwait().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 88                                                                            \{\par
89     return pthread_cond_timedwait(cond, mutex, NULL);\par
90 \}\par
}
}
{\xe \v pthread_condattr_destroy\:pthread.h}
{\xe \v pthread.h\:pthread_condattr_destroy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_condattr_destroy ({\b pthread_condattr_t} * {\i attr})}}
\par
{\bkmkstart AAAAAAABQH}
{\bkmkend AAAAAAABQH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 18 of file pthread_condattr.c.}\par
{
References errno, and pthread_condattr::pshared.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18                                                               \{\par
19     if(!attr) \{\par
20         errno = EINVAL;\par
21         return 1;\par
22     \}\par
23 \par
24     attr->pshared = 0;\par
25     return 0;\par
26 \}\par
}
}
{\xe \v pthread_condattr_getpshared\:pthread.h}
{\xe \v pthread.h\:pthread_condattr_getpshared}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_condattr_getpshared (const {\b pthread_condattr_t} * {\i attr}, int * {\i pshared})}}
\par
{\bkmkstart AAAAAAABQI}
{\bkmkend AAAAAAABQI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 29 of file pthread_condattr.c.}\par
{
References errno, and pthread_condattr::pshared.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 29                                                                                      \{\par
30     if(!attr) \{\par
31         errno = EINVAL;\par
32         return 1;\par
33     \}\par
34 \par
35     \par
36     *pshared = attr->pshared;\par
37     return 0;\par
38 \}\par
}
}
{\xe \v pthread_condattr_init\:pthread.h}
{\xe \v pthread.h\:pthread_condattr_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_condattr_init ({\b pthread_condattr_t} * {\i attr})}}
\par
{\bkmkstart AAAAAAABQJ}
{\bkmkend AAAAAAABQJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 7 of file pthread_condattr.c.}\par
{
References errno, and pthread_condattr::pshared.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7                                                            \{\par
8     if(!attr) \{\par
9         errno = EINVAL;\par
10         return 1;\par
11     \}\par
12 \par
13     attr->pshared = 0;\par
14     return 0;\par
15 \}\par
}
}
{\xe \v pthread_condattr_setpshared\:pthread.h}
{\xe \v pthread.h\:pthread_condattr_setpshared}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_condattr_setpshared ({\b pthread_condattr_t} * {\i attr}, int {\i pshared})}}
\par
{\bkmkstart AAAAAAABQK}
{\bkmkend AAAAAAABQK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 41 of file pthread_condattr.c.}\par
{
References errno, and pthread_condattr::pshared.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 41                                                                               \{\par
42     if(!attr) \{\par
43         errno = EINVAL;\par
44         return 1;\par
45     \}\par
46 \par
47     attr->pshared = pshared;\par
48     return 0;\par
49 \}\par
}
}
{\xe \v pthread_create\:pthread.h}
{\xe \v pthread.h\:pthread_create}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_create ({\b pthread_t} * {\i thread}, const {\b pthread_attr_t} * {\i attr}, void *(*)(void *) {\i start}, void * {\i arg})}}
\par
{\bkmkstart AAAAAAABQL}
{\bkmkend AAAAAAABQL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 37 of file pthread_create.c.}\par
{
References __os_thread_create, __pthread_counts, __pthread_handler__(), __pthread_init_queue(), __pthread_queue, pthread_context::attr, pthread_once::done, pthread_context::entry, errno, pthread_attr::inheritsched, pthread_context::next, pthread_context::once, pthread_context::param, pthread_attr::param, pthread_attr_setschedparam(), PTHREAD_INHERIT_SCHED, pthread_self(), PTHREAD_THREADS_MAX, pthread_once::started, and pthread_context::tid.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 37                                                                                                            \{\par
38 \par
39     __pthread_init_queue();\par
40 \par
41     if(!thread) \{\par
42         errno = EINVAL;\par
43         return 1;\par
44     \}\par
45 \par
46     if(__pthread_counts > PTHREAD_THREADS_MAX) \{\par
47         errno = EAGAIN;\par
48         return 1;\par
49     \}\par
50 \par
51     pthread_context_t* ctx = malloc(sizeof(pthread_context_t));\par
52     memset(ctx, 0, sizeof(pthread_context_t));\par
53 \par
54     ctx->entry = start;\par
55     ctx->param = arg;\par
56     ctx->once.done = 0;\par
57     ctx->once.started = -1;\par
58     ctx->next = 0;\par
59 \par
60     if(attr)\par
61         memcpy(&ctx->attr, attr, sizeof(pthread_attr_t));\par
62 \par
63     if(ctx->attr.inheritsched == PTHREAD_INHERIT_SCHED) \{\par
64         pthread_t px = pthread_self();\par
65         if(px) \{\par
66             pthread_context_t* inh = (pthread_context_t*) px;\par
67             pthread_attr_setschedparam(&ctx->attr, &inh->attr.param);\par
68         \}\par
69     \}\par
70 \par
71 \par
72     __pthread_counts += 1;\par
73     *thread = (pthread_t) ctx;\par
74     \par
75     \par
76     ctx->next = __pthread_queue;\par
77     __pthread_queue = ctx;\par
78         \par
79 \par
80 \par
81     ctx->tid = __os_thread_create(__pthread_handler__, ctx, ctx->attr.param.sched_priority);\par
82     return 0;\par
83 \}\par
}
}
{\xe \v pthread_detach\:pthread.h}
{\xe \v pthread.h\:pthread_detach}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_detach ({\b pthread_t} {\i thread})}}
\par
{\bkmkstart AAAAAAABQM}
{\bkmkend AAAAAAABQM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 12 of file pthread_detach.c.}\par
{
References __os_thread_kill, __pthread_queue, pthread_once::done, errno, pthread_context::once, and pthread_context::tid.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12                                             \{\par
13     if(!thread) \{\par
14         errno = EINVAL;\par
15         return 1;\par
16     \}\par
17 \par
18     if(!__pthread_queue) \{\par
19         errno = ESRCH;\par
20         return 1;\par
21     \}\par
22 \par
23     pthread_context_t* ctx = (pthread_context_t*) thread;\par
24     if(__os_thread_kill(ctx->tid, SIGKILL) == 0)\par
25         ctx->once.done = 1;\par
26     else \{\par
27         errno = ESRCH;\par
28         return 1;\par
29     \}\par
30 \par
31     __pthread_counts -= 1;\par
32     pthread_context_t* tmp = __pthread_queue;\par
33 \par
34     if(tmp->next) \{\par
35         while(tmp->next) \{\par
36             if(tmp->next == ctx) \{\par
37                 tmp->next = ctx->next;\par
38                 break;\par
39             \}\par
40 \par
41             tmp = tmp->next;\par
42         \}\par
43     \} else \{\par
44         if(__pthread_queue == ctx)\par
45             __pthread_queue = 0;\par
46     \}\par
47 \par
48     return 0;\par
49 \}\par
}
}
{\xe \v pthread_equal\:pthread.h}
{\xe \v pthread.h\:pthread_equal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_equal ({\b pthread_t} {\i t1}, {\b pthread_t} {\i t2})}}
\par
{\bkmkstart AAAAAAABQN}
{\bkmkend AAAAAAABQN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 7 of file pthread_equal.c.}\par
{
References pthread_context::tid.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7                                                      \{\par
8     pthread_context_t* c1 = (pthread_context_t*) t1;\par
9     pthread_context_t* c2 = (pthread_context_t*) t2;\par
10 \par
11     return (c1->tid == c2->tid);\par
12 \}\par
}
}
{\xe \v pthread_exit\:pthread.h}
{\xe \v pthread.h\:pthread_exit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void pthread_exit (void * {\i value_ptr})}}
\par
{\bkmkstart AAAAAAABQO}
{\bkmkend AAAAAAABQO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 8 of file pthread_exit.c.}\par
{
References pthread_context::exitval, pthread_detach(), and pthread_self().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 8                                           \{\par
9     pthread_t ptx = pthread_self();\par
10     pthread_context_t* ctx = (pthread_context_t*) ptx;\par
11 \par
12     if(ptx) \{\par
13         ctx->exitval = value_ptr;\par
14         pthread_detach(ptx);\par
15     \}else\par
16         abort();\par
17 \par
18     for(;;);\par
19 \}\par
}
}
{\xe \v pthread_getconcurrency\:pthread.h}
{\xe \v pthread.h\:pthread_getconcurrency}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_getconcurrency (void )}}
\par
{\bkmkstart AAAAAAABQP}
{\bkmkend AAAAAAABQP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 57 of file pthread_sched.c.}\par
{
References pthread_context::attr, errno, pthread_attr::param, and pthread_self().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 57                                         \{\par
58     pthread_t thread = pthread_self();\par
59     if(!thread) \{\par
60         errno = ESRCH;\par
61         return 1;\par
62     \}\par
63 \par
64     pthread_context_t* ctx = (pthread_context_t*) thread;\par
65     return ctx->attr.param.sched_priority;\par
66 \}\par
}
}
{\xe \v pthread_getschedparam\:pthread.h}
{\xe \v pthread.h\:pthread_getschedparam}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_getschedparam ({\b pthread_t} {\i thread}, int * {\i policy}, struct sched_param * {\i param})}}
\par
{\bkmkstart AAAAAAABQQ}
{\bkmkend AAAAAAABQQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 26 of file pthread_sched.c.}\par
{
References errno, sched_getparam(), and pthread_context::tid.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 26                                                                                            \{\par
27     if(!thread) \{\par
28         errno = EINVAL;\par
29         return 1;\par
30     \}\par
31 \par
32     if(param == NULL) \{\par
33         errno = EINVAL;\par
34         return 1;\par
35     \}\par
36     \par
37     pthread_context_t* ctx = (pthread_context_t*) thread;\par
38     if((*policy = sched_getparam(ctx->tid, param)) != -1)\par
39         return 0;\par
40     \par
41     return 1;\par
42 \}\par
}
}
{\xe \v pthread_getspecific\:pthread.h}
{\xe \v pthread.h\:pthread_getspecific}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* pthread_getspecific ({\b pthread_key_t} {\i key})}}
\par
{\bkmkstart AAAAAAABQR}
{\bkmkend AAAAAAABQR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 65 of file pthread_key.c.}\par
{
References __pthread_keys, errno, PTHREAD_KEYS_MAX, and __pthread_key::value.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 65                                                     \{\par
66     if(key > PTHREAD_KEYS_MAX) \{\par
67         errno = EINVAL;\par
68         return 0;\par
69     \}\par
70 \par
71     if(__pthread_keys[key].used == 0) \{\par
72         errno = EINVAL;\par
73         return 0;\par
74     \}\par
75 \par
76     return __pthread_keys[key].value;\par
77 \}\par
}
}
{\xe \v pthread_join\:pthread.h}
{\xe \v pthread.h\:pthread_join}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_join ({\b pthread_t} {\i thread}, void ** {\i value_ptr})}}
\par
{\bkmkstart AAAAAAABQS}
{\bkmkend AAAAAAABQS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 8 of file pthread_join.c.}\par
{
References pthread_once::done, errno, pthread_context::exitval, pthread_context::once, and sched_yield().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 8                                                             \{\par
9     if(!thread) \{\par
10         errno = EINVAL;\par
11         return 1;\par
12     \}\par
13 \par
14     pthread_context_t* ctx = (pthread_context_t*) thread;\par
15     while(ctx->once.done == 0)\par
16         sched_yield();\par
17 \par
18     if(value_ptr)\par
19         *value_ptr = ctx->exitval;\par
20 \par
21     return 0;\par
22 \}\par
}
}
{\xe \v pthread_key_create\:pthread.h}
{\xe \v pthread.h\:pthread_key_create}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_key_create ({\b pthread_key_t} * {\i key}, void(*)(void *) {\i destructor})}}
\par
{\bkmkstart AAAAAAABQT}
{\bkmkend AAAAAAABQT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9 of file pthread_key.c.}\par
{
References __pthread_keys, __pthread_key::dtor, errno, PTHREAD_KEYS_MAX, __pthread_key::used, and __pthread_key::value.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 9                                                                               \{\par
10     if(!key) \{\par
11         errno = EINVAL;\par
12         return 1;\par
13     \}\par
14 \par
15     int i;\par
16     for(i = 0; i < PTHREAD_KEYS_MAX; i++) \{\par
17         if(__pthread_keys[i].used == 0) \{\par
18             __pthread_keys[i].used = 1;\par
19             __pthread_keys[i].dtor = destructor;\par
20             __pthread_keys[i].value = NULL;\par
21 \par
22             *key = i;\par
23             return 0;\par
24         \}\par
25     \}\par
26 \par
27     errno = EAGAIN;\par
28     return 1;\par
29 \}\par
}
}
{\xe \v pthread_key_delete\:pthread.h}
{\xe \v pthread.h\:pthread_key_delete}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_key_delete ({\b pthread_key_t} {\i key})}}
\par
{\bkmkstart AAAAAAABQU}
{\bkmkend AAAAAAABQU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 32 of file pthread_key.c.}\par
{
References __pthread_keys, __pthread_key::dtor, errno, PTHREAD_KEYS_MAX, __pthread_key::used, __pthread_key::value, and value.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 32                                                  \{\par
33     if(key > PTHREAD_KEYS_MAX) \{\par
34         errno = EINVAL;\par
35         return 1;\par
36     \}\par
37 \par
38     if(__pthread_keys[key].dtor)\par
39         __pthread_keys[key].dtor(__pthread_keys[key].value);\par
40 \par
41     __pthread_keys[key].used = 0;\par
42     __pthread_keys[key].dtor = 0;\par
43     __pthread_keys[key].value = NULL;\par
44     \par
45     return 0;\par
46 \}\par
}
}
{\xe \v pthread_mutex_destroy\:pthread.h}
{\xe \v pthread.h\:pthread_mutex_destroy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_mutex_destroy ({\b pthread_mutex_t} * {\i mutex})}}
\par
{\bkmkstart AAAAAAABQV}
{\bkmkend AAAAAAABQV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 46 of file pthread_mutex.c.}\par
{
References errno, pthread_mutex::event, pthread_mutex::kind, pthread_mutex::lock, pthread_mutex::owner, pthread_mutex::recursion, and pthread_mutex::time.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 46                                                          \{\par
47     if(!mutex) \{\par
48         errno = EINVAL;\par
49         return 1;\par
50     \}\par
51 \par
52     if(mutex->lock == 1) \{\par
53         errno = EBUSY;\par
54         return 1;\par
55     \}\par
56 \par
57     mutex->lock = 0;\par
58     mutex->recursion = 0;\par
59     mutex->kind = 0;\par
60     mutex->owner = 0;\par
61     mutex->event = 0;\par
62     mutex->time = 0;\par
63 \par
64     return 0;\par
65 \}\par
}
}
{\xe \v pthread_mutex_init\:pthread.h}
{\xe \v pthread.h\:pthread_mutex_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_mutex_init ({\b pthread_mutex_t} * {\i mutex}, const {\b pthread_mutexattr_t} * {\i attr})}}
\par
{\bkmkstart AAAAAAABQW}
{\bkmkend AAAAAAABQW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 26 of file pthread_mutex.c.}\par
{
References errno, pthread_mutex::event, pthread_mutexattr::kind, pthread_mutex::kind, pthread_mutex::lock, pthread_mutex::owner, PTHREAD_MUTEX_DEFAULT, pthread_mutex::recursion, and pthread_mutex::time.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 26                                                                                        \{\par
27     if(!mutex) \{\par
28         errno = EINVAL;\par
29         return 1;\par
30     \}\par
31 \par
32     mutex->lock = 0;\par
33     mutex->recursion = 0;\par
34     mutex->kind = PTHREAD_MUTEX_DEFAULT;\par
35     mutex->owner = 0;\par
36     mutex->event = 0;\par
37     mutex->time = 0;\par
38 \par
39     if(attr)\par
40         mutex->kind = attr->kind;\par
41 \par
42     return 0;\par
43 \}\par
}
}
{\xe \v pthread_mutex_lock\:pthread.h}
{\xe \v pthread.h\:pthread_mutex_lock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_mutex_lock ({\b pthread_mutex_t} * {\i mutex})}}
\par
{\bkmkstart AAAAAAABQX}
{\bkmkend AAAAAAABQX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 67 of file pthread_mutex.c.}\par
{
References __locked_mtx(), errno, pthread_mutex::kind, pthread_mutex::lock, pthread_mutex::owner, PTHREAD_MUTEX_ERRORCHECK, PTHREAD_MUTEX_RECURSIVE, pthread_self(), pthread_mutex::recursion, and sched_yield().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 67                                                       \{\par
68     if(!mutex) \{\par
69         errno = EINVAL;\par
70         return 1;\par
71     \}\par
72 \par
73     if(mutex->owner != pthread_self()) \{\par
74         while(__locked_mtx(mutex))\par
75             sched_yield();\par
76         \par
77         mutex->owner = pthread_self();\par
78         mutex->recursion = 0;\par
79         mutex->lock = 1;\par
80     \} else if(mutex->kind == PTHREAD_MUTEX_ERRORCHECK) \{\par
81         errno = EDEADLK;\par
82         return 1;\par
83     \}\par
84 \par
85     if(mutex->kind == PTHREAD_MUTEX_RECURSIVE)\par
86         mutex->recursion += 1;\par
87 \par
88     return 0;\par
89 \}\par
}
}
{\xe \v pthread_mutex_timedlock\:pthread.h}
{\xe \v pthread.h\:pthread_mutex_timedlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_mutex_timedlock ({\b pthread_mutex_t} * {\i mutex}, const struct timespec * {\i abstime})}}
\par
{\bkmkstart AAAAAAABQY}
{\bkmkend AAAAAAABQY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 92 of file pthread_mutex.c.}\par
{
References errno, pthread_mutex_lock(), and pthread_mutex::time.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 92                                                                                            \{\par
93     if(abstime == NULL) \{\par
94         errno = EINVAL;\par
95         return 1;\par
96     \}\par
97 \par
98     if(pthread_mutex_lock(mutex) == 0)\par
99         mutex->time = time(NULL) + abstime->tv_sec;\par
100     else\par
101         return 1;\par
102 \par
103     return 0;\par
104 \}\par
}
}
{\xe \v pthread_mutex_trylock\:pthread.h}
{\xe \v pthread.h\:pthread_mutex_trylock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_mutex_trylock ({\b pthread_mutex_t} * {\i mutex})}}
\par
{\bkmkstart AAAAAAABQZ}
{\bkmkend AAAAAAABQZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 107 of file pthread_mutex.c.}\par
{
References __locked_mtx(), errno, pthread_mutex::kind, pthread_mutex::lock, pthread_mutex::owner, PTHREAD_MUTEX_ERRORCHECK, PTHREAD_MUTEX_RECURSIVE, pthread_self(), and pthread_mutex::recursion.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 107                                                          \{\par
108     if(!mutex) \{\par
109         errno = EINVAL;\par
110         return 1;\par
111     \}\par
112 \par
113     if(mutex->owner != pthread_self()) \{\par
114         if(__locked_mtx(mutex)) \{\par
115             errno = EBUSY;\par
116             return 1;\par
117         \}\par
118 \par
119         mutex->owner = pthread_self();\par
120         mutex->recursion = 0;\par
121         mutex->lock = 1;\par
122     \} else if(mutex->kind == PTHREAD_MUTEX_ERRORCHECK) \{\par
123         errno = EDEADLK;\par
124         return 1;\par
125     \}\par
126 \par
127     if(mutex->kind == PTHREAD_MUTEX_RECURSIVE)\par
128         mutex->recursion += 1;\par
129 \par
130     return 0;\par
131 \}\par
}
}
{\xe \v pthread_mutex_unlock\:pthread.h}
{\xe \v pthread.h\:pthread_mutex_unlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_mutex_unlock ({\b pthread_mutex_t} * {\i mutex})}}
\par
{\bkmkstart AAAAAAABRA}
{\bkmkend AAAAAAABRA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 133 of file pthread_mutex.c.}\par
{
References errno, pthread_mutex::kind, pthread_mutex::lock, pthread_mutex::owner, PTHREAD_MUTEX_ERRORCHECK, PTHREAD_MUTEX_RECURSIVE, pthread_self(), and pthread_mutex::recursion.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 133                                                         \{\par
134     if(!mutex) \{\par
135         errno = EINVAL;\par
136         return 1;\par
137     \}\par
138 \par
139     if(mutex->owner == pthread_self()) \{\par
140         if(mutex->kind == PTHREAD_MUTEX_RECURSIVE) \{\par
141             if(--(mutex->recursion))\par
142                 return 0;\par
143         \}\par
144 \par
145         mutex->owner = 0;\par
146         mutex->lock = 0;\par
147     \} else if(mutex->kind == PTHREAD_MUTEX_ERRORCHECK) \{\par
148         errno = EPERM;\par
149         return 1;\par
150     \}\par
151 \par
152     return 0;\par
153 \}\par
}
}
{\xe \v pthread_mutexattr_destroy\:pthread.h}
{\xe \v pthread.h\:pthread_mutexattr_destroy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_mutexattr_destroy ({\b pthread_mutexattr_t} * {\i attr})}}
\par
{\bkmkstart AAAAAAABRB}
{\bkmkend AAAAAAABRB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 20 of file pthread_mutexattr.c.}\par
{
References errno, pthread_mutexattr::kind, and pthread_mutexattr::pshared.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20                                                                 \{\par
21     if(!attr) \{\par
22         errno = EINVAL;\par
23         return 1;\par
24     \}\par
25 \par
26     attr->pshared = 0;\par
27     attr->kind = 0;\par
28     \par
29     return 0;\par
30 \}\par
}
}
{\xe \v pthread_mutexattr_getpshared\:pthread.h}
{\xe \v pthread.h\:pthread_mutexattr_getpshared}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_mutexattr_getpshared (const {\b pthread_mutexattr_t} * {\i attr}, int * {\i pshared})}}
\par
{\bkmkstart AAAAAAABRC}
{\bkmkend AAAAAAABRC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 32 of file pthread_mutexattr.c.}\par
{
References errno, and pthread_mutexattr::pshared.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 32                                                                                        \{\par
33     if(!attr) \{\par
34         errno = EINVAL;\par
35         return 1;\par
36     \}\par
37 \par
38     *pshared = attr->pshared;\par
39     return 0;\par
40 \}\par
}
}
{\xe \v pthread_mutexattr_gettype\:pthread.h}
{\xe \v pthread.h\:pthread_mutexattr_gettype}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_mutexattr_gettype ({\b pthread_mutexattr_t} * {\i attr}, int * {\i kind})}}
\par
{\bkmkstart AAAAAAABRD}
{\bkmkend AAAAAAABRD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 52 of file pthread_mutexattr.c.}\par
{
References errno, and pthread_mutexattr::kind.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 52                                                                            \{\par
53     if(!attr) \{\par
54         errno = EINVAL;\par
55         return 1;\par
56     \}\par
57 \par
58     *kind = attr->kind;\par
59     return 0;\par
60 \}\par
}
}
{\xe \v pthread_mutexattr_init\:pthread.h}
{\xe \v pthread.h\:pthread_mutexattr_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_mutexattr_init ({\b pthread_mutexattr_t} * {\i attr})}}
\par
{\bkmkstart AAAAAAABRE}
{\bkmkend AAAAAAABRE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 8 of file pthread_mutexattr.c.}\par
{
References errno, pthread_mutexattr::kind, pthread_mutexattr::pshared, and PTHREAD_MUTEX_DEFAULT.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 8                                                              \{\par
9     if(!attr) \{\par
10         errno = EINVAL;\par
11         return 1;\par
12     \}\par
13 \par
14     attr->pshared = 0;\par
15     attr->kind = PTHREAD_MUTEX_DEFAULT;\par
16     \par
17     return 0;\par
18 \}\par
}
}
{\xe \v pthread_mutexattr_setpshared\:pthread.h}
{\xe \v pthread.h\:pthread_mutexattr_setpshared}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_mutexattr_setpshared ({\b pthread_mutexattr_t} * {\i attr}, int {\i pshared})}}
\par
{\bkmkstart AAAAAAABRF}
{\bkmkend AAAAAAABRF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 42 of file pthread_mutexattr.c.}\par
{
References errno, and pthread_mutexattr::pshared.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 42                                                                                 \{\par
43     if(!attr) \{\par
44         errno = EINVAL;\par
45         return 1;\par
46     \}\par
47 \par
48     attr->pshared = pshared;\par
49     return 0;\par
50 \}\par
}
}
{\xe \v pthread_mutexattr_settype\:pthread.h}
{\xe \v pthread.h\:pthread_mutexattr_settype}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_mutexattr_settype ({\b pthread_mutexattr_t} * {\i attr}, int {\i kind})}}
\par
{\bkmkstart AAAAAAABRG}
{\bkmkend AAAAAAABRG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 62 of file pthread_mutexattr.c.}\par
{
References errno, and pthread_mutexattr::kind.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 62                                                                           \{\par
63     if(!attr) \{\par
64         errno = EINVAL;\par
65         return 1;\par
66     \}\par
67 \par
68     attr->kind = kind;\par
69     return 0;\par
70 \}\par
}
}
{\xe \v pthread_once\:pthread.h}
{\xe \v pthread.h\:pthread_once}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int {\b pthread_once} ({\b pthread_once_t} * {\i once_control}, void(*)(void) {\i init_routine})}}
\par
{\bkmkstart AAAAAAABRH}
{\bkmkend AAAAAAABRH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 7 of file pthread_once.c.}\par
{
References errno.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7                                                                                   \{\par
8     errno = ENOSYS;\par
9     return 1;\par
10 \}\par
}
}
{\xe \v pthread_rwlock_destroy\:pthread.h}
{\xe \v pthread.h\:pthread_rwlock_destroy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_rwlock_destroy ({\b pthread_rwlock_t} * {\i lock})}}
\par
{\bkmkstart AAAAAAABRI}
{\bkmkend AAAAAAABRI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 34 of file pthread_rwlock.c.}\par
{
References errno, pthread_rwlock::exclusive_waiters, pthread_rwlock::num_exclusive_waiters, pthread_rwlock::num_shared_waiters, pthread_rwlock::owner, pthread_mutex_destroy(), pthread_self(), pthread_rwlock::rdmutex, pthread_rwlock::shared_waiters, and pthread_rwlock::wrmutex.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 34                                                           \{\par
35     if(lock == NULL) \{\par
36         errno = EINVAL;\par
37         return 1;\par
38     \}\par
39 \par
40     pthread_t thread = pthread_self();\par
41     if(!thread) \{\par
42         errno = EFAULT;\par
43         return 1;\par
44     \}\par
45 \par
46     if(thread != lock->owner) \{\par
47         errno = EPERM;\par
48         return 1;\par
49     \}\par
50 \par
51     pthread_mutex_destroy(&lock->rdmutex);\par
52     pthread_mutex_destroy(&lock->wrmutex);\par
53 \par
54     lock->shared_waiters = (handle_t) 0;\par
55     lock->exclusive_waiters = (handle_t) 0;\par
56     lock->num_shared_waiters = 0;\par
57     lock->num_exclusive_waiters = 0;\par
58     lock->owner = 0;\par
59     \par
60     return 0;\par
61 \}\par
}
}
{\xe \v pthread_rwlock_init\:pthread.h}
{\xe \v pthread.h\:pthread_rwlock_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_rwlock_init ({\b pthread_rwlock_t} * {\i lock}, const {\b pthread_rwlockattr_t} * {\i attr})}}
\par
{\bkmkstart AAAAAAABRJ}
{\bkmkend AAAAAAABRJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 10 of file pthread_rwlock.c.}\par
{
References errno, pthread_rwlock::exclusive_waiters, pthread_rwlock::num_exclusive_waiters, pthread_rwlock::num_shared_waiters, pthread_rwlock::owner, pthread_mutex_init(), pthread_self(), pthread_rwlock::rdmutex, pthread_rwlock::shared_waiters, and pthread_rwlock::wrmutex.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10                                                                                          \{\par
11     if(lock == NULL) \{\par
12         errno = EINVAL;\par
13         return 1;\par
14     \}\par
15 \par
16     pthread_t thread = pthread_self();\par
17     if(!thread) \{\par
18         errno = EFAULT;\par
19         return 1;\par
20     \}\par
21 \par
22     pthread_mutex_init(&lock->rdmutex, NULL);\par
23     pthread_mutex_init(&lock->wrmutex, NULL);\par
24 \par
25     lock->shared_waiters = (handle_t) 0;\par
26     lock->exclusive_waiters = (handle_t) 0;\par
27     lock->num_shared_waiters = 0;\par
28     lock->num_exclusive_waiters = 0;\par
29     lock->owner = thread;\par
30 \par
31     return 0;\par
32 \}\par
}
}
{\xe \v pthread_rwlock_rdlock\:pthread.h}
{\xe \v pthread.h\:pthread_rwlock_rdlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_rwlock_rdlock ({\b pthread_rwlock_t} * {\i lock})}}
\par
{\bkmkstart AAAAAAABRK}
{\bkmkend AAAAAAABRK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 81 of file pthread_rwlock.c.}\par
{
References errno, pthread_mutex_lock(), and pthread_rwlock::rdmutex.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 81                                                          \{\par
82     if(lock == NULL) \{\par
83         errno = EINVAL;\par
84         return 1;\par
85     \}\par
86 \par
87     return pthread_mutex_lock(&lock->rdmutex);\par
88 \}\par
}
}
{\xe \v pthread_rwlock_timedrdlock\:pthread.h}
{\xe \v pthread.h\:pthread_rwlock_timedrdlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_rwlock_timedrdlock ({\b pthread_rwlock_t} * {\i lock}, const struct timespec * {\i abstime})}}
\par
{\bkmkstart AAAAAAABRL}
{\bkmkend AAAAAAABRL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 90 of file pthread_rwlock.c.}\par
{
References errno, pthread_mutex_timedlock(), and pthread_rwlock::rdmutex.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 90                                                                                               \{\par
91     if(lock == NULL) \{\par
92         errno = EINVAL;\par
93         return 1;\par
94     \}\par
95 \par
96     return pthread_mutex_timedlock(&lock->rdmutex, abstime);\par
97 \}\par
}
}
{\xe \v pthread_rwlock_timedwrlock\:pthread.h}
{\xe \v pthread.h\:pthread_rwlock_timedwrlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_rwlock_timedwrlock ({\b pthread_rwlock_t} * {\i lock}, const struct timespec * {\i abstime})}}
\par
{\bkmkstart AAAAAAABRM}
{\bkmkend AAAAAAABRM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 108 of file pthread_rwlock.c.}\par
{
References errno, pthread_mutex_timedlock(), and pthread_rwlock::wrmutex.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 108                                                                                               \{\par
109     if(lock == NULL) \{\par
110         errno = EINVAL;\par
111         return 1;\par
112     \}\par
113 \par
114     return pthread_mutex_timedlock(&lock->wrmutex, abstime);\par
115 \}\par
}
}
{\xe \v pthread_rwlock_tryrdlock\:pthread.h}
{\xe \v pthread.h\:pthread_rwlock_tryrdlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_rwlock_tryrdlock ({\b pthread_rwlock_t} * {\i lock})}}
\par
{\bkmkstart AAAAAAABRN}
{\bkmkend AAAAAAABRN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 63 of file pthread_rwlock.c.}\par
{
References errno, pthread_mutex_trylock(), and pthread_rwlock::rdmutex.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 63                                                             \{\par
64     if(lock == NULL) \{\par
65         errno = EINVAL;\par
66         return 1;\par
67     \}\par
68 \par
69     return pthread_mutex_trylock(&lock->rdmutex);\par
70 \}\par
}
}
{\xe \v pthread_rwlock_trywrlock\:pthread.h}
{\xe \v pthread.h\:pthread_rwlock_trywrlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_rwlock_trywrlock ({\b pthread_rwlock_t} * {\i lock})}}
\par
{\bkmkstart AAAAAAABRO}
{\bkmkend AAAAAAABRO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 72 of file pthread_rwlock.c.}\par
{
References errno, pthread_mutex_trylock(), and pthread_rwlock::wrmutex.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 72                                                             \{\par
73     if(lock == NULL) \{\par
74         errno = EINVAL;\par
75         return 1;\par
76     \}\par
77 \par
78     return pthread_mutex_trylock(&lock->wrmutex);\par
79 \}\par
}
}
{\xe \v pthread_rwlock_unlock\:pthread.h}
{\xe \v pthread.h\:pthread_rwlock_unlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_rwlock_unlock ({\b pthread_rwlock_t} * {\i lock})}}
\par
{\bkmkstart AAAAAAABRP}
{\bkmkend AAAAAAABRP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 117 of file pthread_rwlock.c.}\par
{
References errno, pthread_mutex_unlock(), pthread_rwlock::rdmutex, and pthread_rwlock::wrmutex.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 117                                                          \{\par
118     if(lock == NULL) \{\par
119         errno = EINVAL;\par
120         return 1;\par
121     \}\par
122 \par
123     if(pthread_mutex_unlock(&lock->rdmutex) != 0)\par
124         return 1;\par
125 \par
126     if(pthread_mutex_unlock(&lock->wrmutex) != 0)\par
127         return 1;\par
128 \par
129     return 0;\par
130 \}\par
}
}
{\xe \v pthread_rwlock_wrlock\:pthread.h}
{\xe \v pthread.h\:pthread_rwlock_wrlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_rwlock_wrlock ({\b pthread_rwlock_t} * {\i lock})}}
\par
{\bkmkstart AAAAAAABRQ}
{\bkmkend AAAAAAABRQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 99 of file pthread_rwlock.c.}\par
{
References errno, pthread_mutex_lock(), and pthread_rwlock::wrmutex.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 99                                                          \{\par
100     if(lock == NULL) \{\par
101         errno = EINVAL;\par
102         return 1;\par
103     \}\par
104 \par
105     return pthread_mutex_lock(&lock->wrmutex);\par
106 \}\par
}
}
{\xe \v pthread_rwlockattr_destroy\:pthread.h}
{\xe \v pthread.h\:pthread_rwlockattr_destroy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_rwlockattr_destroy ({\b pthread_rwlockattr_t} * {\i attr})}}
\par
{\bkmkstart AAAAAAABRR}
{\bkmkend AAAAAAABRR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 19 of file pthread_rwlockattr.c.}\par
{
References errno, and pthread_rwlockattr::pshared.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19                                                                   \{\par
20     if(attr == NULL) \{\par
21         errno = EINVAL;\par
22         return 1;\par
23     \}\par
24 \par
25     attr->pshared = 0;\par
26     return 0;\par
27 \}\par
}
}
{\xe \v pthread_rwlockattr_getpshared\:pthread.h}
{\xe \v pthread.h\:pthread_rwlockattr_getpshared}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_rwlockattr_getpshared (const {\b pthread_rwlockattr_t} * {\i attr}, int * {\i pshared})}}
\par
{\bkmkstart AAAAAAABRS}
{\bkmkend AAAAAAABRS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 29 of file pthread_rwlockattr.c.}\par
{
References errno, and pthread_rwlockattr::pshared.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 29                                                                                          \{\par
30     if(attr == NULL) \{\par
31         errno = EINVAL;\par
32         return 1;\par
33     \}\par
34 \par
35     if(pshared == NULL) \{\par
36         errno = EINVAL;\par
37         return 1;\par
38     \}\par
39 \par
40     *pshared = attr->pshared;\par
41     return 0;\par
42 \}\par
}
}
{\xe \v pthread_rwlockattr_init\:pthread.h}
{\xe \v pthread.h\:pthread_rwlockattr_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_rwlockattr_init ({\b pthread_rwlockattr_t} * {\i attr})}}
\par
{\bkmkstart AAAAAAABRT}
{\bkmkend AAAAAAABRT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9 of file pthread_rwlockattr.c.}\par
{
References errno, and pthread_rwlockattr::pshared.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 9                                                                \{\par
10     if(attr == NULL) \{\par
11         errno = EINVAL;\par
12         return 1;\par
13     \}\par
14 \par
15     attr->pshared = 0;\par
16     return 0;\par
17 \}\par
}
}
{\xe \v pthread_rwlockattr_setpshared\:pthread.h}
{\xe \v pthread.h\:pthread_rwlockattr_setpshared}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_rwlockattr_setpshared ({\b pthread_rwlockattr_t} * {\i attr}, int {\i pshared})}}
\par
{\bkmkstart AAAAAAABRU}
{\bkmkend AAAAAAABRU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 44 of file pthread_rwlockattr.c.}\par
{
References errno, and pthread_rwlockattr::pshared.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 44                                                                                   \{\par
45     if(attr == NULL) \{\par
46         errno = EINVAL;\par
47         return 1;\par
48     \}\par
49 \par
50     attr->pshared = pshared;\par
51     return 0;\par
52 \}\par
}
}
{\xe \v pthread_self\:pthread.h}
{\xe \v pthread.h\:pthread_self}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b pthread_t} pthread_self (void )}}
\par
{\bkmkstart AAAAAAABRV}
{\bkmkend AAAAAAABRV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 10 of file pthread_self.c.}\par
{
References __os_gettid, __pthread_queue, errno, pthread_context::next, and pthread_context::tid.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10                                     \{\par
11     if(!__pthread_queue) \{\par
12         errno = ESRCH;\par
13         return 0;\par
14     \}\par
15 \par
16     int tid = __os_gettid();\par
17     pthread_context_t* tmp = __pthread_queue;\par
18     while(tmp) \{\par
19         if(tmp->tid == tid)\par
20             return (pthread_t) tmp;\par
21 \par
22         tmp = tmp->next;\par
23     \}\par
24 \par
25     errno = ESRCH;\par
26     return 0;\par
27 \}\par
}
}
{\xe \v pthread_setcancelstate\:pthread.h}
{\xe \v pthread.h\:pthread_setcancelstate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_setcancelstate (int {\i state}, int * {\i oldstate})}}
\par
{\bkmkstart AAAAAAABRW}
{\bkmkend AAAAAAABRW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 12 of file pthread_cancel.c.}\par
{
References errno.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12                                                             \{\par
13     errno = ENOSYS;\par
14     return 1;\par
15 \}\par
}
}
{\xe \v pthread_setcanceltype\:pthread.h}
{\xe \v pthread.h\:pthread_setcanceltype}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_setcanceltype (int {\i type}, int * {\i oldtype})}}
\par
{\bkmkstart AAAAAAABRX}
{\bkmkend AAAAAAABRX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 18 of file pthread_cancel.c.}\par
{
References errno.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18                                                          \{\par
19     errno = ENOSYS;\par
20     return 1;\par
21 \}\par
}
}
{\xe \v pthread_setconcurrency\:pthread.h}
{\xe \v pthread.h\:pthread_setconcurrency}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_setconcurrency (int {\i level})}}
\par
{\bkmkstart AAAAAAABRY}
{\bkmkend AAAAAAABRY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 44 of file pthread_sched.c.}\par
{
References pthread_context::attr, errno, pthread_attr::param, and pthread_self().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 44                                              \{\par
45     pthread_t thread = pthread_self();\par
46     if(!thread) \{\par
47         errno = ESRCH;\par
48         return 1;\par
49     \}\par
50 \par
51     pthread_context_t* ctx = (pthread_context_t*) thread;\par
52     ctx->attr.param.sched_priority = level;\par
53 \par
54     return 0;\par
55 \}\par
}
}
{\xe \v pthread_setschedparam\:pthread.h}
{\xe \v pthread.h\:pthread_setschedparam}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_setschedparam ({\b pthread_t} {\i thread}, int {\i policy}, const struct sched_param * {\i param})}}
\par
{\bkmkstart AAAAAAABRZ}
{\bkmkend AAAAAAABRZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 11 of file pthread_sched.c.}\par
{
References errno, sched_setparam(), and pthread_context::tid.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11                                                                                                 \{\par
12     if(!thread) \{\par
13         errno = EINVAL;\par
14         return 1;\par
15     \}\par
16 \par
17     if(param == NULL) \{\par
18         errno = EINVAL;\par
19         return 1;\par
20     \}\par
21 \par
22     pthread_context_t* ctx = (pthread_context_t*) thread;\par
23     return sched_setparam(ctx->tid, param);\par
24 \}\par
}
}
{\xe \v pthread_setspecific\:pthread.h}
{\xe \v pthread.h\:pthread_setspecific}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_setspecific ({\b pthread_key_t} {\i key}, const void * {\i value})}}
\par
{\bkmkstart AAAAAAABSA}
{\bkmkend AAAAAAABSA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 49 of file pthread_key.c.}\par
{
References __pthread_keys, errno, PTHREAD_KEYS_MAX, and __pthread_key::value.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 49                                                                      \{\par
50     if(key > PTHREAD_KEYS_MAX) \{\par
51         errno = EINVAL;\par
52         return 1;\par
53     \}\par
54 \par
55     if(__pthread_keys[key].used == 0) \{\par
56         errno = EINVAL;\par
57         return 1;\par
58     \}\par
59 \par
60     __pthread_keys[key].value = (void*) value;\par
61     return 0;\par
62 \}\par
}
}
{\xe \v pthread_spin_destroy\:pthread.h}
{\xe \v pthread.h\:pthread_spin_destroy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_spin_destroy ({\b pthread_spinlock_t} * {\i lock})}}
\par
{\bkmkstart AAAAAAABSB}
{\bkmkend AAAAAAABSB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 19 of file pthread_spin.c.}\par
{
References errno, pthread_spinlock::interlock, pthread_spinlock::mutex, and pthread_mutex_destroy().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19                                                           \{\par
20     if(!lock) \{\par
21         errno = EINVAL;\par
22         return 1;\par
23     \}\par
24 \par
25     lock->interlock = 0;\par
26     pthread_mutex_destroy(&lock->mutex);\par
27 \par
28     return 0;\par
29 \}\par
}
}
{\xe \v pthread_spin_init\:pthread.h}
{\xe \v pthread.h\:pthread_spin_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_spin_init ({\b pthread_spinlock_t} * {\i lock}, int {\i pshared})}}
\par
{\bkmkstart AAAAAAABSC}
{\bkmkend AAAAAAABSC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 7 of file pthread_spin.c.}\par
{
References errno, pthread_spinlock::interlock, pthread_spinlock::mutex, and pthread_mutex_init().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7                                                                     \{\par
8     if(!lock) \{\par
9         errno = EINVAL;\par
10         return 1;\par
11     \}\par
12 \par
13     lock->interlock = 0;\par
14     pthread_mutex_init(&lock->mutex, NULL);\par
15 \par
16     return 0;\par
17 \}\par
}
}
{\xe \v pthread_spin_lock\:pthread.h}
{\xe \v pthread.h\:pthread_spin_lock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_spin_lock ({\b pthread_spinlock_t} * {\i lock})}}
\par
{\bkmkstart AAAAAAABSD}
{\bkmkend AAAAAAABSD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 31 of file pthread_spin.c.}\par
{
References errno, pthread_spinlock::interlock, pthread_spinlock::mutex, and pthread_mutex_lock().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 31                                                        \{\par
32     if(!lock) \{\par
33         errno = EINVAL;\par
34         return 1;\par
35     \}\par
36 \par
37     if(pthread_mutex_lock(&lock->mutex) == 0)\par
38         lock->interlock = 1;\par
39     else\par
40         return 1; /* errno already setted */\par
41 \par
42     return 0;\par
43 \}\par
}
}
{\xe \v pthread_spin_trylock\:pthread.h}
{\xe \v pthread.h\:pthread_spin_trylock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_spin_trylock ({\b pthread_spinlock_t} * {\i lock})}}
\par
{\bkmkstart AAAAAAABSE}
{\bkmkend AAAAAAABSE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 45 of file pthread_spin.c.}\par
{
References errno, pthread_spinlock::interlock, pthread_spinlock::mutex, and pthread_mutex_trylock().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 45                                                           \{\par
46     if(!lock) \{\par
47         errno = EINVAL;\par
48         return 1;\par
49     \}\par
50 \par
51     if(pthread_mutex_trylock(&lock->mutex) == 0)\par
52         lock->interlock = 1;\par
53     else\par
54         return 1; /* errno already setted */\par
55 \par
56     return 0;\par
57 \}\par
}
}
{\xe \v pthread_spin_unlock\:pthread.h}
{\xe \v pthread.h\:pthread_spin_unlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pthread_spin_unlock ({\b pthread_spinlock_t} * {\i lock})}}
\par
{\bkmkstart AAAAAAABSF}
{\bkmkend AAAAAAABSF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 59 of file pthread_spin.c.}\par
{
References errno, pthread_spinlock::interlock, pthread_spinlock::mutex, and pthread_mutex_unlock().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 59                                                          \{\par
60     if(!lock) \{\par
61         errno = EINVAL;\par
62         return 1;\par
63     \}\par
64 \par
65     if(pthread_mutex_unlock(&lock->mutex) == 0)\par
66         lock->interlock = 0;\par
67     else\par
68         return 1; /* errno already setted */\par
69     \par
70     return 0;\par
71 \}\par
}
}
{\xe \v pthread_testcancel\:pthread.h}
{\xe \v pthread.h\:pthread_testcancel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void pthread_testcancel (void )}}
\par
{\bkmkstart AAAAAAABSG}
{\bkmkend AAAAAAABSG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 23 of file pthread_cancel.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 23                                      \{\par
24     /* Boh ?? */\par
25 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
usr/src/libpthread/src/platform/posix/hooks.h File Reference\par \pard\plain 
{\tc\tcl2 \v usr/src/libpthread/src/platform/posix/hooks.h}
{\xe \v usr/src/libpthread/src/platform/posix/hooks.h}
{\bkmkstart AAAAAAABSH}
{\bkmkend AAAAAAABSH}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <sched.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _GNU_SOURCE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CLONE_VM}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b __os_thread_create}(e, a, p)\~ {\b clone}((int(*)(void*)) e, NULL, {\b CLONE_VM}, a)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b __os_thread_kill}(t, s)\~ {\b kill}(t, s)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b __os_gettid}()\~ {\b getpid}()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b clone} (int(*fn)(void *), void *, int, void *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b kill} (int, int)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b getpid} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v __os_gettid\:posix/hooks.h}
{\xe \v posix/hooks.h\:__os_gettid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define __os_gettid()\~ {\b getpid}()}}
\par
{\bkmkstart AAAAAAABSI}
{\bkmkend AAAAAAABSI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 18 of file hooks.h.}\par
}
{\xe \v __os_thread_create\:posix/hooks.h}
{\xe \v posix/hooks.h\:__os_thread_create}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define __os_thread_create( e,  a,  p)\~ {\b clone}((int(*)(void*)) e, NULL, {\b CLONE_VM}, a)}}
\par
{\bkmkstart AAAAAAABSJ}
{\bkmkend AAAAAAABSJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 16 of file hooks.h.}\par
}
{\xe \v __os_thread_kill\:posix/hooks.h}
{\xe \v posix/hooks.h\:__os_thread_kill}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define __os_thread_kill( t,  s)\~ {\b kill}(t, s)}}
\par
{\bkmkstart AAAAAAABSK}
{\bkmkend AAAAAAABSK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 17 of file hooks.h.}\par
}
{\xe \v _GNU_SOURCE\:posix/hooks.h}
{\xe \v posix/hooks.h\:_GNU_SOURCE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _GNU_SOURCE}}
\par
{\bkmkstart AAAAAAABSL}
{\bkmkend AAAAAAABSL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 4 of file hooks.h.}\par
}
{\xe \v CLONE_VM\:posix/hooks.h}
{\xe \v posix/hooks.h\:CLONE_VM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CLONE_VM\~ 0}}
\par
{\bkmkstart AAAAAAABSM}
{\bkmkend AAAAAAABSM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 12 of file hooks.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v clone\:posix/hooks.h}
{\xe \v posix/hooks.h\:clone}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int clone (int(*)(void *) {\i fn}, void * , int , void * )}}
\par
{\bkmkstart AAAAAAABSN}
{\bkmkend AAAAAAABSN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v getpid\:posix/hooks.h}
{\xe \v posix/hooks.h\:getpid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int getpid ()}}
\par
{\bkmkstart AAAAAAABSO}
{\bkmkend AAAAAAABSO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v kill\:posix/hooks.h}
{\xe \v posix/hooks.h\:kill}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int kill (int , int )}}
\par
{\bkmkstart AAAAAAABSP}
{\bkmkend AAAAAAABSP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
usr/src/libpthread/src/platform/win32/hooks.h File Reference\par \pard\plain 
{\tc\tcl2 \v usr/src/libpthread/src/platform/win32/hooks.h}
{\xe \v usr/src/libpthread/src/platform/win32/hooks.h}
{\bkmkstart AAAAAAABSQ}
{\bkmkend AAAAAAABSQ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <windows.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b __os_thread_create}(e, a, p)\~ ((int) CreateThread(0, 0, e, a, 0))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b __os_thread_kill}(t, s)\~ TerminateThread(t, s)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b __os_gettid}()\~ GetCurrentThreadId()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v __os_gettid\:win32/hooks.h}
{\xe \v win32/hooks.h\:__os_gettid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define __os_gettid()\~ GetCurrentThreadId()}}
\par
{\bkmkstart AAAAAAABSR}
{\bkmkend AAAAAAABSR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 11 of file hooks.h.}\par
}
{\xe \v __os_thread_create\:win32/hooks.h}
{\xe \v win32/hooks.h\:__os_thread_create}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define __os_thread_create( e,  a,  p)\~ ((int) CreateThread(0, 0, e, a, 0))}}
\par
{\bkmkstart AAAAAAABSS}
{\bkmkend AAAAAAABSS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9 of file hooks.h.}\par
}
{\xe \v __os_thread_kill\:win32/hooks.h}
{\xe \v win32/hooks.h\:__os_thread_kill}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define __os_thread_kill( t,  s)\~ TerminateThread(t, s)}}
\par
{\bkmkstart AAAAAAABST}
{\bkmkend AAAAAAABST}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 10 of file hooks.h.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
usr/src/libpthread/src/pthread_attr.c File Reference\par \pard\plain 
{\tc\tcl2 \v usr/src/libpthread/src/pthread_attr.c}
{\xe \v usr/src/libpthread/src/pthread_attr.c}
{\bkmkstart AAAAAAABSU}
{\bkmkend AAAAAAABSU}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <pthread.h>}\par
{\f2 #include "pthread_internal.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b STACK_DEFAULT_SIZE}\~ {\b PTHREAD_STACK_MIN}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_attr_init} ({\b pthread_attr_t} *attr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_attr_destroy} ({\b pthread_attr_t} *attr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_attr_getdetachstate} (const {\b pthread_attr_t} *attr, int *detachstate)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_attr_setdetachstate} ({\b pthread_attr_t} *attr, int detachstate)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_attr_getstackaddr} (const {\b pthread_attr_t} *attr, void **stackaddr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_attr_setstackaddr} ({\b pthread_attr_t} *attr, void *stackaddr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_attr_getstacksize} (const {\b pthread_attr_t} *attr, size_t *stacksize)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_attr_setstacksize} ({\b pthread_attr_t} *attr, size_t stacksize)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_attr_getschedparam} (const {\b pthread_attr_t} *attr, struct sched_param *param)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_attr_setschedparam} ({\b pthread_attr_t} *attr, const struct sched_param *param)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_attr_getschedpolicy} ({\b pthread_attr_t} *attr, int *policy)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_attr_setschedpolicy} ({\b pthread_attr_t} *attr, int policy)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_attr_getinheritsched} ({\b pthread_attr_t} *attr, int *inheritsched)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_attr_setinheritsched} ({\b pthread_attr_t} *attr, int inheritsched)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_attr_getscope} (const {\b pthread_attr_t} *attr, int *contentionscope)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_attr_setscope} ({\b pthread_attr_t} *attr, int contentionscope)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v STACK_DEFAULT_SIZE\:pthread_attr.c}
{\xe \v pthread_attr.c\:STACK_DEFAULT_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define STACK_DEFAULT_SIZE\~ {\b PTHREAD_STACK_MIN}}}
\par
{\bkmkstart AAAAAAABSV}
{\bkmkend AAAAAAABSV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 10 of file pthread_attr.c.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v pthread_attr_destroy\:pthread_attr.c}
{\xe \v pthread_attr.c\:pthread_attr_destroy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_attr_destroy ({\b pthread_attr_t} * {\i attr})}}
\par
{\bkmkstart AAAAAAABSW}
{\bkmkend AAAAAAABSW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 28 of file pthread_attr.c.}\par
{
References errno.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28                                                       \{\par
29     if(!attr) \{\par
30         errno = EINVAL;\par
31         return 1;\par
32     \}\par
33 \par
34     memset(attr, 0, sizeof(pthread_attr_t));\par
35     return 0;\par
36 \}\par
}
}
{\xe \v pthread_attr_getdetachstate\:pthread_attr.c}
{\xe \v pthread_attr.c\:pthread_attr_getdetachstate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_attr_getdetachstate (const {\b pthread_attr_t} * {\i attr}, int * {\i detachstate})}}
\par
{\bkmkstart AAAAAAABSX}
{\bkmkend AAAAAAABSX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 38 of file pthread_attr.c.}\par
{
References pthread_attr::detachstate, and errno.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 38                                                                                      \{\par
39     if(!attr) \{\par
40         errno = EINVAL;\par
41         return 1;\par
42     \}\par
43 \par
44     *detachstate = attr->detachstate;\par
45     return 0;\par
46 \}\par
}
}
{\xe \v pthread_attr_getinheritsched\:pthread_attr.c}
{\xe \v pthread_attr.c\:pthread_attr_getinheritsched}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_attr_getinheritsched ({\b pthread_attr_t} * {\i attr}, int * {\i inheritsched})}}
\par
{\bkmkstart AAAAAAABSY}
{\bkmkend AAAAAAABSY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 133 of file pthread_attr.c.}\par
{
References errno, and pthread_attr::inheritsched.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 133                                                                                  \{\par
134     if(!attr) \{\par
135         errno = EINVAL;\par
136         return 1;\par
137     \}\par
138 \par
139     *inheritsched = attr->inheritsched;\par
140     return 0;\par
141 \}\par
}
}
{\xe \v pthread_attr_getschedparam\:pthread_attr.c}
{\xe \v pthread_attr.c\:pthread_attr_getschedparam}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_attr_getschedparam (const {\b pthread_attr_t} * {\i attr}, struct sched_param * {\i param})}}
\par
{\bkmkstart AAAAAAABSZ}
{\bkmkend AAAAAAABSZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 100 of file pthread_attr.c.}\par
{
References errno, and pthread_attr::param.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 100                                                                                              \{\par
101     if(!attr) \{\par
102         errno = EINVAL;\par
103         return 1;\par
104     \}\par
105 \par
106     memcpy(param, &attr->param, sizeof(struct sched_param));\par
107     return 0; \par
108 \}\par
}
}
{\xe \v pthread_attr_getschedpolicy\:pthread_attr.c}
{\xe \v pthread_attr.c\:pthread_attr_getschedpolicy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_attr_getschedpolicy ({\b pthread_attr_t} * {\i attr}, int * {\i policy})}}
\par
{\bkmkstart AAAAAAABTA}
{\bkmkend AAAAAAABTA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 123 of file pthread_attr.c.}\par
{
References errno.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 123                                                                           \{\par
124     errno = ENOSYS;\par
125     return 1;\par
126 \}\par
}
}
{\xe \v pthread_attr_getscope\:pthread_attr.c}
{\xe \v pthread_attr.c\:pthread_attr_getscope}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_attr_getscope (const {\b pthread_attr_t} * {\i attr}, int * {\i contentionscope})}}
\par
{\bkmkstart AAAAAAABTB}
{\bkmkend AAAAAAABTB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 153 of file pthread_attr.c.}\par
{
References pthread_attr::contentionscope, and errno.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 153                                                                                    \{\par
154     if(!attr) \{\par
155         errno = EINVAL;\par
156         return 1;\par
157     \}\par
158 \par
159     *contentionscope = attr->contentionscope;\par
160     return 0;\par
161 \}\par
}
}
{\xe \v pthread_attr_getstackaddr\:pthread_attr.c}
{\xe \v pthread_attr.c\:pthread_attr_getstackaddr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_attr_getstackaddr (const {\b pthread_attr_t} * {\i attr}, void ** {\i stackaddr})}}
\par
{\bkmkstart AAAAAAABTC}
{\bkmkend AAAAAAABTC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 58 of file pthread_attr.c.}\par
{
References errno, and pthread_attr::stackaddr.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 58                                                                                    \{\par
59     if(!attr) \{\par
60         errno = EINVAL;\par
61         return 1;\par
62     \}\par
63 \par
64     *stackaddr = attr->stackaddr;\par
65     return 0;\par
66 \}\par
}
}
{\xe \v pthread_attr_getstacksize\:pthread_attr.c}
{\xe \v pthread_attr.c\:pthread_attr_getstacksize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_attr_getstacksize (const {\b pthread_attr_t} * {\i attr}, size_t * {\i stacksize})}}
\par
{\bkmkstart AAAAAAABTD}
{\bkmkend AAAAAAABTD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 79 of file pthread_attr.c.}\par
{
References errno, and pthread_attr::stacksize.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 79                                                                                     \{\par
80     if(!attr) \{\par
81         errno = EINVAL;\par
82         return 1;\par
83     \}\par
84 \par
85     *stacksize = attr->stacksize;\par
86     return 0;\par
87 \}\par
}
}
{\xe \v pthread_attr_init\:pthread_attr.c}
{\xe \v pthread_attr.c\:pthread_attr_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_attr_init ({\b pthread_attr_t} * {\i attr})}}
\par
{\bkmkstart AAAAAAABTE}
{\bkmkend AAAAAAABTE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 12 of file pthread_attr.c.}\par
{
References pthread_attr::contentionscope, pthread_attr::detachstate, errno, pthread_attr::inheritsched, pthread_attr::param, PTHREAD_STACK_MIN, pthread_attr::stackaddr, and pthread_attr::stacksize.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12                                                    \{\par
13     if(!attr) \{\par
14         errno = EINVAL;\par
15         return 1;\par
16     \}\par
17 \par
18     attr->stackaddr = 0;\par
19     attr->stacksize = PTHREAD_STACK_MIN;\par
20     attr->detachstate = 0;\par
21     attr->param.sched_priority = 0;\par
22     attr->inheritsched = 0;\par
23     attr->contentionscope = 0;\par
24     \par
25     return 0;\par
26 \}\par
}
}
{\xe \v pthread_attr_setdetachstate\:pthread_attr.c}
{\xe \v pthread_attr.c\:pthread_attr_setdetachstate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_attr_setdetachstate ({\b pthread_attr_t} * {\i attr}, int {\i detachstate})}}
\par
{\bkmkstart AAAAAAABTF}
{\bkmkend AAAAAAABTF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 48 of file pthread_attr.c.}\par
{
References pthread_attr::detachstate, and errno.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 48                                                                               \{\par
49     if(!attr) \{\par
50         errno = EINVAL;\par
51         return 1;\par
52     \}\par
53 \par
54     attr->detachstate = detachstate;\par
55     return 0;\par
56 \}\par
}
}
{\xe \v pthread_attr_setinheritsched\:pthread_attr.c}
{\xe \v pthread_attr.c\:pthread_attr_setinheritsched}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_attr_setinheritsched ({\b pthread_attr_t} * {\i attr}, int {\i inheritsched})}}
\par
{\bkmkstart AAAAAAABTG}
{\bkmkend AAAAAAABTG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 143 of file pthread_attr.c.}\par
{
References errno, and pthread_attr::inheritsched.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 143                                                                                 \{\par
144     if(!attr) \{\par
145         errno = EINVAL;\par
146         return 1;\par
147     \}\par
148 \par
149     attr->inheritsched = inheritsched;\par
150     return 0;\par
151 \}\par
}
}
{\xe \v pthread_attr_setschedparam\:pthread_attr.c}
{\xe \v pthread_attr.c\:pthread_attr_setschedparam}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_attr_setschedparam ({\b pthread_attr_t} * {\i attr}, const struct sched_param * {\i param})}}
\par
{\bkmkstart AAAAAAABTH}
{\bkmkend AAAAAAABTH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 112 of file pthread_attr.c.}\par
{
References errno, and pthread_attr::param.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 112                                                                                              \{\par
113     if(!attr) \{\par
114         errno = EINVAL;\par
115         return 1;\par
116     \}\par
117 \par
118     memcpy(&attr->param, param, sizeof(struct sched_param));\par
119     return 0; \par
120 \}\par
}
}
{\xe \v pthread_attr_setschedpolicy\:pthread_attr.c}
{\xe \v pthread_attr.c\:pthread_attr_setschedpolicy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_attr_setschedpolicy ({\b pthread_attr_t} * {\i attr}, int {\i policy})}}
\par
{\bkmkstart AAAAAAABTI}
{\bkmkend AAAAAAABTI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 128 of file pthread_attr.c.}\par
{
References errno.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 128                                                                          \{\par
129     errno = ENOSYS;\par
130     return 1;\par
131 \}\par
}
}
{\xe \v pthread_attr_setscope\:pthread_attr.c}
{\xe \v pthread_attr.c\:pthread_attr_setscope}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_attr_setscope ({\b pthread_attr_t} * {\i attr}, int {\i contentionscope})}}
\par
{\bkmkstart AAAAAAABTJ}
{\bkmkend AAAAAAABTJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 163 of file pthread_attr.c.}\par
{
References pthread_attr::contentionscope, and errno.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 163                                                                             \{\par
164     if(!attr) \{\par
165         errno = EINVAL;\par
166         return 1;\par
167     \}\par
168 \par
169     attr->contentionscope = contentionscope;\par
170     return 0;\par
171 \}\par
}
}
{\xe \v pthread_attr_setstackaddr\:pthread_attr.c}
{\xe \v pthread_attr.c\:pthread_attr_setstackaddr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_attr_setstackaddr ({\b pthread_attr_t} * {\i attr}, void * {\i stackaddr})}}
\par
{\bkmkstart AAAAAAABTK}
{\bkmkend AAAAAAABTK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 68 of file pthread_attr.c.}\par
{
References errno, and pthread_attr::stackaddr.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 68                                                                             \{\par
69     if(!attr) \{\par
70         errno = EINVAL;\par
71         return 1;\par
72     \}\par
73 \par
74     attr->stackaddr = stackaddr;\par
75     return 0;\par
76 \}\par
}
}
{\xe \v pthread_attr_setstacksize\:pthread_attr.c}
{\xe \v pthread_attr.c\:pthread_attr_setstacksize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_attr_setstacksize ({\b pthread_attr_t} * {\i attr}, size_t {\i stacksize})}}
\par
{\bkmkstart AAAAAAABTL}
{\bkmkend AAAAAAABTL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 89 of file pthread_attr.c.}\par
{
References errno, and pthread_attr::stacksize.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 89                                                                              \{\par
90     if(!attr) \{\par
91         errno = EINVAL;\par
92         return 1;\par
93     \}\par
94 \par
95     attr->stacksize = stacksize;\par
96     return 0;\par
97 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
usr/src/libpthread/src/pthread_barrier.c File Reference\par \pard\plain 
{\tc\tcl2 \v usr/src/libpthread/src/pthread_barrier.c}
{\xe \v usr/src/libpthread/src/pthread_barrier.c}
{\bkmkstart AAAAAAABTM}
{\bkmkend AAAAAAABTM}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
{\f2 #include <sched.h>}\par
{\f2 #include <time.h>}\par
{\f2 #include <pthread.h>}\par
{\f2 #include "pthread_internal.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_barrier_init} ({\b pthread_barrier_t} *barrier, const {\b pthread_barrierattr_t} *attr, unsigned int count)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_barrier_destroy} ({\b pthread_barrier_t} *barrier)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_barrier_wait} ({\b pthread_barrier_t} *barrier)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v pthread_barrier_destroy\:pthread_barrier.c}
{\xe \v pthread_barrier.c\:pthread_barrier_destroy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_barrier_destroy ({\b pthread_barrier_t} * {\i barrier})}}
\par
{\bkmkstart AAAAAAABTN}
{\bkmkend AAAAAAABTN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 28 of file pthread_barrier.c.}\par
{
References pthread_barrier::curr_height, errno, and pthread_barrier::init_height.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28                                                                \{\par
29     if(barrier == NULL) \{\par
30         errno = EINVAL;\par
31         return 1;\par
32     \}\par
33 \par
34     barrier->curr_height = 0;\par
35     barrier->init_height = 0;\par
36     \par
37 \par
38     return 0;\par
39 \}\par
}
}
{\xe \v pthread_barrier_init\:pthread_barrier.c}
{\xe \v pthread_barrier.c\:pthread_barrier_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_barrier_init ({\b pthread_barrier_t} * {\i barrier}, const {\b pthread_barrierattr_t} * {\i attr}, unsigned int {\i count})}}
\par
{\bkmkstart AAAAAAABTO}
{\bkmkend AAAAAAABTO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9 of file pthread_barrier.c.}\par
{
References pthread_barrier::curr_height, errno, and pthread_barrier::init_height.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 9                                                                                                                    \{\par
10     if(barrier == NULL) \{\par
11         errno = EINVAL;\par
12         return 1;\par
13     \}\par
14 \par
15     if(count == 0) \{\par
16         errno = EINVAL;\par
17         return 1;\par
18     \}\par
19 \par
20     barrier->curr_height = 0;\par
21     barrier->init_height = count;\par
22     \par
23 \par
24     return 0;\par
25 \}\par
}
}
{\xe \v pthread_barrier_wait\:pthread_barrier.c}
{\xe \v pthread_barrier.c\:pthread_barrier_wait}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_barrier_wait ({\b pthread_barrier_t} * {\i barrier})}}
\par
{\bkmkstart AAAAAAABTP}
{\bkmkend AAAAAAABTP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 42 of file pthread_barrier.c.}\par
{
References pthread_barrier::curr_height, errno, pthread_barrier::init_height, and sched_yield().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 42                                                             \{\par
43     if(barrier == NULL) \{\par
44         errno = EINVAL;\par
45         return 1;\par
46     \}\par
47 \par
48     barrier->curr_height += 1;\par
49 \par
50     while(barrier->curr_height < barrier->init_height)\par
51         sched_yield();\par
52 \par
53     return 0;\par
54 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
usr/src/libpthread/src/pthread_barrierattr.c File Reference\par \pard\plain 
{\tc\tcl2 \v usr/src/libpthread/src/pthread_barrierattr.c}
{\xe \v usr/src/libpthread/src/pthread_barrierattr.c}
{\bkmkstart AAAAAAABTQ}
{\bkmkend AAAAAAABTQ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <pthread.h>}\par
{\f2 #include "pthread_internal.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_barrierattr_init} ({\b pthread_barrierattr_t} *attr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_barrierattr_destroy} ({\b pthread_barrierattr_t} *attr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_barrierattr_getpshared} (const {\b pthread_barrierattr_t} *attr, int *pshared)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_barrierattr_setpshared} ({\b pthread_barrierattr_t} *attr, int pshared)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v pthread_barrierattr_destroy\:pthread_barrierattr.c}
{\xe \v pthread_barrierattr.c\:pthread_barrierattr_destroy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_barrierattr_destroy ({\b pthread_barrierattr_t} * {\i attr})}}
\par
{\bkmkstart AAAAAAABTR}
{\bkmkend AAAAAAABTR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 20 of file pthread_barrierattr.c.}\par
{
References errno, and pthread_barrierattr::pshared.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20                                                                     \{\par
21     if(attr == NULL) \{\par
22         errno = EINVAL;\par
23         return 1;\par
24     \}\par
25 \par
26     attr->pshared = 0;\par
27     return 0;\par
28 \}\par
}
}
{\xe \v pthread_barrierattr_getpshared\:pthread_barrierattr.c}
{\xe \v pthread_barrierattr.c\:pthread_barrierattr_getpshared}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_barrierattr_getpshared (const {\b pthread_barrierattr_t} * {\i attr}, int * {\i pshared})}}
\par
{\bkmkstart AAAAAAABTS}
{\bkmkend AAAAAAABTS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 31 of file pthread_barrierattr.c.}\par
{
References errno, and pthread_barrierattr::pshared.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 31                                                                                            \{\par
32     if(attr == NULL) \{\par
33         errno = EINVAL;\par
34         return 1;\par
35     \}\par
36 \par
37     if(pshared == NULL) \{\par
38         errno = EINVAL;\par
39         return 1;\par
40     \}\par
41     \par
42     *pshared = attr->pshared;\par
43     return 0;\par
44 \}\par
}
}
{\xe \v pthread_barrierattr_init\:pthread_barrierattr.c}
{\xe \v pthread_barrierattr.c\:pthread_barrierattr_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_barrierattr_init ({\b pthread_barrierattr_t} * {\i attr})}}
\par
{\bkmkstart AAAAAAABTT}
{\bkmkend AAAAAAABTT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9 of file pthread_barrierattr.c.}\par
{
References errno, and pthread_barrierattr::pshared.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 9                                                                  \{\par
10     if(attr == NULL) \{\par
11         errno = EINVAL;\par
12         return 1;\par
13     \}\par
14 \par
15     attr->pshared = 0;\par
16     return 0;\par
17 \}\par
}
}
{\xe \v pthread_barrierattr_setpshared\:pthread_barrierattr.c}
{\xe \v pthread_barrierattr.c\:pthread_barrierattr_setpshared}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_barrierattr_setpshared ({\b pthread_barrierattr_t} * {\i attr}, int {\i pshared})}}
\par
{\bkmkstart AAAAAAABTU}
{\bkmkend AAAAAAABTU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 47 of file pthread_barrierattr.c.}\par
{
References errno, and pthread_barrierattr::pshared.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 47                                                                                     \{\par
48     if(attr == NULL) \{\par
49         errno = EINVAL;\par
50         return 1;\par
51     \}\par
52 \par
53     attr->pshared = pshared;\par
54     return 0;\par
55 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
usr/src/libpthread/src/pthread_cancel.c File Reference\par \pard\plain 
{\tc\tcl2 \v usr/src/libpthread/src/pthread_cancel.c}
{\xe \v usr/src/libpthread/src/pthread_cancel.c}
{\bkmkstart AAAAAAABTV}
{\bkmkend AAAAAAABTV}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
{\f2 #include <pthread.h>}\par
{\f2 #include "pthread_internal.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_cancel} ({\b pthread_t} thread)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_setcancelstate} (int state, int *oldstate)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_setcanceltype} (int {\b type}, int *oldtype)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} void {\b pthread_testcancel} (void)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v pthread_cancel\:pthread_cancel.c}
{\xe \v pthread_cancel.c\:pthread_cancel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_cancel ({\b pthread_t} {\i thread})}}
\par
{\bkmkstart AAAAAAABTW}
{\bkmkend AAAAAAABTW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 7 of file pthread_cancel.c.}\par
{
References pthread_detach().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7                                             \{\par
8     return pthread_detach(thread);\par
9 \}\par
}
}
{\xe \v pthread_setcancelstate\:pthread_cancel.c}
{\xe \v pthread_cancel.c\:pthread_setcancelstate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_setcancelstate (int {\i state}, int * {\i oldstate})}}
\par
{\bkmkstart AAAAAAABTX}
{\bkmkend AAAAAAABTX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 12 of file pthread_cancel.c.}\par
{
References errno.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12                                                             \{\par
13     errno = ENOSYS;\par
14     return 1;\par
15 \}\par
}
}
{\xe \v pthread_setcanceltype\:pthread_cancel.c}
{\xe \v pthread_cancel.c\:pthread_setcanceltype}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_setcanceltype (int {\i type}, int * {\i oldtype})}}
\par
{\bkmkstart AAAAAAABTY}
{\bkmkend AAAAAAABTY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 18 of file pthread_cancel.c.}\par
{
References errno.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18                                                          \{\par
19     errno = ENOSYS;\par
20     return 1;\par
21 \}\par
}
}
{\xe \v pthread_testcancel\:pthread_cancel.c}
{\xe \v pthread_cancel.c\:pthread_testcancel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} void pthread_testcancel (void )}}
\par
{\bkmkstart AAAAAAABTZ}
{\bkmkend AAAAAAABTZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 23 of file pthread_cancel.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 23                                      \{\par
24     /* Boh ?? */\par
25 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
usr/src/libpthread/src/pthread_cond.c File Reference\par \pard\plain 
{\tc\tcl2 \v usr/src/libpthread/src/pthread_cond.c}
{\xe \v usr/src/libpthread/src/pthread_cond.c}
{\bkmkstart AAAAAAABUA}
{\bkmkend AAAAAAABUA}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
{\f2 #include <sched.h>}\par
{\f2 #include <time.h>}\par
{\f2 #include <pthread.h>}\par
{\f2 #include "pthread_internal.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_cond_init} ({\b pthread_cond_t} *cond, const {\b pthread_condattr_t} *attr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_cond_destroy} ({\b pthread_cond_t} *cond)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_cond_timedwait} ({\b pthread_cond_t} *cond, {\b pthread_mutex_t} *mutex, const struct timespec *abstime)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_cond_wait} ({\b pthread_cond_t} *cond, {\b pthread_mutex_t} *mutex)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_cond_signal} ({\b pthread_cond_t} *cond)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_cond_broadcast} ({\b pthread_cond_t} *cond)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EXTERN} {\b pthread_context_t} * {\b __pthread_queue}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v pthread_cond_broadcast\:pthread_cond.c}
{\xe \v pthread_cond.c\:pthread_cond_broadcast}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_cond_broadcast ({\b pthread_cond_t} * {\i cond})}}
\par
{\bkmkstart AAAAAAABUB}
{\bkmkend AAAAAAABUB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 116 of file pthread_cond.c.}\par
{
References __pthread_queue, pthread_context::cond, errno, pthread_context::next, pthread_cond::semaphore, and pthread_cond::waiting.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 116                                                         \{\par
117     if(!__pthread_queue) \{\par
118         errno = ESRCH;\par
119         return -1;\par
120     \}\par
121 \par
122 \par
123     pthread_context_t* tmp = __pthread_queue;\par
124     while(tmp) \{\par
125         if(tmp->cond == cond) \{\par
126             if(tmp->cond->waiting) \{\par
127                 tmp->cond->semaphore = 0;       \par
128             \}\par
129         \}\par
130 \par
131         tmp = tmp->next;\par
132     \}\par
133 \par
134 \par
135     return 0;\par
136 \}\par
}
}
{\xe \v pthread_cond_destroy\:pthread_cond.c}
{\xe \v pthread_cond.c\:pthread_cond_destroy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_cond_destroy ({\b pthread_cond_t} * {\i cond})}}
\par
{\bkmkstart AAAAAAABUC}
{\bkmkend AAAAAAABUC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 25 of file pthread_cond.c.}\par
{
References errno, pthread_cond::semaphore, and pthread_cond::waiting.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25                                                       \{\par
26     if(!cond) \{\par
27         errno = EINVAL;\par
28         return 1;\par
29     \}\par
30 \par
31     if(cond->waiting) \{\par
32         errno = EBUSY;\par
33         return 1;\par
34     \}\par
35 \par
36 \par
37     cond->waiting = 0;\par
38     cond->semaphore = 0;        \par
39     \par
40     return 0;\par
41 \}\par
}
}
{\xe \v pthread_cond_init\:pthread_cond.c}
{\xe \v pthread_cond.c\:pthread_cond_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_cond_init ({\b pthread_cond_t} * {\i cond}, const {\b pthread_condattr_t} * {\i attr})}}
\par
{\bkmkstart AAAAAAABUD}
{\bkmkend AAAAAAABUD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 13 of file pthread_cond.c.}\par
{
References errno, pthread_cond::semaphore, and pthread_cond::waiting.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13                                                                                    \{\par
14     if(!cond) \{\par
15         errno = EINVAL;\par
16         return 1;\par
17     \}\par
18 \par
19     cond->waiting = 0;\par
20     cond->semaphore = 0;\par
21 \par
22     return 0;\par
23 \}\par
}
}
{\xe \v pthread_cond_signal\:pthread_cond.c}
{\xe \v pthread_cond.c\:pthread_cond_signal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_cond_signal ({\b pthread_cond_t} * {\i cond})}}
\par
{\bkmkstart AAAAAAABUE}
{\bkmkend AAAAAAABUE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 93 of file pthread_cond.c.}\par
{
References __pthread_queue, pthread_context::cond, errno, pthread_context::next, pthread_cond::semaphore, and pthread_cond::waiting.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 93                                                      \{\par
94     if(!__pthread_queue) \{\par
95         errno = ESRCH;\par
96         return -1;\par
97     \}\par
98 \par
99 \par
100     pthread_context_t* tmp = __pthread_queue;\par
101     while(tmp) \{\par
102         if(tmp->cond == cond) \{\par
103             if(tmp->cond->waiting) \{\par
104                 tmp->cond->semaphore = 0;\par
105                 return 0;           \par
106             \}\par
107         \}\par
108 \par
109         tmp = tmp->next;\par
110     \}\par
111 \par
112     errno = ESRCH;\par
113     return -1;\par
114 \}\par
}
}
{\xe \v pthread_cond_timedwait\:pthread_cond.c}
{\xe \v pthread_cond.c\:pthread_cond_timedwait}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_cond_timedwait ({\b pthread_cond_t} * {\i cond}, {\b pthread_mutex_t} * {\i mutex}, const struct timespec * {\i abstime})}}
\par
{\bkmkstart AAAAAAABUF}
{\bkmkend AAAAAAABUF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 44 of file pthread_cond.c.}\par
{
References pthread_context::cond, errno, pthread_mutex::owner, pthread_mutex_unlock(), pthread_self(), sched_yield(), pthread_cond::semaphore, and pthread_cond::waiting.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 44                                                                                                                 \{\par
45         if(!cond) \{\par
46         errno = EINVAL;\par
47         return 1;\par
48     \}\par
49 \par
50     if(!mutex) \{\par
51         errno = EINVAL;\par
52         return 1;\par
53     \}\par
54 \par
55     if(mutex->owner != pthread_self()) \{\par
56         errno = EINVAL;\par
57         return 1;\par
58     \}\par
59 \par
60     pthread_context_t* ctx = (pthread_context_t*) pthread_self();\par
61     if(!ctx) \{\par
62         errno = EINVAL;\par
63         return -1;\par
64     \}\par
65 \par
66     ctx->cond = cond;\par
67     ctx->cond->waiting = 1;\par
68     ctx->cond->semaphore = 1;\par
69 \par
70     int t0;\par
71     if(abstime)\par
72         t0 = time(NULL) + abstime->tv_sec;\par
73     else\par
74         t0 = ~0;\par
75 \par
76     while(ctx->cond->semaphore == 1 && (time(NULL) < t0))\par
77         sched_yield();\par
78 \par
79     ctx->cond->waiting = 0;\par
80     ctx->cond->semaphore = 0;\par
81     ctx->cond = 0;\par
82 \par
83     pthread_mutex_unlock(mutex);\par
84 \par
85     return 0;\par
86 \}\par
}
}
{\xe \v pthread_cond_wait\:pthread_cond.c}
{\xe \v pthread_cond.c\:pthread_cond_wait}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_cond_wait ({\b pthread_cond_t} * {\i cond}, {\b pthread_mutex_t} * {\i mutex})}}
\par
{\bkmkstart AAAAAAABUG}
{\bkmkend AAAAAAABUG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 88 of file pthread_cond.c.}\par
{
References pthread_cond_timedwait().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 88                                                                            \{\par
89     return pthread_cond_timedwait(cond, mutex, NULL);\par
90 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v __pthread_queue\:pthread_cond.c}
{\xe \v pthread_cond.c\:__pthread_queue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b EXTERN} {\b pthread_context_t}* __pthread_queue}}
\par
{\bkmkstart AAAAAAABUH}
{\bkmkend AAAAAAABUH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9 of file pthread_cond.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
usr/src/libpthread/src/pthread_condattr.c File Reference\par \pard\plain 
{\tc\tcl2 \v usr/src/libpthread/src/pthread_condattr.c}
{\xe \v usr/src/libpthread/src/pthread_condattr.c}
{\bkmkstart AAAAAAABUI}
{\bkmkend AAAAAAABUI}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
{\f2 #include <pthread.h>}\par
{\f2 #include "pthread_internal.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_condattr_init} ({\b pthread_condattr_t} *attr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_condattr_destroy} ({\b pthread_condattr_t} *attr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_condattr_getpshared} (const {\b pthread_condattr_t} *attr, int *pshared)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_condattr_setpshared} ({\b pthread_condattr_t} *attr, int pshared)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v pthread_condattr_destroy\:pthread_condattr.c}
{\xe \v pthread_condattr.c\:pthread_condattr_destroy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_condattr_destroy ({\b pthread_condattr_t} * {\i attr})}}
\par
{\bkmkstart AAAAAAABUJ}
{\bkmkend AAAAAAABUJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 18 of file pthread_condattr.c.}\par
{
References errno, and pthread_condattr::pshared.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18                                                               \{\par
19     if(!attr) \{\par
20         errno = EINVAL;\par
21         return 1;\par
22     \}\par
23 \par
24     attr->pshared = 0;\par
25     return 0;\par
26 \}\par
}
}
{\xe \v pthread_condattr_getpshared\:pthread_condattr.c}
{\xe \v pthread_condattr.c\:pthread_condattr_getpshared}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_condattr_getpshared (const {\b pthread_condattr_t} * {\i attr}, int * {\i pshared})}}
\par
{\bkmkstart AAAAAAABUK}
{\bkmkend AAAAAAABUK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 29 of file pthread_condattr.c.}\par
{
References errno, and pthread_condattr::pshared.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 29                                                                                      \{\par
30     if(!attr) \{\par
31         errno = EINVAL;\par
32         return 1;\par
33     \}\par
34 \par
35     \par
36     *pshared = attr->pshared;\par
37     return 0;\par
38 \}\par
}
}
{\xe \v pthread_condattr_init\:pthread_condattr.c}
{\xe \v pthread_condattr.c\:pthread_condattr_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_condattr_init ({\b pthread_condattr_t} * {\i attr})}}
\par
{\bkmkstart AAAAAAABUL}
{\bkmkend AAAAAAABUL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 7 of file pthread_condattr.c.}\par
{
References errno, and pthread_condattr::pshared.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7                                                            \{\par
8     if(!attr) \{\par
9         errno = EINVAL;\par
10         return 1;\par
11     \}\par
12 \par
13     attr->pshared = 0;\par
14     return 0;\par
15 \}\par
}
}
{\xe \v pthread_condattr_setpshared\:pthread_condattr.c}
{\xe \v pthread_condattr.c\:pthread_condattr_setpshared}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_condattr_setpshared ({\b pthread_condattr_t} * {\i attr}, int {\i pshared})}}
\par
{\bkmkstart AAAAAAABUM}
{\bkmkend AAAAAAABUM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 41 of file pthread_condattr.c.}\par
{
References errno, and pthread_condattr::pshared.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 41                                                                               \{\par
42     if(!attr) \{\par
43         errno = EINVAL;\par
44         return 1;\par
45     \}\par
46 \par
47     attr->pshared = pshared;\par
48     return 0;\par
49 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
usr/src/libpthread/src/pthread_create.c File Reference\par \pard\plain 
{\tc\tcl2 \v usr/src/libpthread/src/pthread_create.c}
{\xe \v usr/src/libpthread/src/pthread_create.c}
{\bkmkstart AAAAAAABUN}
{\bkmkend AAAAAAABUN}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <pthread.h>}\par
{\f2 #include "pthread_internal.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EXTERN} void {\b __pthread_init_queue} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PRIVATE} void {\b __pthread_handler__} ({\b pthread_context_t} *ctx)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_create} ({\b pthread_t} *thread, const {\b pthread_attr_t} *attr, void *(*start)(void *), void *arg)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EXTERN} {\b uint32_t} {\b __pthread_counts}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EXTERN} {\b pthread_context_t} * {\b __pthread_queue}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v __pthread_handler__\:pthread_create.c}
{\xe \v pthread_create.c\:__pthread_handler__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PRIVATE} void __pthread_handler__ ({\b pthread_context_t} * {\i ctx})}}
\par
{\bkmkstart AAAAAAABUO}
{\bkmkend AAAAAAABUO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 24 of file pthread_create.c.}\par
{
References pthread_context::entry, pthread_context::param, and pthread_exit().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 24                                                          \{\par
25 #endif\par
26 \par
27     if(ctx == NULL)\par
28         _exit(-1);\par
29 \par
30     if(ctx->entry == NULL)\par
31         _exit(-1);\par
32 \par
33     pthread_exit(ctx->entry(ctx->param));\par
34 \}\par
}
}
{\xe \v __pthread_init_queue\:pthread_create.c}
{\xe \v pthread_create.c\:__pthread_init_queue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b EXTERN} void __pthread_init_queue (void )}}
\par
{\bkmkstart AAAAAAABUP}
{\bkmkend AAAAAAABUP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 12 of file pthread_queue.c.}\par
{
References __current_thread, __os_gettid, pthread_context::attr, pthread_context::cond, pthread_once::done, pthread_context::entry, pthread_context::exitval, pthread_context::next, pthread_context::once, pthread_context::param, pthread_once::started, and pthread_context::tid.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12                                    \{\par
13     if(__current_thread.tid)\par
14         return;\par
15 \par
16     __current_thread.tid = __os_gettid();\par
17     __current_thread.entry = NULL;\par
18     __current_thread.param = NULL;\par
19     __current_thread.exitval = NULL;\par
20     __current_thread.once.done = 0;\par
21     __current_thread.once.started = -1;\par
22     __current_thread.cond = NULL;\par
23     __current_thread.next = NULL;\par
24 \par
25     memset(&__current_thread.attr, 0, sizeof(pthread_attr_t));\par
26 \}\par
}
}
{\xe \v pthread_create\:pthread_create.c}
{\xe \v pthread_create.c\:pthread_create}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_create ({\b pthread_t} * {\i thread}, const {\b pthread_attr_t} * {\i attr}, void *(*)(void *) {\i start}, void * {\i arg})}}
\par
{\bkmkstart AAAAAAABUQ}
{\bkmkend AAAAAAABUQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 37 of file pthread_create.c.}\par
{
References __os_thread_create, __pthread_counts, __pthread_handler__(), __pthread_init_queue(), __pthread_queue, pthread_context::attr, pthread_once::done, pthread_context::entry, errno, pthread_attr::inheritsched, pthread_context::next, pthread_context::once, pthread_context::param, pthread_attr::param, pthread_attr_setschedparam(), PTHREAD_INHERIT_SCHED, pthread_self(), PTHREAD_THREADS_MAX, pthread_once::started, and pthread_context::tid.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 37                                                                                                            \{\par
38 \par
39     __pthread_init_queue();\par
40 \par
41     if(!thread) \{\par
42         errno = EINVAL;\par
43         return 1;\par
44     \}\par
45 \par
46     if(__pthread_counts > PTHREAD_THREADS_MAX) \{\par
47         errno = EAGAIN;\par
48         return 1;\par
49     \}\par
50 \par
51     pthread_context_t* ctx = malloc(sizeof(pthread_context_t));\par
52     memset(ctx, 0, sizeof(pthread_context_t));\par
53 \par
54     ctx->entry = start;\par
55     ctx->param = arg;\par
56     ctx->once.done = 0;\par
57     ctx->once.started = -1;\par
58     ctx->next = 0;\par
59 \par
60     if(attr)\par
61         memcpy(&ctx->attr, attr, sizeof(pthread_attr_t));\par
62 \par
63     if(ctx->attr.inheritsched == PTHREAD_INHERIT_SCHED) \{\par
64         pthread_t px = pthread_self();\par
65         if(px) \{\par
66             pthread_context_t* inh = (pthread_context_t*) px;\par
67             pthread_attr_setschedparam(&ctx->attr, &inh->attr.param);\par
68         \}\par
69     \}\par
70 \par
71 \par
72     __pthread_counts += 1;\par
73     *thread = (pthread_t) ctx;\par
74     \par
75     \par
76     ctx->next = __pthread_queue;\par
77     __pthread_queue = ctx;\par
78         \par
79 \par
80 \par
81     ctx->tid = __os_thread_create(__pthread_handler__, ctx, ctx->attr.param.sched_priority);\par
82     return 0;\par
83 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v __pthread_counts\:pthread_create.c}
{\xe \v pthread_create.c\:__pthread_counts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b EXTERN} {\b uint32_t} __pthread_counts}}
\par
{\bkmkstart AAAAAAABUR}
{\bkmkend AAAAAAABUR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 10 of file pthread_create.c.}\par
}
{\xe \v __pthread_queue\:pthread_create.c}
{\xe \v pthread_create.c\:__pthread_queue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b EXTERN} {\b pthread_context_t}* __pthread_queue}}
\par
{\bkmkstart AAAAAAABUS}
{\bkmkend AAAAAAABUS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 11 of file pthread_create.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
usr/src/libpthread/src/pthread_detach.c File Reference\par \pard\plain 
{\tc\tcl2 \v usr/src/libpthread/src/pthread_detach.c}
{\xe \v usr/src/libpthread/src/pthread_detach.c}
{\bkmkstart AAAAAAABUT}
{\bkmkend AAAAAAABUT}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
{\f2 #include <signal.h>}\par
{\f2 #include <pthread.h>}\par
{\f2 #include "pthread_internal.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_detach} ({\b pthread_t} thread)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EXTERN} {\b uint32_t} {\b __pthread_counts}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EXTERN} {\b pthread_context_t} * {\b __pthread_queue}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v pthread_detach\:pthread_detach.c}
{\xe \v pthread_detach.c\:pthread_detach}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_detach ({\b pthread_t} {\i thread})}}
\par
{\bkmkstart AAAAAAABUU}
{\bkmkend AAAAAAABUU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 12 of file pthread_detach.c.}\par
{
References __os_thread_kill, __pthread_queue, pthread_once::done, errno, pthread_context::once, and pthread_context::tid.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12                                             \{\par
13     if(!thread) \{\par
14         errno = EINVAL;\par
15         return 1;\par
16     \}\par
17 \par
18     if(!__pthread_queue) \{\par
19         errno = ESRCH;\par
20         return 1;\par
21     \}\par
22 \par
23     pthread_context_t* ctx = (pthread_context_t*) thread;\par
24     if(__os_thread_kill(ctx->tid, SIGKILL) == 0)\par
25         ctx->once.done = 1;\par
26     else \{\par
27         errno = ESRCH;\par
28         return 1;\par
29     \}\par
30 \par
31     __pthread_counts -= 1;\par
32     pthread_context_t* tmp = __pthread_queue;\par
33 \par
34     if(tmp->next) \{\par
35         while(tmp->next) \{\par
36             if(tmp->next == ctx) \{\par
37                 tmp->next = ctx->next;\par
38                 break;\par
39             \}\par
40 \par
41             tmp = tmp->next;\par
42         \}\par
43     \} else \{\par
44         if(__pthread_queue == ctx)\par
45             __pthread_queue = 0;\par
46     \}\par
47 \par
48     return 0;\par
49 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v __pthread_counts\:pthread_detach.c}
{\xe \v pthread_detach.c\:__pthread_counts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b EXTERN} {\b uint32_t} __pthread_counts}}
\par
{\bkmkstart AAAAAAABUV}
{\bkmkend AAAAAAABUV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9 of file pthread_detach.c.}\par
}
{\xe \v __pthread_queue\:pthread_detach.c}
{\xe \v pthread_detach.c\:__pthread_queue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b EXTERN} {\b pthread_context_t}* __pthread_queue}}
\par
{\bkmkstart AAAAAAABUW}
{\bkmkend AAAAAAABUW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 10 of file pthread_detach.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
usr/src/libpthread/src/pthread_equal.c File Reference\par \pard\plain 
{\tc\tcl2 \v usr/src/libpthread/src/pthread_equal.c}
{\xe \v usr/src/libpthread/src/pthread_equal.c}
{\bkmkstart AAAAAAABUX}
{\bkmkend AAAAAAABUX}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
{\f2 #include <pthread.h>}\par
{\f2 #include "pthread_internal.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_equal} ({\b pthread_t} t1, {\b pthread_t} t2)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v pthread_equal\:pthread_equal.c}
{\xe \v pthread_equal.c\:pthread_equal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_equal ({\b pthread_t} {\i t1}, {\b pthread_t} {\i t2})}}
\par
{\bkmkstart AAAAAAABUY}
{\bkmkend AAAAAAABUY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 7 of file pthread_equal.c.}\par
{
References pthread_context::tid.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7                                                      \{\par
8     pthread_context_t* c1 = (pthread_context_t*) t1;\par
9     pthread_context_t* c2 = (pthread_context_t*) t2;\par
10 \par
11     return (c1->tid == c2->tid);\par
12 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
usr/src/libpthread/src/pthread_exit.c File Reference\par \pard\plain 
{\tc\tcl2 \v usr/src/libpthread/src/pthread_exit.c}
{\xe \v usr/src/libpthread/src/pthread_exit.c}
{\bkmkstart AAAAAAABUZ}
{\bkmkend AAAAAAABUZ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <pthread.h>}\par
{\f2 #include "pthread_internal.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} void {\b pthread_exit} (void *value_ptr)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v pthread_exit\:pthread_exit.c}
{\xe \v pthread_exit.c\:pthread_exit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} void pthread_exit (void * {\i value_ptr})}}
\par
{\bkmkstart AAAAAAABVA}
{\bkmkend AAAAAAABVA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 8 of file pthread_exit.c.}\par
{
References pthread_context::exitval, pthread_detach(), and pthread_self().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 8                                           \{\par
9     pthread_t ptx = pthread_self();\par
10     pthread_context_t* ctx = (pthread_context_t*) ptx;\par
11 \par
12     if(ptx) \{\par
13         ctx->exitval = value_ptr;\par
14         pthread_detach(ptx);\par
15     \}else\par
16         abort();\par
17 \par
18     for(;;);\par
19 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
usr/src/libpthread/src/pthread_internal.h File Reference\par \pard\plain 
{\tc\tcl2 \v usr/src/libpthread/src/pthread_internal.h}
{\xe \v usr/src/libpthread/src/pthread_internal.h}
{\bkmkstart AAAAAAABVB}
{\bkmkend AAAAAAABVB}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <errno.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <pthread.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b __pthread_key}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b pthread_context}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PRIVATE}\~ static\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PUBLIC}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EXTERN}\~ extern\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PTHREAD_KEYS_MAX}\~ 64\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PTHREAD_STACK_MIN}\~ 4096\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PTHREAD_THREADS_MAX}\~ 2048\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b __pthread_key} {\b __pthread_key_t}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b pthread_context} {\b pthread_context_t}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sched_yield} (void)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v EXTERN\:pthread_internal.h}
{\xe \v pthread_internal.h\:EXTERN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EXTERN\~ extern}}
\par
{\bkmkstart AAAAAAABVC}
{\bkmkend AAAAAAABVC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 20 of file pthread_internal.h.}\par
}
{\xe \v PRIVATE\:pthread_internal.h}
{\xe \v pthread_internal.h\:PRIVATE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PRIVATE\~ static}}
\par
{\bkmkstart AAAAAAABVD}
{\bkmkend AAAAAAABVD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 11 of file pthread_internal.h.}\par
}
{\xe \v PTHREAD_KEYS_MAX\:pthread_internal.h}
{\xe \v pthread_internal.h\:PTHREAD_KEYS_MAX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PTHREAD_KEYS_MAX\~ 64}}
\par
{\bkmkstart AAAAAAABVE}
{\bkmkend AAAAAAABVE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 25 of file pthread_internal.h.}\par
}
{\xe \v PTHREAD_STACK_MIN\:pthread_internal.h}
{\xe \v pthread_internal.h\:PTHREAD_STACK_MIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PTHREAD_STACK_MIN\~ 4096}}
\par
{\bkmkstart AAAAAAABVF}
{\bkmkend AAAAAAABVF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 26 of file pthread_internal.h.}\par
}
{\xe \v PTHREAD_THREADS_MAX\:pthread_internal.h}
{\xe \v pthread_internal.h\:PTHREAD_THREADS_MAX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PTHREAD_THREADS_MAX\~ 2048}}
\par
{\bkmkstart AAAAAAABVG}
{\bkmkend AAAAAAABVG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 27 of file pthread_internal.h.}\par
}
{\xe \v PUBLIC\:pthread_internal.h}
{\xe \v pthread_internal.h\:PUBLIC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PUBLIC}}
\par
{\bkmkstart AAAAAAABVH}
{\bkmkend AAAAAAABVH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 15 of file pthread_internal.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v __pthread_key_t\:pthread_internal.h}
{\xe \v pthread_internal.h\:__pthread_key_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b __pthread_key}  {\b __pthread_key_t}}}
\par
{\bkmkstart AAAAAAABVI}
{\bkmkend AAAAAAABVI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v pthread_context_t\:pthread_internal.h}
{\xe \v pthread_internal.h\:pthread_context_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b pthread_context}  {\b pthread_context_t}}}
\par
{\bkmkstart AAAAAAABVJ}
{\bkmkend AAAAAAABVJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v sched_yield\:pthread_internal.h}
{\xe \v pthread_internal.h\:sched_yield}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int sched_yield (void )}}
\par
{\bkmkstart AAAAAAABVK}
{\bkmkend AAAAAAABVK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
usr/src/libpthread/src/pthread_join.c File Reference\par \pard\plain 
{\tc\tcl2 \v usr/src/libpthread/src/pthread_join.c}
{\xe \v usr/src/libpthread/src/pthread_join.c}
{\bkmkstart AAAAAAABVL}
{\bkmkend AAAAAAABVL}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
{\f2 #include <sched.h>}\par
{\f2 #include <pthread.h>}\par
{\f2 #include "pthread_internal.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_join} ({\b pthread_t} thread, void **value_ptr)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v pthread_join\:pthread_join.c}
{\xe \v pthread_join.c\:pthread_join}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_join ({\b pthread_t} {\i thread}, void ** {\i value_ptr})}}
\par
{\bkmkstart AAAAAAABVM}
{\bkmkend AAAAAAABVM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 8 of file pthread_join.c.}\par
{
References pthread_once::done, errno, pthread_context::exitval, pthread_context::once, and sched_yield().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 8                                                             \{\par
9     if(!thread) \{\par
10         errno = EINVAL;\par
11         return 1;\par
12     \}\par
13 \par
14     pthread_context_t* ctx = (pthread_context_t*) thread;\par
15     while(ctx->once.done == 0)\par
16         sched_yield();\par
17 \par
18     if(value_ptr)\par
19         *value_ptr = ctx->exitval;\par
20 \par
21     return 0;\par
22 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
usr/src/libpthread/src/pthread_key.c File Reference\par \pard\plain 
{\tc\tcl2 \v usr/src/libpthread/src/pthread_key.c}
{\xe \v usr/src/libpthread/src/pthread_key.c}
{\bkmkstart AAAAAAABVN}
{\bkmkend AAAAAAABVN}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
{\f2 #include <pthread.h>}\par
{\f2 #include "pthread_internal.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_key_create} ({\b pthread_key_t} *key, void(*destructor)(void *))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_key_delete} ({\b pthread_key_t} key)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_setspecific} ({\b pthread_key_t} key, const void *{\b value})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} void * {\b pthread_getspecific} ({\b pthread_key_t} key)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PRIVATE} {\b __pthread_key_t} {\b __pthread_keys} [{\b PTHREAD_KEYS_MAX}] = \{ \}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v pthread_getspecific\:pthread_key.c}
{\xe \v pthread_key.c\:pthread_getspecific}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} void* pthread_getspecific ({\b pthread_key_t} {\i key})}}
\par
{\bkmkstart AAAAAAABVO}
{\bkmkend AAAAAAABVO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 65 of file pthread_key.c.}\par
{
References __pthread_keys, errno, PTHREAD_KEYS_MAX, and __pthread_key::value.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 65                                                     \{\par
66     if(key > PTHREAD_KEYS_MAX) \{\par
67         errno = EINVAL;\par
68         return 0;\par
69     \}\par
70 \par
71     if(__pthread_keys[key].used == 0) \{\par
72         errno = EINVAL;\par
73         return 0;\par
74     \}\par
75 \par
76     return __pthread_keys[key].value;\par
77 \}\par
}
}
{\xe \v pthread_key_create\:pthread_key.c}
{\xe \v pthread_key.c\:pthread_key_create}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_key_create ({\b pthread_key_t} * {\i key}, void(*)(void *) {\i destructor})}}
\par
{\bkmkstart AAAAAAABVP}
{\bkmkend AAAAAAABVP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9 of file pthread_key.c.}\par
{
References __pthread_keys, __pthread_key::dtor, errno, PTHREAD_KEYS_MAX, __pthread_key::used, and __pthread_key::value.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 9                                                                               \{\par
10     if(!key) \{\par
11         errno = EINVAL;\par
12         return 1;\par
13     \}\par
14 \par
15     int i;\par
16     for(i = 0; i < PTHREAD_KEYS_MAX; i++) \{\par
17         if(__pthread_keys[i].used == 0) \{\par
18             __pthread_keys[i].used = 1;\par
19             __pthread_keys[i].dtor = destructor;\par
20             __pthread_keys[i].value = NULL;\par
21 \par
22             *key = i;\par
23             return 0;\par
24         \}\par
25     \}\par
26 \par
27     errno = EAGAIN;\par
28     return 1;\par
29 \}\par
}
}
{\xe \v pthread_key_delete\:pthread_key.c}
{\xe \v pthread_key.c\:pthread_key_delete}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_key_delete ({\b pthread_key_t} {\i key})}}
\par
{\bkmkstart AAAAAAABVQ}
{\bkmkend AAAAAAABVQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 32 of file pthread_key.c.}\par
{
References __pthread_keys, __pthread_key::dtor, errno, PTHREAD_KEYS_MAX, __pthread_key::used, __pthread_key::value, and value.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 32                                                  \{\par
33     if(key > PTHREAD_KEYS_MAX) \{\par
34         errno = EINVAL;\par
35         return 1;\par
36     \}\par
37 \par
38     if(__pthread_keys[key].dtor)\par
39         __pthread_keys[key].dtor(__pthread_keys[key].value);\par
40 \par
41     __pthread_keys[key].used = 0;\par
42     __pthread_keys[key].dtor = 0;\par
43     __pthread_keys[key].value = NULL;\par
44     \par
45     return 0;\par
46 \}\par
}
}
{\xe \v pthread_setspecific\:pthread_key.c}
{\xe \v pthread_key.c\:pthread_setspecific}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_setspecific ({\b pthread_key_t} {\i key}, const void * {\i value})}}
\par
{\bkmkstart AAAAAAABVR}
{\bkmkend AAAAAAABVR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 49 of file pthread_key.c.}\par
{
References __pthread_keys, errno, PTHREAD_KEYS_MAX, and __pthread_key::value.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 49                                                                      \{\par
50     if(key > PTHREAD_KEYS_MAX) \{\par
51         errno = EINVAL;\par
52         return 1;\par
53     \}\par
54 \par
55     if(__pthread_keys[key].used == 0) \{\par
56         errno = EINVAL;\par
57         return 1;\par
58     \}\par
59 \par
60     __pthread_keys[key].value = (void*) value;\par
61     return 0;\par
62 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v __pthread_keys\:pthread_key.c}
{\xe \v pthread_key.c\:__pthread_keys}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PRIVATE} {\b __pthread_key_t} __pthread_keys[{\b PTHREAD_KEYS_MAX}] = \{ \}}}
\par
{\bkmkstart AAAAAAABVS}
{\bkmkend AAAAAAABVS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 7 of file pthread_key.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
usr/src/libpthread/src/pthread_mutex.c File Reference\par \pard\plain 
{\tc\tcl2 \v usr/src/libpthread/src/pthread_mutex.c}
{\xe \v usr/src/libpthread/src/pthread_mutex.c}
{\bkmkstart AAAAAAABVT}
{\bkmkend AAAAAAABVT}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
{\f2 #include <time.h>}\par
{\f2 #include <pthread.h>}\par
{\f2 #include "pthread_internal.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PRIVATE} int {\b __locked_mtx} ({\b pthread_mutex_t} *mutex)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_mutex_init} ({\b pthread_mutex_t} *mutex, const {\b pthread_mutexattr_t} *attr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_mutex_destroy} ({\b pthread_mutex_t} *mutex)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_mutex_lock} ({\b pthread_mutex_t} *mutex)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_mutex_timedlock} ({\b pthread_mutex_t} *mutex, const struct timespec *abstime)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_mutex_trylock} ({\b pthread_mutex_t} *mutex)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_mutex_unlock} ({\b pthread_mutex_t} *mutex)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v __locked_mtx\:pthread_mutex.c}
{\xe \v pthread_mutex.c\:__locked_mtx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PRIVATE} int __locked_mtx ({\b pthread_mutex_t} * {\i mutex})}}
\par
{\bkmkstart AAAAAAABVU}
{\bkmkend AAAAAAABVU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9 of file pthread_mutex.c.}\par
{
References pthread_mutex::lock, pthread_mutex_unlock(), and pthread_mutex::time.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 9                                                  \{\par
10     if(mutex->time > 0) \{\par
11         if(time(NULL) < mutex->time)\par
12             return 1;\par
13         else \{\par
14             pthread_mutex_unlock(mutex);\par
15             mutex->time = 0;\par
16         \}\par
17     \}\par
18 \par
19 \par
20     if(mutex->lock == 1)\par
21         return 1;\par
22 \par
23     return 0;\par
24 \}\par
}
}
{\xe \v pthread_mutex_destroy\:pthread_mutex.c}
{\xe \v pthread_mutex.c\:pthread_mutex_destroy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_mutex_destroy ({\b pthread_mutex_t} * {\i mutex})}}
\par
{\bkmkstart AAAAAAABVV}
{\bkmkend AAAAAAABVV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 46 of file pthread_mutex.c.}\par
{
References errno, pthread_mutex::event, pthread_mutex::kind, pthread_mutex::lock, pthread_mutex::owner, pthread_mutex::recursion, and pthread_mutex::time.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 46                                                          \{\par
47     if(!mutex) \{\par
48         errno = EINVAL;\par
49         return 1;\par
50     \}\par
51 \par
52     if(mutex->lock == 1) \{\par
53         errno = EBUSY;\par
54         return 1;\par
55     \}\par
56 \par
57     mutex->lock = 0;\par
58     mutex->recursion = 0;\par
59     mutex->kind = 0;\par
60     mutex->owner = 0;\par
61     mutex->event = 0;\par
62     mutex->time = 0;\par
63 \par
64     return 0;\par
65 \}\par
}
}
{\xe \v pthread_mutex_init\:pthread_mutex.c}
{\xe \v pthread_mutex.c\:pthread_mutex_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_mutex_init ({\b pthread_mutex_t} * {\i mutex}, const {\b pthread_mutexattr_t} * {\i attr})}}
\par
{\bkmkstart AAAAAAABVW}
{\bkmkend AAAAAAABVW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 26 of file pthread_mutex.c.}\par
{
References errno, pthread_mutex::event, pthread_mutexattr::kind, pthread_mutex::kind, pthread_mutex::lock, pthread_mutex::owner, PTHREAD_MUTEX_DEFAULT, pthread_mutex::recursion, and pthread_mutex::time.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 26                                                                                        \{\par
27     if(!mutex) \{\par
28         errno = EINVAL;\par
29         return 1;\par
30     \}\par
31 \par
32     mutex->lock = 0;\par
33     mutex->recursion = 0;\par
34     mutex->kind = PTHREAD_MUTEX_DEFAULT;\par
35     mutex->owner = 0;\par
36     mutex->event = 0;\par
37     mutex->time = 0;\par
38 \par
39     if(attr)\par
40         mutex->kind = attr->kind;\par
41 \par
42     return 0;\par
43 \}\par
}
}
{\xe \v pthread_mutex_lock\:pthread_mutex.c}
{\xe \v pthread_mutex.c\:pthread_mutex_lock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_mutex_lock ({\b pthread_mutex_t} * {\i mutex})}}
\par
{\bkmkstart AAAAAAABVX}
{\bkmkend AAAAAAABVX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 67 of file pthread_mutex.c.}\par
{
References __locked_mtx(), errno, pthread_mutex::kind, pthread_mutex::lock, pthread_mutex::owner, PTHREAD_MUTEX_ERRORCHECK, PTHREAD_MUTEX_RECURSIVE, pthread_self(), pthread_mutex::recursion, and sched_yield().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 67                                                       \{\par
68     if(!mutex) \{\par
69         errno = EINVAL;\par
70         return 1;\par
71     \}\par
72 \par
73     if(mutex->owner != pthread_self()) \{\par
74         while(__locked_mtx(mutex))\par
75             sched_yield();\par
76         \par
77         mutex->owner = pthread_self();\par
78         mutex->recursion = 0;\par
79         mutex->lock = 1;\par
80     \} else if(mutex->kind == PTHREAD_MUTEX_ERRORCHECK) \{\par
81         errno = EDEADLK;\par
82         return 1;\par
83     \}\par
84 \par
85     if(mutex->kind == PTHREAD_MUTEX_RECURSIVE)\par
86         mutex->recursion += 1;\par
87 \par
88     return 0;\par
89 \}\par
}
}
{\xe \v pthread_mutex_timedlock\:pthread_mutex.c}
{\xe \v pthread_mutex.c\:pthread_mutex_timedlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_mutex_timedlock ({\b pthread_mutex_t} * {\i mutex}, const struct timespec * {\i abstime})}}
\par
{\bkmkstart AAAAAAABVY}
{\bkmkend AAAAAAABVY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 92 of file pthread_mutex.c.}\par
{
References errno, pthread_mutex_lock(), and pthread_mutex::time.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 92                                                                                            \{\par
93     if(abstime == NULL) \{\par
94         errno = EINVAL;\par
95         return 1;\par
96     \}\par
97 \par
98     if(pthread_mutex_lock(mutex) == 0)\par
99         mutex->time = time(NULL) + abstime->tv_sec;\par
100     else\par
101         return 1;\par
102 \par
103     return 0;\par
104 \}\par
}
}
{\xe \v pthread_mutex_trylock\:pthread_mutex.c}
{\xe \v pthread_mutex.c\:pthread_mutex_trylock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_mutex_trylock ({\b pthread_mutex_t} * {\i mutex})}}
\par
{\bkmkstart AAAAAAABVZ}
{\bkmkend AAAAAAABVZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 107 of file pthread_mutex.c.}\par
{
References __locked_mtx(), errno, pthread_mutex::kind, pthread_mutex::lock, pthread_mutex::owner, PTHREAD_MUTEX_ERRORCHECK, PTHREAD_MUTEX_RECURSIVE, pthread_self(), and pthread_mutex::recursion.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 107                                                          \{\par
108     if(!mutex) \{\par
109         errno = EINVAL;\par
110         return 1;\par
111     \}\par
112 \par
113     if(mutex->owner != pthread_self()) \{\par
114         if(__locked_mtx(mutex)) \{\par
115             errno = EBUSY;\par
116             return 1;\par
117         \}\par
118 \par
119         mutex->owner = pthread_self();\par
120         mutex->recursion = 0;\par
121         mutex->lock = 1;\par
122     \} else if(mutex->kind == PTHREAD_MUTEX_ERRORCHECK) \{\par
123         errno = EDEADLK;\par
124         return 1;\par
125     \}\par
126 \par
127     if(mutex->kind == PTHREAD_MUTEX_RECURSIVE)\par
128         mutex->recursion += 1;\par
129 \par
130     return 0;\par
131 \}\par
}
}
{\xe \v pthread_mutex_unlock\:pthread_mutex.c}
{\xe \v pthread_mutex.c\:pthread_mutex_unlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_mutex_unlock ({\b pthread_mutex_t} * {\i mutex})}}
\par
{\bkmkstart AAAAAAABWA}
{\bkmkend AAAAAAABWA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 133 of file pthread_mutex.c.}\par
{
References errno, pthread_mutex::kind, pthread_mutex::lock, pthread_mutex::owner, PTHREAD_MUTEX_ERRORCHECK, PTHREAD_MUTEX_RECURSIVE, pthread_self(), and pthread_mutex::recursion.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 133                                                         \{\par
134     if(!mutex) \{\par
135         errno = EINVAL;\par
136         return 1;\par
137     \}\par
138 \par
139     if(mutex->owner == pthread_self()) \{\par
140         if(mutex->kind == PTHREAD_MUTEX_RECURSIVE) \{\par
141             if(--(mutex->recursion))\par
142                 return 0;\par
143         \}\par
144 \par
145         mutex->owner = 0;\par
146         mutex->lock = 0;\par
147     \} else if(mutex->kind == PTHREAD_MUTEX_ERRORCHECK) \{\par
148         errno = EPERM;\par
149         return 1;\par
150     \}\par
151 \par
152     return 0;\par
153 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
usr/src/libpthread/src/pthread_mutexattr.c File Reference\par \pard\plain 
{\tc\tcl2 \v usr/src/libpthread/src/pthread_mutexattr.c}
{\xe \v usr/src/libpthread/src/pthread_mutexattr.c}
{\bkmkstart AAAAAAABWB}
{\bkmkend AAAAAAABWB}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
{\f2 #include <pthread.h>}\par
{\f2 #include "pthread_internal.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_mutexattr_init} ({\b pthread_mutexattr_t} *attr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_mutexattr_destroy} ({\b pthread_mutexattr_t} *attr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_mutexattr_getpshared} (const {\b pthread_mutexattr_t} *attr, int *pshared)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_mutexattr_setpshared} ({\b pthread_mutexattr_t} *attr, int pshared)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_mutexattr_gettype} ({\b pthread_mutexattr_t} *attr, int *kind)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_mutexattr_settype} ({\b pthread_mutexattr_t} *attr, int kind)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v pthread_mutexattr_destroy\:pthread_mutexattr.c}
{\xe \v pthread_mutexattr.c\:pthread_mutexattr_destroy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_mutexattr_destroy ({\b pthread_mutexattr_t} * {\i attr})}}
\par
{\bkmkstart AAAAAAABWC}
{\bkmkend AAAAAAABWC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 20 of file pthread_mutexattr.c.}\par
{
References errno, pthread_mutexattr::kind, and pthread_mutexattr::pshared.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20                                                                 \{\par
21     if(!attr) \{\par
22         errno = EINVAL;\par
23         return 1;\par
24     \}\par
25 \par
26     attr->pshared = 0;\par
27     attr->kind = 0;\par
28     \par
29     return 0;\par
30 \}\par
}
}
{\xe \v pthread_mutexattr_getpshared\:pthread_mutexattr.c}
{\xe \v pthread_mutexattr.c\:pthread_mutexattr_getpshared}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_mutexattr_getpshared (const {\b pthread_mutexattr_t} * {\i attr}, int * {\i pshared})}}
\par
{\bkmkstart AAAAAAABWD}
{\bkmkend AAAAAAABWD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 32 of file pthread_mutexattr.c.}\par
{
References errno, and pthread_mutexattr::pshared.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 32                                                                                        \{\par
33     if(!attr) \{\par
34         errno = EINVAL;\par
35         return 1;\par
36     \}\par
37 \par
38     *pshared = attr->pshared;\par
39     return 0;\par
40 \}\par
}
}
{\xe \v pthread_mutexattr_gettype\:pthread_mutexattr.c}
{\xe \v pthread_mutexattr.c\:pthread_mutexattr_gettype}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_mutexattr_gettype ({\b pthread_mutexattr_t} * {\i attr}, int * {\i kind})}}
\par
{\bkmkstart AAAAAAABWE}
{\bkmkend AAAAAAABWE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 52 of file pthread_mutexattr.c.}\par
{
References errno, and pthread_mutexattr::kind.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 52                                                                            \{\par
53     if(!attr) \{\par
54         errno = EINVAL;\par
55         return 1;\par
56     \}\par
57 \par
58     *kind = attr->kind;\par
59     return 0;\par
60 \}\par
}
}
{\xe \v pthread_mutexattr_init\:pthread_mutexattr.c}
{\xe \v pthread_mutexattr.c\:pthread_mutexattr_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_mutexattr_init ({\b pthread_mutexattr_t} * {\i attr})}}
\par
{\bkmkstart AAAAAAABWF}
{\bkmkend AAAAAAABWF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 8 of file pthread_mutexattr.c.}\par
{
References errno, pthread_mutexattr::kind, pthread_mutexattr::pshared, and PTHREAD_MUTEX_DEFAULT.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 8                                                              \{\par
9     if(!attr) \{\par
10         errno = EINVAL;\par
11         return 1;\par
12     \}\par
13 \par
14     attr->pshared = 0;\par
15     attr->kind = PTHREAD_MUTEX_DEFAULT;\par
16     \par
17     return 0;\par
18 \}\par
}
}
{\xe \v pthread_mutexattr_setpshared\:pthread_mutexattr.c}
{\xe \v pthread_mutexattr.c\:pthread_mutexattr_setpshared}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_mutexattr_setpshared ({\b pthread_mutexattr_t} * {\i attr}, int {\i pshared})}}
\par
{\bkmkstart AAAAAAABWG}
{\bkmkend AAAAAAABWG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 42 of file pthread_mutexattr.c.}\par
{
References errno, and pthread_mutexattr::pshared.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 42                                                                                 \{\par
43     if(!attr) \{\par
44         errno = EINVAL;\par
45         return 1;\par
46     \}\par
47 \par
48     attr->pshared = pshared;\par
49     return 0;\par
50 \}\par
}
}
{\xe \v pthread_mutexattr_settype\:pthread_mutexattr.c}
{\xe \v pthread_mutexattr.c\:pthread_mutexattr_settype}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_mutexattr_settype ({\b pthread_mutexattr_t} * {\i attr}, int {\i kind})}}
\par
{\bkmkstart AAAAAAABWH}
{\bkmkend AAAAAAABWH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 62 of file pthread_mutexattr.c.}\par
{
References errno, and pthread_mutexattr::kind.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 62                                                                           \{\par
63     if(!attr) \{\par
64         errno = EINVAL;\par
65         return 1;\par
66     \}\par
67 \par
68     attr->kind = kind;\par
69     return 0;\par
70 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
usr/src/libpthread/src/pthread_once.c File Reference\par \pard\plain 
{\tc\tcl2 \v usr/src/libpthread/src/pthread_once.c}
{\xe \v usr/src/libpthread/src/pthread_once.c}
{\bkmkstart AAAAAAABWI}
{\bkmkend AAAAAAABWI}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
{\f2 #include <pthread.h>}\par
{\f2 #include "pthread_internal.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_once} ({\b pthread_once_t} *once_control, void(*init_routine)(void))\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v pthread_once\:pthread_once.c}
{\xe \v pthread_once.c\:pthread_once}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int {\b pthread_once} ({\b pthread_once_t} * {\i once_control}, void(*)(void) {\i init_routine})}}
\par
{\bkmkstart AAAAAAABWJ}
{\bkmkend AAAAAAABWJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 7 of file pthread_once.c.}\par
{
References errno.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7                                                                                   \{\par
8     errno = ENOSYS;\par
9     return 1;\par
10 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
usr/src/libpthread/src/pthread_queue.c File Reference\par \pard\plain 
{\tc\tcl2 \v usr/src/libpthread/src/pthread_queue.c}
{\xe \v usr/src/libpthread/src/pthread_queue.c}
{\bkmkstart AAAAAAABWK}
{\bkmkend AAAAAAABWK}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "pthread_internal.h"}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <string.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} void {\b __pthread_init_queue} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PRIVATE} {\b pthread_context_t} {\b __current_thread}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} {\b pthread_context_t} * {\b __pthread_queue} = &{\b __current_thread}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} {\b uint32_t} {\b __pthread_counts} = 1\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v __pthread_init_queue\:pthread_queue.c}
{\xe \v pthread_queue.c\:__pthread_init_queue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} void __pthread_init_queue (void )}}
\par
{\bkmkstart AAAAAAABWL}
{\bkmkend AAAAAAABWL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 12 of file pthread_queue.c.}\par
{
References __current_thread, __os_gettid, pthread_context::attr, pthread_context::cond, pthread_once::done, pthread_context::entry, pthread_context::exitval, pthread_context::next, pthread_context::once, pthread_context::param, pthread_once::started, and pthread_context::tid.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12                                    \{\par
13     if(__current_thread.tid)\par
14         return;\par
15 \par
16     __current_thread.tid = __os_gettid();\par
17     __current_thread.entry = NULL;\par
18     __current_thread.param = NULL;\par
19     __current_thread.exitval = NULL;\par
20     __current_thread.once.done = 0;\par
21     __current_thread.once.started = -1;\par
22     __current_thread.cond = NULL;\par
23     __current_thread.next = NULL;\par
24 \par
25     memset(&__current_thread.attr, 0, sizeof(pthread_attr_t));\par
26 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v __current_thread\:pthread_queue.c}
{\xe \v pthread_queue.c\:__current_thread}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PRIVATE} {\b pthread_context_t} __current_thread}}
\par
{\bkmkstart AAAAAAABWM}
{\bkmkend AAAAAAABWM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 6 of file pthread_queue.c.}\par
}
{\xe \v __pthread_counts\:pthread_queue.c}
{\xe \v pthread_queue.c\:__pthread_counts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} {\b uint32_t} __pthread_counts = 1}}
\par
{\bkmkstart AAAAAAABWN}
{\bkmkend AAAAAAABWN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9 of file pthread_queue.c.}\par
}
{\xe \v __pthread_queue\:pthread_queue.c}
{\xe \v pthread_queue.c\:__pthread_queue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} {\b pthread_context_t}* __pthread_queue = &{\b __current_thread}}}
\par
{\bkmkstart AAAAAAABWO}
{\bkmkend AAAAAAABWO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 8 of file pthread_queue.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
usr/src/libpthread/src/pthread_rwlock.c File Reference\par \pard\plain 
{\tc\tcl2 \v usr/src/libpthread/src/pthread_rwlock.c}
{\xe \v usr/src/libpthread/src/pthread_rwlock.c}
{\bkmkstart AAAAAAABWP}
{\bkmkend AAAAAAABWP}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
{\f2 #include <sched.h>}\par
{\f2 #include <time.h>}\par
{\f2 #include <pthread.h>}\par
{\f2 #include "pthread_internal.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_rwlock_init} ({\b pthread_rwlock_t} *{\b lock}, const {\b pthread_rwlockattr_t} *attr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_rwlock_destroy} ({\b pthread_rwlock_t} *{\b lock})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_rwlock_tryrdlock} ({\b pthread_rwlock_t} *{\b lock})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_rwlock_trywrlock} ({\b pthread_rwlock_t} *{\b lock})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_rwlock_rdlock} ({\b pthread_rwlock_t} *{\b lock})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_rwlock_timedrdlock} ({\b pthread_rwlock_t} *{\b lock}, const struct timespec *abstime)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_rwlock_wrlock} ({\b pthread_rwlock_t} *{\b lock})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_rwlock_timedwrlock} ({\b pthread_rwlock_t} *{\b lock}, const struct timespec *abstime)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_rwlock_unlock} ({\b pthread_rwlock_t} *{\b lock})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v pthread_rwlock_destroy\:pthread_rwlock.c}
{\xe \v pthread_rwlock.c\:pthread_rwlock_destroy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_rwlock_destroy ({\b pthread_rwlock_t} * {\i lock})}}
\par
{\bkmkstart AAAAAAABWQ}
{\bkmkend AAAAAAABWQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 34 of file pthread_rwlock.c.}\par
{
References errno, pthread_rwlock::exclusive_waiters, pthread_rwlock::num_exclusive_waiters, pthread_rwlock::num_shared_waiters, pthread_rwlock::owner, pthread_mutex_destroy(), pthread_self(), pthread_rwlock::rdmutex, pthread_rwlock::shared_waiters, and pthread_rwlock::wrmutex.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 34                                                           \{\par
35     if(lock == NULL) \{\par
36         errno = EINVAL;\par
37         return 1;\par
38     \}\par
39 \par
40     pthread_t thread = pthread_self();\par
41     if(!thread) \{\par
42         errno = EFAULT;\par
43         return 1;\par
44     \}\par
45 \par
46     if(thread != lock->owner) \{\par
47         errno = EPERM;\par
48         return 1;\par
49     \}\par
50 \par
51     pthread_mutex_destroy(&lock->rdmutex);\par
52     pthread_mutex_destroy(&lock->wrmutex);\par
53 \par
54     lock->shared_waiters = (handle_t) 0;\par
55     lock->exclusive_waiters = (handle_t) 0;\par
56     lock->num_shared_waiters = 0;\par
57     lock->num_exclusive_waiters = 0;\par
58     lock->owner = 0;\par
59     \par
60     return 0;\par
61 \}\par
}
}
{\xe \v pthread_rwlock_init\:pthread_rwlock.c}
{\xe \v pthread_rwlock.c\:pthread_rwlock_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_rwlock_init ({\b pthread_rwlock_t} * {\i lock}, const {\b pthread_rwlockattr_t} * {\i attr})}}
\par
{\bkmkstart AAAAAAABWR}
{\bkmkend AAAAAAABWR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 10 of file pthread_rwlock.c.}\par
{
References errno, pthread_rwlock::exclusive_waiters, pthread_rwlock::num_exclusive_waiters, pthread_rwlock::num_shared_waiters, pthread_rwlock::owner, pthread_mutex_init(), pthread_self(), pthread_rwlock::rdmutex, pthread_rwlock::shared_waiters, and pthread_rwlock::wrmutex.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10                                                                                          \{\par
11     if(lock == NULL) \{\par
12         errno = EINVAL;\par
13         return 1;\par
14     \}\par
15 \par
16     pthread_t thread = pthread_self();\par
17     if(!thread) \{\par
18         errno = EFAULT;\par
19         return 1;\par
20     \}\par
21 \par
22     pthread_mutex_init(&lock->rdmutex, NULL);\par
23     pthread_mutex_init(&lock->wrmutex, NULL);\par
24 \par
25     lock->shared_waiters = (handle_t) 0;\par
26     lock->exclusive_waiters = (handle_t) 0;\par
27     lock->num_shared_waiters = 0;\par
28     lock->num_exclusive_waiters = 0;\par
29     lock->owner = thread;\par
30 \par
31     return 0;\par
32 \}\par
}
}
{\xe \v pthread_rwlock_rdlock\:pthread_rwlock.c}
{\xe \v pthread_rwlock.c\:pthread_rwlock_rdlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_rwlock_rdlock ({\b pthread_rwlock_t} * {\i lock})}}
\par
{\bkmkstart AAAAAAABWS}
{\bkmkend AAAAAAABWS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 81 of file pthread_rwlock.c.}\par
{
References errno, pthread_mutex_lock(), and pthread_rwlock::rdmutex.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 81                                                          \{\par
82     if(lock == NULL) \{\par
83         errno = EINVAL;\par
84         return 1;\par
85     \}\par
86 \par
87     return pthread_mutex_lock(&lock->rdmutex);\par
88 \}\par
}
}
{\xe \v pthread_rwlock_timedrdlock\:pthread_rwlock.c}
{\xe \v pthread_rwlock.c\:pthread_rwlock_timedrdlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_rwlock_timedrdlock ({\b pthread_rwlock_t} * {\i lock}, const struct timespec * {\i abstime})}}
\par
{\bkmkstart AAAAAAABWT}
{\bkmkend AAAAAAABWT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 90 of file pthread_rwlock.c.}\par
{
References errno, pthread_mutex_timedlock(), and pthread_rwlock::rdmutex.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 90                                                                                               \{\par
91     if(lock == NULL) \{\par
92         errno = EINVAL;\par
93         return 1;\par
94     \}\par
95 \par
96     return pthread_mutex_timedlock(&lock->rdmutex, abstime);\par
97 \}\par
}
}
{\xe \v pthread_rwlock_timedwrlock\:pthread_rwlock.c}
{\xe \v pthread_rwlock.c\:pthread_rwlock_timedwrlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_rwlock_timedwrlock ({\b pthread_rwlock_t} * {\i lock}, const struct timespec * {\i abstime})}}
\par
{\bkmkstart AAAAAAABWU}
{\bkmkend AAAAAAABWU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 108 of file pthread_rwlock.c.}\par
{
References errno, pthread_mutex_timedlock(), and pthread_rwlock::wrmutex.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 108                                                                                               \{\par
109     if(lock == NULL) \{\par
110         errno = EINVAL;\par
111         return 1;\par
112     \}\par
113 \par
114     return pthread_mutex_timedlock(&lock->wrmutex, abstime);\par
115 \}\par
}
}
{\xe \v pthread_rwlock_tryrdlock\:pthread_rwlock.c}
{\xe \v pthread_rwlock.c\:pthread_rwlock_tryrdlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_rwlock_tryrdlock ({\b pthread_rwlock_t} * {\i lock})}}
\par
{\bkmkstart AAAAAAABWV}
{\bkmkend AAAAAAABWV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 63 of file pthread_rwlock.c.}\par
{
References errno, pthread_mutex_trylock(), and pthread_rwlock::rdmutex.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 63                                                             \{\par
64     if(lock == NULL) \{\par
65         errno = EINVAL;\par
66         return 1;\par
67     \}\par
68 \par
69     return pthread_mutex_trylock(&lock->rdmutex);\par
70 \}\par
}
}
{\xe \v pthread_rwlock_trywrlock\:pthread_rwlock.c}
{\xe \v pthread_rwlock.c\:pthread_rwlock_trywrlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_rwlock_trywrlock ({\b pthread_rwlock_t} * {\i lock})}}
\par
{\bkmkstart AAAAAAABWW}
{\bkmkend AAAAAAABWW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 72 of file pthread_rwlock.c.}\par
{
References errno, pthread_mutex_trylock(), and pthread_rwlock::wrmutex.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 72                                                             \{\par
73     if(lock == NULL) \{\par
74         errno = EINVAL;\par
75         return 1;\par
76     \}\par
77 \par
78     return pthread_mutex_trylock(&lock->wrmutex);\par
79 \}\par
}
}
{\xe \v pthread_rwlock_unlock\:pthread_rwlock.c}
{\xe \v pthread_rwlock.c\:pthread_rwlock_unlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_rwlock_unlock ({\b pthread_rwlock_t} * {\i lock})}}
\par
{\bkmkstart AAAAAAABWX}
{\bkmkend AAAAAAABWX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 117 of file pthread_rwlock.c.}\par
{
References errno, pthread_mutex_unlock(), pthread_rwlock::rdmutex, and pthread_rwlock::wrmutex.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 117                                                          \{\par
118     if(lock == NULL) \{\par
119         errno = EINVAL;\par
120         return 1;\par
121     \}\par
122 \par
123     if(pthread_mutex_unlock(&lock->rdmutex) != 0)\par
124         return 1;\par
125 \par
126     if(pthread_mutex_unlock(&lock->wrmutex) != 0)\par
127         return 1;\par
128 \par
129     return 0;\par
130 \}\par
}
}
{\xe \v pthread_rwlock_wrlock\:pthread_rwlock.c}
{\xe \v pthread_rwlock.c\:pthread_rwlock_wrlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_rwlock_wrlock ({\b pthread_rwlock_t} * {\i lock})}}
\par
{\bkmkstart AAAAAAABWY}
{\bkmkend AAAAAAABWY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 99 of file pthread_rwlock.c.}\par
{
References errno, pthread_mutex_lock(), and pthread_rwlock::wrmutex.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 99                                                          \{\par
100     if(lock == NULL) \{\par
101         errno = EINVAL;\par
102         return 1;\par
103     \}\par
104 \par
105     return pthread_mutex_lock(&lock->wrmutex);\par
106 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
usr/src/libpthread/src/pthread_rwlockattr.c File Reference\par \pard\plain 
{\tc\tcl2 \v usr/src/libpthread/src/pthread_rwlockattr.c}
{\xe \v usr/src/libpthread/src/pthread_rwlockattr.c}
{\bkmkstart AAAAAAABWZ}
{\bkmkend AAAAAAABWZ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
{\f2 #include <sched.h>}\par
{\f2 #include <time.h>}\par
{\f2 #include <pthread.h>}\par
{\f2 #include "pthread_internal.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_rwlockattr_init} ({\b pthread_rwlockattr_t} *attr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_rwlockattr_destroy} ({\b pthread_rwlockattr_t} *attr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_rwlockattr_getpshared} (const {\b pthread_rwlockattr_t} *attr, int *pshared)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_rwlockattr_setpshared} ({\b pthread_rwlockattr_t} *attr, int pshared)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v pthread_rwlockattr_destroy\:pthread_rwlockattr.c}
{\xe \v pthread_rwlockattr.c\:pthread_rwlockattr_destroy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_rwlockattr_destroy ({\b pthread_rwlockattr_t} * {\i attr})}}
\par
{\bkmkstart AAAAAAABXA}
{\bkmkend AAAAAAABXA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 19 of file pthread_rwlockattr.c.}\par
{
References errno, and pthread_rwlockattr::pshared.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19                                                                   \{\par
20     if(attr == NULL) \{\par
21         errno = EINVAL;\par
22         return 1;\par
23     \}\par
24 \par
25     attr->pshared = 0;\par
26     return 0;\par
27 \}\par
}
}
{\xe \v pthread_rwlockattr_getpshared\:pthread_rwlockattr.c}
{\xe \v pthread_rwlockattr.c\:pthread_rwlockattr_getpshared}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_rwlockattr_getpshared (const {\b pthread_rwlockattr_t} * {\i attr}, int * {\i pshared})}}
\par
{\bkmkstart AAAAAAABXB}
{\bkmkend AAAAAAABXB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 29 of file pthread_rwlockattr.c.}\par
{
References errno, and pthread_rwlockattr::pshared.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 29                                                                                          \{\par
30     if(attr == NULL) \{\par
31         errno = EINVAL;\par
32         return 1;\par
33     \}\par
34 \par
35     if(pshared == NULL) \{\par
36         errno = EINVAL;\par
37         return 1;\par
38     \}\par
39 \par
40     *pshared = attr->pshared;\par
41     return 0;\par
42 \}\par
}
}
{\xe \v pthread_rwlockattr_init\:pthread_rwlockattr.c}
{\xe \v pthread_rwlockattr.c\:pthread_rwlockattr_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_rwlockattr_init ({\b pthread_rwlockattr_t} * {\i attr})}}
\par
{\bkmkstart AAAAAAABXC}
{\bkmkend AAAAAAABXC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9 of file pthread_rwlockattr.c.}\par
{
References errno, and pthread_rwlockattr::pshared.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 9                                                                \{\par
10     if(attr == NULL) \{\par
11         errno = EINVAL;\par
12         return 1;\par
13     \}\par
14 \par
15     attr->pshared = 0;\par
16     return 0;\par
17 \}\par
}
}
{\xe \v pthread_rwlockattr_setpshared\:pthread_rwlockattr.c}
{\xe \v pthread_rwlockattr.c\:pthread_rwlockattr_setpshared}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_rwlockattr_setpshared ({\b pthread_rwlockattr_t} * {\i attr}, int {\i pshared})}}
\par
{\bkmkstart AAAAAAABXD}
{\bkmkend AAAAAAABXD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 44 of file pthread_rwlockattr.c.}\par
{
References errno, and pthread_rwlockattr::pshared.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 44                                                                                   \{\par
45     if(attr == NULL) \{\par
46         errno = EINVAL;\par
47         return 1;\par
48     \}\par
49 \par
50     attr->pshared = pshared;\par
51     return 0;\par
52 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
usr/src/libpthread/src/pthread_sched.c File Reference\par \pard\plain 
{\tc\tcl2 \v usr/src/libpthread/src/pthread_sched.c}
{\xe \v usr/src/libpthread/src/pthread_sched.c}
{\bkmkstart AAAAAAABXE}
{\bkmkend AAAAAAABXE}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
{\f2 #include <sched.h>}\par
{\f2 #include <pthread.h>}\par
{\f2 #include "pthread_internal.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EXTERN} int {\b sched_setparam} (pid_t pid, const struct sched_param *param)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EXTERN} int {\b sched_getparam} (pid_t pid, const struct sched_param *param)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_setschedparam} ({\b pthread_t} thread, int policy, const struct sched_param *param)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_getschedparam} ({\b pthread_t} thread, int *policy, struct sched_param *param)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_setconcurrency} (int level)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_getconcurrency} (void)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v pthread_getconcurrency\:pthread_sched.c}
{\xe \v pthread_sched.c\:pthread_getconcurrency}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_getconcurrency (void )}}
\par
{\bkmkstart AAAAAAABXF}
{\bkmkend AAAAAAABXF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 57 of file pthread_sched.c.}\par
{
References pthread_context::attr, errno, pthread_attr::param, and pthread_self().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 57                                         \{\par
58     pthread_t thread = pthread_self();\par
59     if(!thread) \{\par
60         errno = ESRCH;\par
61         return 1;\par
62     \}\par
63 \par
64     pthread_context_t* ctx = (pthread_context_t*) thread;\par
65     return ctx->attr.param.sched_priority;\par
66 \}\par
}
}
{\xe \v pthread_getschedparam\:pthread_sched.c}
{\xe \v pthread_sched.c\:pthread_getschedparam}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_getschedparam ({\b pthread_t} {\i thread}, int * {\i policy}, struct sched_param * {\i param})}}
\par
{\bkmkstart AAAAAAABXG}
{\bkmkend AAAAAAABXG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 26 of file pthread_sched.c.}\par
{
References errno, sched_getparam(), and pthread_context::tid.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 26                                                                                            \{\par
27     if(!thread) \{\par
28         errno = EINVAL;\par
29         return 1;\par
30     \}\par
31 \par
32     if(param == NULL) \{\par
33         errno = EINVAL;\par
34         return 1;\par
35     \}\par
36     \par
37     pthread_context_t* ctx = (pthread_context_t*) thread;\par
38     if((*policy = sched_getparam(ctx->tid, param)) != -1)\par
39         return 0;\par
40     \par
41     return 1;\par
42 \}\par
}
}
{\xe \v pthread_setconcurrency\:pthread_sched.c}
{\xe \v pthread_sched.c\:pthread_setconcurrency}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_setconcurrency (int {\i level})}}
\par
{\bkmkstart AAAAAAABXH}
{\bkmkend AAAAAAABXH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 44 of file pthread_sched.c.}\par
{
References pthread_context::attr, errno, pthread_attr::param, and pthread_self().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 44                                              \{\par
45     pthread_t thread = pthread_self();\par
46     if(!thread) \{\par
47         errno = ESRCH;\par
48         return 1;\par
49     \}\par
50 \par
51     pthread_context_t* ctx = (pthread_context_t*) thread;\par
52     ctx->attr.param.sched_priority = level;\par
53 \par
54     return 0;\par
55 \}\par
}
}
{\xe \v pthread_setschedparam\:pthread_sched.c}
{\xe \v pthread_sched.c\:pthread_setschedparam}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_setschedparam ({\b pthread_t} {\i thread}, int {\i policy}, const struct sched_param * {\i param})}}
\par
{\bkmkstart AAAAAAABXI}
{\bkmkend AAAAAAABXI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 11 of file pthread_sched.c.}\par
{
References errno, sched_setparam(), and pthread_context::tid.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11                                                                                                 \{\par
12     if(!thread) \{\par
13         errno = EINVAL;\par
14         return 1;\par
15     \}\par
16 \par
17     if(param == NULL) \{\par
18         errno = EINVAL;\par
19         return 1;\par
20     \}\par
21 \par
22     pthread_context_t* ctx = (pthread_context_t*) thread;\par
23     return sched_setparam(ctx->tid, param);\par
24 \}\par
}
}
{\xe \v sched_getparam\:pthread_sched.c}
{\xe \v pthread_sched.c\:sched_getparam}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b EXTERN} int sched_getparam (pid_t {\i pid}, const struct sched_param * {\i param})}}
\par
{\bkmkstart AAAAAAABXJ}
{\bkmkend AAAAAAABXJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v sched_setparam\:pthread_sched.c}
{\xe \v pthread_sched.c\:sched_setparam}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b EXTERN} int sched_setparam (pid_t {\i pid}, const struct sched_param * {\i param})}}
\par
{\bkmkstart AAAAAAABXK}
{\bkmkend AAAAAAABXK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 35 of file sched.c.}\par
{
References errno.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 35                                                                \{\par
36     if(param == NULL) \{\par
37         errno = EINVAL;\par
38         return -1;\par
39     \}\par
40 \par
41     if(pid < 0) \{\par
42         errno = EINVAL;\par
43         return -1;\par
44     \}\par
45 \par
46     errno = ENOSYS;\par
47     return -1;\par
48 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
usr/src/libpthread/src/pthread_self.c File Reference\par \pard\plain 
{\tc\tcl2 \v usr/src/libpthread/src/pthread_self.c}
{\xe \v usr/src/libpthread/src/pthread_self.c}
{\bkmkstart AAAAAAABXL}
{\bkmkend AAAAAAABXL}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
{\f2 #include <pthread.h>}\par
{\f2 #include "pthread_internal.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} {\b pthread_t} {\b pthread_self} (void)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EXTERN} {\b pthread_context_t} * {\b __pthread_queue}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v pthread_self\:pthread_self.c}
{\xe \v pthread_self.c\:pthread_self}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} {\b pthread_t} pthread_self (void )}}
\par
{\bkmkstart AAAAAAABXM}
{\bkmkend AAAAAAABXM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 10 of file pthread_self.c.}\par
{
References __os_gettid, __pthread_queue, errno, pthread_context::next, and pthread_context::tid.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10                                     \{\par
11     if(!__pthread_queue) \{\par
12         errno = ESRCH;\par
13         return 0;\par
14     \}\par
15 \par
16     int tid = __os_gettid();\par
17     pthread_context_t* tmp = __pthread_queue;\par
18     while(tmp) \{\par
19         if(tmp->tid == tid)\par
20             return (pthread_t) tmp;\par
21 \par
22         tmp = tmp->next;\par
23     \}\par
24 \par
25     errno = ESRCH;\par
26     return 0;\par
27 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v __pthread_queue\:pthread_self.c}
{\xe \v pthread_self.c\:__pthread_queue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b EXTERN} {\b pthread_context_t}* __pthread_queue}}
\par
{\bkmkstart AAAAAAABXN}
{\bkmkend AAAAAAABXN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 8 of file pthread_self.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
usr/src/libpthread/src/pthread_spin.c File Reference\par \pard\plain 
{\tc\tcl2 \v usr/src/libpthread/src/pthread_spin.c}
{\xe \v usr/src/libpthread/src/pthread_spin.c}
{\bkmkstart AAAAAAABXO}
{\bkmkend AAAAAAABXO}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
{\f2 #include <pthread.h>}\par
{\f2 #include "pthread_internal.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_spin_init} ({\b pthread_spinlock_t} *{\b lock}, int pshared)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_spin_destroy} ({\b pthread_spinlock_t} *{\b lock})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_spin_lock} ({\b pthread_spinlock_t} *{\b lock})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_spin_trylock} ({\b pthread_spinlock_t} *{\b lock})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PUBLIC} int {\b pthread_spin_unlock} ({\b pthread_spinlock_t} *{\b lock})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v pthread_spin_destroy\:pthread_spin.c}
{\xe \v pthread_spin.c\:pthread_spin_destroy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_spin_destroy ({\b pthread_spinlock_t} * {\i lock})}}
\par
{\bkmkstart AAAAAAABXP}
{\bkmkend AAAAAAABXP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 19 of file pthread_spin.c.}\par
{
References errno, pthread_spinlock::interlock, pthread_spinlock::mutex, and pthread_mutex_destroy().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19                                                           \{\par
20     if(!lock) \{\par
21         errno = EINVAL;\par
22         return 1;\par
23     \}\par
24 \par
25     lock->interlock = 0;\par
26     pthread_mutex_destroy(&lock->mutex);\par
27 \par
28     return 0;\par
29 \}\par
}
}
{\xe \v pthread_spin_init\:pthread_spin.c}
{\xe \v pthread_spin.c\:pthread_spin_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_spin_init ({\b pthread_spinlock_t} * {\i lock}, int {\i pshared})}}
\par
{\bkmkstart AAAAAAABXQ}
{\bkmkend AAAAAAABXQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 7 of file pthread_spin.c.}\par
{
References errno, pthread_spinlock::interlock, pthread_spinlock::mutex, and pthread_mutex_init().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7                                                                     \{\par
8     if(!lock) \{\par
9         errno = EINVAL;\par
10         return 1;\par
11     \}\par
12 \par
13     lock->interlock = 0;\par
14     pthread_mutex_init(&lock->mutex, NULL);\par
15 \par
16     return 0;\par
17 \}\par
}
}
{\xe \v pthread_spin_lock\:pthread_spin.c}
{\xe \v pthread_spin.c\:pthread_spin_lock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_spin_lock ({\b pthread_spinlock_t} * {\i lock})}}
\par
{\bkmkstart AAAAAAABXR}
{\bkmkend AAAAAAABXR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 31 of file pthread_spin.c.}\par
{
References errno, pthread_spinlock::interlock, pthread_spinlock::mutex, and pthread_mutex_lock().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 31                                                        \{\par
32     if(!lock) \{\par
33         errno = EINVAL;\par
34         return 1;\par
35     \}\par
36 \par
37     if(pthread_mutex_lock(&lock->mutex) == 0)\par
38         lock->interlock = 1;\par
39     else\par
40         return 1; /* errno already setted */\par
41 \par
42     return 0;\par
43 \}\par
}
}
{\xe \v pthread_spin_trylock\:pthread_spin.c}
{\xe \v pthread_spin.c\:pthread_spin_trylock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_spin_trylock ({\b pthread_spinlock_t} * {\i lock})}}
\par
{\bkmkstart AAAAAAABXS}
{\bkmkend AAAAAAABXS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 45 of file pthread_spin.c.}\par
{
References errno, pthread_spinlock::interlock, pthread_spinlock::mutex, and pthread_mutex_trylock().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 45                                                           \{\par
46     if(!lock) \{\par
47         errno = EINVAL;\par
48         return 1;\par
49     \}\par
50 \par
51     if(pthread_mutex_trylock(&lock->mutex) == 0)\par
52         lock->interlock = 1;\par
53     else\par
54         return 1; /* errno already setted */\par
55 \par
56     return 0;\par
57 \}\par
}
}
{\xe \v pthread_spin_unlock\:pthread_spin.c}
{\xe \v pthread_spin.c\:pthread_spin_unlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PUBLIC} int pthread_spin_unlock ({\b pthread_spinlock_t} * {\i lock})}}
\par
{\bkmkstart AAAAAAABXT}
{\bkmkend AAAAAAABXT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 59 of file pthread_spin.c.}\par
{
References errno, pthread_spinlock::interlock, pthread_spinlock::mutex, and pthread_mutex_unlock().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 59                                                          \{\par
60     if(!lock) \{\par
61         errno = EINVAL;\par
62         return 1;\par
63     \}\par
64 \par
65     if(pthread_mutex_unlock(&lock->mutex) == 0)\par
66         lock->interlock = 0;\par
67     else\par
68         return 1; /* errno already setted */\par
69     \par
70     return 0;\par
71 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
usr/src/libssp/src/chkfail.c File Reference\par \pard\plain 
{\tc\tcl2 \v usr/src/libssp/src/chkfail.c}
{\xe \v usr/src/libssp/src/chkfail.c}
{\bkmkstart AAAAAAABXU}
{\bkmkend AAAAAAABXU}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
{\f2 #include <stddef.h>}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <string.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b STACK_CHK_GUARD}\~ 0xe2dee396\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b __attribute__} ((noreturn))\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b __stack_chk_guard} = (void*) {\b STACK_CHK_GUARD}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v STACK_CHK_GUARD\:chkfail.c}
{\xe \v chkfail.c\:STACK_CHK_GUARD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define STACK_CHK_GUARD\~ 0xe2dee396}}
\par
{\bkmkstart AAAAAAABXV}
{\bkmkend AAAAAAABXV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 10 of file chkfail.c.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v __attribute__\:chkfail.c}
{\xe \v chkfail.c\:__attribute__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__attribute__ ((noreturn) )}}
\par
{\bkmkstart AAAAAAABXW}
{\bkmkend AAAAAAABXW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 18 of file chkfail.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19                             \{\par
20 \par
21 #ifdef __GNU_LIBRARY__\par
22     extern char* __progname;\par
23 #else\par
24     static const char __progname[] = "panic";\par
25 #endif\par
26 \par
27     fprintf(stderr, "%s: stack smashing detected\\n", __progname);\par
28     abort();\par
29 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v __stack_chk_guard\:chkfail.c}
{\xe \v chkfail.c\:__stack_chk_guard}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* __stack_chk_guard = (void*) {\b STACK_CHK_GUARD}}}
\par
{\bkmkstart AAAAAAABXX}
{\bkmkend AAAAAAABXX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 15 of file chkfail.c.}\par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Index\par 
\pard\plain 
{\tc \v Index}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}