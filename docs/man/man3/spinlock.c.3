.TH "src/spinlock.c" 3 "Wed Nov 12 2014" "Version 0.1" "aPlus" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/spinlock.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include <stdint\&.h>\fP
.br
\fC#include <aplus/spinlock\&.h>\fP
.br
\fC#include <aplus/list\&.h>\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBspinlock_lock\fP (\fBspinlock_t\fP *spin)"
.br
.RI "\fIAcquire a spinlock\&. \fP"
.ti -1c
.RI "void \fBspinlock_unlock\fP (\fBspinlock_t\fP *spin)"
.br
.RI "\fIUnlock a spinlock\&. \fP"
.ti -1c
.RI "int \fBspinlock_trylock\fP (\fBspinlock_t\fP *spin)"
.br
.RI "\fITry to acquire a spinlock\&. \fP"
.ti -1c
.RI "void \fB__spinlock_waiton\fP ()"
.br
.RI "\fIYield current task if a false condition was given by \fBspinlock_waiton()\fP\&. \fP"
.ti -1c
.RI "void \fB__fastlock_waiton\fP ()"
.br
.RI "\fIPut CPU in pause for a while if a false condition was given by \fBfastlock_waiton()\fP\&. \fP"
.in -1c
.SH "Function Documentation"
.PP 
.SS "void __fastlock_waiton ()"

.PP
Put CPU in pause for a while if a false condition was given by \fBfastlock_waiton()\fP\&. 
.PP
\fBSee also:\fP
.RS 4
\fBfastlock_waiton\fP 
.RE
.PP

.PP
Definition at line 76 of file spinlock\&.c\&.
.PP
References __asm__()\&.
.PP
.nf
76                          {
77     __asm__ __volatile__("pause");
78 }
.fi
.SS "void __spinlock_waiton ()"

.PP
Yield current task if a false condition was given by \fBspinlock_waiton()\fP\&. 
.PP
\fBSee also:\fP
.RS 4
\fBspinlock_waiton\fP 
.RE
.PP

.PP
Definition at line 68 of file spinlock\&.c\&.
.PP
References schedule_yield()\&.
.PP
.nf
68                          {
69     schedule_yield();
70 }
.fi
.SS "void spinlock_lock (\fBspinlock_t\fP *spin)"

.PP
Acquire a spinlock\&. 
.PP
\fBParameters:\fP
.RS 4
\fIspin\fP Spinlock address\&. 
.RE
.PP

.PP
Definition at line 31 of file spinlock\&.c\&.
.PP
References fastlock_waiton, SPINLOCK_FLAGS_FASTLOCK, SPINLOCK_FLAGS_LOCKED, and spinlock_waiton\&.
.PP
.nf
31                                      {
32     if((*spin & SPINLOCK_FLAGS_FASTLOCK) == 0)
33         spinlock_waiton(*spin & SPINLOCK_FLAGS_LOCKED);
34     else
35         fastlock_waiton(*spin & SPINLOCK_FLAGS_LOCKED);
36 
37     *spin |= SPINLOCK_FLAGS_LOCKED;
38 }
.fi
.SS "int spinlock_trylock (\fBspinlock_t\fP *spin)"

.PP
Try to acquire a spinlock\&. 
.PP
\fBParameters:\fP
.RS 4
\fIspin\fP Spinlock address\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
0 for success else -1\&. 
.RE
.PP

.PP
Definition at line 55 of file spinlock\&.c\&.
.PP
References SPINLOCK_FLAGS_LOCKED\&.
.PP
.nf
55                                        {
56     if(*spin & SPINLOCK_FLAGS_LOCKED)
57         return -1;
58         
59     *spin |= SPINLOCK_FLAGS_LOCKED;
60     return 0;
61 }
.fi
.SS "void spinlock_unlock (\fBspinlock_t\fP *spin)"

.PP
Unlock a spinlock\&. 
.PP
\fBParameters:\fP
.RS 4
\fIspin\fP Spinlock address\&. 
.RE
.PP

.PP
Definition at line 45 of file spinlock\&.c\&.
.PP
References SPINLOCK_FLAGS_LOCKED\&.
.PP
.nf
45                                        {
46     *spin &= ~SPINLOCK_FLAGS_LOCKED;
47 }
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for aPlus from the source code\&.
