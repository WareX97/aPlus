.TH "src/bufio.c" 3 "Fri Nov 14 2014" "Version 0.1" "aPlus" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/bufio.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include <aplus\&.h>\fP
.br
\fC#include <aplus/list\&.h>\fP
.br
\fC#include <aplus/spinlock\&.h>\fP
.br
\fC#include <aplus/mm\&.h>\fP
.br
\fC#include <aplus/bufio\&.h>\fP
.br
\fC#include <aplus/task\&.h>\fP
.br
\fC#include <stddef\&.h>\fP
.br
\fC#include <stdint\&.h>\fP
.br
\fC#include <sys/types\&.h>\fP
.br
\fC#include <stdio\&.h>\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBbufio_init\fP ()"
.br
.RI "\fIBufIO initialization\&. \fP"
.ti -1c
.RI "void \fBbufio_free_unused\fP ()"
.br
.RI "\fIFree al unused buffers\&. \fP"
.ti -1c
.RI "\fBbufio_t\fP * \fBbufio_alloc\fP (size_t \fBsize\fP)"
.br
.RI "\fIAlloc new buffer for current task\&. \fP"
.ti -1c
.RI "\fBbufio_t\fP * \fBbufio_alloc_raw\fP (void *raw, size_t \fBsize\fP)"
.br
.RI "\fICreate new buffer from allocated data for current task\&. \fP"
.ti -1c
.RI "void \fBbufio_free\fP (\fBbufio_t\fP *buf)"
.br
.RI "\fIFree and remove buffer\&. \fP"
.ti -1c
.RI "int \fBbufio_seek\fP (\fBbufio_t\fP *buf, off_t \fBoffset\fP, int dir)"
.br
.RI "\fISets the position indicator associated with the bufio descriptor to a new position\&. \fP"
.ti -1c
.RI "int \fBbufio_tell\fP (\fBbufio_t\fP *buf)"
.br
.RI "\fIReturns the current value of the position indicator of the stream\&.
.br
\&. \fP"
.ti -1c
.RI "void \fBbufio_clear\fP (\fBbufio_t\fP *buf)"
.br
.RI "\fIClear entire stream of the buffer descriptor\&. \fP"
.ti -1c
.RI "int \fBbufio_read\fP (\fBbufio_t\fP *buf, void *ptr, size_t len)"
.br
.RI "\fIThis function shall attempt to read nbyte bytes from the stream associated with the bufio descriptor, buf, into the buffer pointed to by ptr\&. \fP"
.ti -1c
.RI "int \fBbufio_write\fP (\fBbufio_t\fP *buf, void *ptr, size_t len)"
.br
.RI "\fIThis function shall attempt to write nbyte bytes into the stream associated with the bufio descriptor, buf, from the buffer pointed to by ptr\&. \fP"
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "static \fBlist_t\fP * \fBlist_buffers\fP"
.br
.RI "\fIList of allocated buffers\&. \fP"
.ti -1c
.RI "static uint64_t \fBbuffers_length\fP"
.br
.RI "\fIAllocated RAM of all buffers\&. \fP"
.ti -1c
.RI "\fBtask_t\fP * \fBcurrent_task\fP"
.br
.RI "\fICurrent task address\&. \fP"
.in -1c
.SH "Function Documentation"
.PP 
.SS "\fBbufio_t\fP* bufio_alloc (size_tsize)"

.PP
Alloc new buffer for current task\&. 
.PP
\fBParameters:\fP
.RS 4
\fIsize\fP Size in Bytes of data\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
bufio descriptor\&. 
.RE
.PP

.PP
Definition at line 63 of file bufio\&.c\&.
.PP
References buffers_length, current_task, kmalloc(), list_add(), lock, bufio::offset, bufio::raw, bufio::size, size, bufio::task, bufio::type, and unlock\&.
.PP
.nf
63                                   {
64     void* addr = (void*) kmalloc(size);
65     if(!addr)
66         return 0;
67         
68     lock(); 
69     buffers_length += size;
70 
71 
72     bufio_t* buf = (bufio_t*) kmalloc(size);
73     buf->raw = addr;
74     buf->size = size;
75     buf->type = 0;
76     buf->offset = (off_t) 0;
77     buf->task = current_task;
78 
79 
80     list_add(list_buffers, (listval_t) buf);
81 
82     unlock();
83     return buf;
84 }
.fi
.SS "\fBbufio_t\fP* bufio_alloc_raw (void *raw, size_tsize)"

.PP
Create new buffer from allocated data for current task\&. 
.PP
\fBParameters:\fP
.RS 4
\fIraw\fP Buffer allocated address\&. 
.br
\fIsize\fP Size in Bytes of data\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
bufio descriptor\&. 
.RE
.PP

.PP
Definition at line 92 of file bufio\&.c\&.
.PP
References buffers_length, current_task, kmalloc(), list_add(), lock, bufio::offset, bufio::raw, bufio::size, size, bufio::task, bufio::type, and unlock\&.
.PP
.nf
92                                                  {
93     if(!raw)
94         return 0;
95 
96     lock(); 
97 
98     buffers_length += size;
99 
100     bufio_t* buf = (bufio_t*) kmalloc(size);
101     buf->raw = raw;
102     buf->size = size;
103     buf->type = 0;
104     buf->offset = (off_t) 0;
105     buf->task = current_task;
106     
107     list_add(list_buffers, (listval_t) buf);
108 
109     unlock();
110     
111     return buf;
112 }
.fi
.SS "void bufio_clear (\fBbufio_t\fP *buf)"

.PP
Clear entire stream of the buffer descriptor\&. 
.PP
\fBParameters:\fP
.RS 4
\fIbuf\fP Pointer to a bufio descriptor\&. 
.RE
.PP

.PP
Definition at line 186 of file bufio\&.c\&.
.PP
References bufio::lock, bufio::raw, bufio::size, spinlock_lock(), and spinlock_unlock()\&.
.PP
.nf
186                                {
187     spinlock_lock(&buf->lock);
188     memset(buf->raw, 0, buf->size);
189     spinlock_unlock(&buf->lock);
190 }
.fi
.SS "void bufio_free (\fBbufio_t\fP *buf)"

.PP
Free and remove buffer\&. 
.PP
\fBParameters:\fP
.RS 4
\fIbuf\fP bufio descriptor\&. 
.RE
.PP

.PP
Definition at line 118 of file bufio\&.c\&.
.PP
References buffers_length, kfree(), list_remove(), lock, bufio::raw, bufio::size, and unlock\&.
.PP
.nf
118                               {
119     lock();
120     buffers_length -= buf->size;
121     
122     kfree(buf->raw);
123     kfree(buf);
124     
125     list_remove(list_buffers, (listval_t) buf);
126     
127     
128     unlock();
129 }
.fi
.SS "void bufio_free_unused ()"

.PP
Free al unused buffers\&. 
.PP
Definition at line 41 of file bufio\&.c\&.
.PP
References list_clone(), list_destroy, list_foreach, list_init, and value\&.
.PP
.nf
41                          {
42 
43     list_t* tmp;
44     list_init(tmp);
45     list_clone(tmp, list_buffers);
46     
47     list_foreach(value, tmp) {
48         //bufio_t* value = (bufio_t*) value;
49         
50         //if(value->task->state == TASK_STATE_DEAD)
51         //  bufio_free(value);
52     }
53     
54     list_destroy(tmp);
55 }
.fi
.SS "int bufio_init ()"

.PP
BufIO initialization\&. 
.PP
Definition at line 31 of file bufio\&.c\&.
.PP
References list_init\&.
.PP
.nf
31                  {
32     list_init(list_buffers);
33     
34     return 0;
35 }
.fi
.SS "int bufio_read (\fBbufio_t\fP *buf, void *ptr, size_tlen)"

.PP
This function shall attempt to read nbyte bytes from the stream associated with the bufio descriptor, buf, into the buffer pointed to by ptr\&. 
.PP
\fBParameters:\fP
.RS 4
\fIbuf\fP Pointer to a bufio descriptor\&. 
.br
\fIptr\fP Pointer to output buffer\&. 
.br
\fIlen\fP Size of data to read\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Upon successful completion, shall return a non-negative integer indicating the number of bytes actually read\&.
.br
 Otherwise, the functions shall return -1 and set errno to indicate the error\&. 
.RE
.PP

.PP
Definition at line 203 of file bufio\&.c\&.
.PP
References bufio::lock, bufio::offset, bufio::raw, bufio::size, spinlock_lock(), and spinlock_unlock()\&.
.PP
.nf
203                                                     {     
204     spinlock_lock(&buf->lock);
205     
206     len = (len + buf->offset > buf->size) ? (buf->size - buf->offset) : len;
207     memcpy(ptr, (void*) ((off_t) buf->raw + buf->offset), len);
208     
209     buf->offset += (off_t) len;
210     
211     spinlock_unlock(&buf->lock);
212     
213     return (int) len;
214 }
.fi
.SS "int bufio_seek (\fBbufio_t\fP *buf, off_toffset, intdir)"

.PP
Sets the position indicator associated with the bufio descriptor to a new position\&. 
.PP
\fBParameters:\fP
.RS 4
\fIbuf\fP Pointer to a bufio descriptor\&. 
.br
\fIoffset\fP Number of bytes to offset from dir\&. 
.br
\fIdir\fP Position used as reference for the offset
.br
.IP "\(bu" 2
SEEK_SET: Beginning of stream\&.
.br

.IP "\(bu" 2
SEEK_CUR: Current position of stream\&.
.br

.IP "\(bu" 2
SEEK_END: End of stream\&.
.br

.PP
.RE
.PP
\fBReturns:\fP
.RS 4
If successful return current position of stream, otherwise, it returns non-zero value\&. 
.RE
.PP

.PP
Definition at line 142 of file bufio\&.c\&.
.PP
References bufio::offset, offset, and bufio::size\&.
.PP
.nf
142                                                     {
143 
144     if(offset > buf->size)
145         return -1;
146         
147     if(dir == SEEK_CUR && (offset + buf->offset) > buf->size)
148         return -1;
149 
150     switch(dir) {
151         case SEEK_SET:
152             buf->offset = offset;
153             break;
154             
155         case SEEK_END:
156             buf->offset = buf->offset - offset;
157             break;
158             
159         case SEEK_CUR:
160             buf->offset += offset;
161             break;
162             
163         default:
164             return -1;
165     }
166     
167     return buf->offset;
168 }
.fi
.SS "int bufio_tell (\fBbufio_t\fP *buf)"

.PP
Returns the current value of the position indicator of the stream\&.
.br
\&. 
.PP
\fBParameters:\fP
.RS 4
\fIbuf\fP Pointer to a bufio descriptor\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
On success, the current value of the position indicator is returned\&.
.br
 On failure, -1L is returned\&. 
.RE
.PP

.PP
Definition at line 177 of file bufio\&.c\&.
.PP
References bufio_seek()\&.
.PP
.nf
177                              {
178     return bufio_seek(buf, 0, SEEK_CUR);
179 }
.fi
.SS "int bufio_write (\fBbufio_t\fP *buf, void *ptr, size_tlen)"

.PP
This function shall attempt to write nbyte bytes into the stream associated with the bufio descriptor, buf, from the buffer pointed to by ptr\&. 
.PP
\fBParameters:\fP
.RS 4
\fIbuf\fP Pointer to a bufio descriptor\&. 
.br
\fIptr\fP Pointer to input buffer\&. 
.br
\fIlen\fP Size of data to write\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Upon successful completion, shall return a non-negative integer indicating the number of bytes actually write\&.
.br
 Otherwise, the functions shall return -1 and set errno to indicate the error\&. 
.RE
.PP

.PP
Definition at line 227 of file bufio\&.c\&.
.PP
References bufio::lock, bufio::offset, bufio::raw, bufio::size, spinlock_lock(), and spinlock_unlock()\&.
.PP
.nf
227                                                      {       
228     
229     spinlock_lock(&buf->lock);
230     
231     len = (len + buf->offset > buf->size) ? (buf->size - buf->offset) : len;
232     memcpy((void*) ((off_t) buf->raw + buf->offset), ptr, len);
233     
234     buf->offset += (off_t) len;
235     
236     spinlock_unlock(&buf->lock);
237     
238     return (int) len;
239 }
.fi
.SH "Variable Documentation"
.PP 
.SS "uint64_t buffers_length\fC [static]\fP"

.PP
Allocated RAM of all buffers\&. 
.PP
Definition at line 23 of file bufio\&.c\&.
.SS "\fBtask_t\fP* current_task"

.PP
Current task address\&. 
.PP
Definition at line 35 of file sched\&.c\&.
.SS "\fBlist_t\fP* list_buffers\fC [static]\fP"

.PP
List of allocated buffers\&. 
.PP
Definition at line 18 of file bufio\&.c\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for aPlus from the source code\&.
