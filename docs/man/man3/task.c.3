.TH "src/arch/task.c" 3 "Wed Nov 12 2014" "Version 0.1" "aPlus" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/arch/task.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include <aplus\&.h>\fP
.br
\fC#include <aplus/spinlock\&.h>\fP
.br
\fC#include <aplus/task\&.h>\fP
.br
\fC#include <aplus/mm\&.h>\fP
.br
\fC#include <aplus/list\&.h>\fP
.br
\fC#include <aplus/fs\&.h>\fP
.br
\fC#include <setjmp\&.h>\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "\fB__asm__\fP ('\&.global \fBtask_context_switch\fP		\\n''task_context_switch:				\\n''	push \fBebp\fP						\\n''	mov \fBebp\fP, \fBesp\fP					\\n''	pushf							\\n''	push \fBedx\fP						\\n''	push \fBeax\fP						\\n''	push \fBecx\fP						\\n''	push \fBebx\fP						\\n''	push \fBesi\fP						\\n''	push \fBedi\fP						\\n''	mov \fBeax\fP, [\fBebp\fP + 8]				\\n''	mov \fBedx\fP, [\fBebp\fP + 12]				\\n''	mov [\fBeax\fP], \fBesp\fP					\\n''	mov \fBesp\fP, [\fBedx\fP]					\\n''	pop \fBedi\fP							\\n''	pop \fBesi\fP							\\n''	pop \fBebx\fP							\\n''	pop \fBecx\fP							\\n''	pop \fBeax\fP							\\n''	pop \fBedx\fP							\\n''	popf							\\n''	pop \fBebp\fP							\\n''	sti								\\n''ret								\\n')"
.br
.ti -1c
.RI "void \fBtask_context_switch\fP (task_env_t **old, task_env_t **new)"
.br
.ti -1c
.RI "\fBtask_t\fP * \fBtask_clone\fP (void *entry, void *arg, void *stack, int \fBflags\fP)"
.br
.ti -1c
.RI "void \fBtask_switch\fP (\fBtask_t\fP *newtask)"
.br
.ti -1c
.RI "static int \fB__fork_child\fP ()"
.br
.ti -1c
.RI "\fBtask_t\fP * \fBtask_fork\fP ()"
.br
.ti -1c
.RI "int \fBtask_init\fP ()"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "\fBtask_t\fP * \fBcurrent_task\fP"
.br
.RI "\fICurrent task address\&. \fP"
.ti -1c
.RI "\fBtask_t\fP * \fBkernel_task\fP"
.br
.RI "\fIKernel task address\&. \fP"
.ti -1c
.RI "\fBlist_t\fP * \fBtask_queue\fP"
.br
.RI "\fIList of all Task\&. \fP"
.ti -1c
.RI "\fBuint32_t\fP * \fBkernel_vmm\fP"
.br
.ti -1c
.RI "\fBuint32_t\fP * \fBcurrent_vmm\fP"
.br
.ti -1c
.RI "volatile \fBinode_t\fP * \fBvfs_root\fP"
.br
.ti -1c
.RI "static jmp_buf \fB__fork_buf\fP"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "__asm__ ('\&.global \fBtask_context_switch\fP \\n''task_context_switch: \\n'' push \fBebp\fP \\n'' movebp, esp\\n''pushf\\n''push edx\\n''push eax\\n''push ecx\\n''push ebx\\n''push esi\\n''push edi\\n''moveax, [ebp + 8] \\n''movedx, [ebp + 12] \\n''mov[eax], esp\\n''movesp, [edx] \\n''pop edi\\n''pop esi\\n''pop ebx\\n''pop ecx\\n''pop eax\\n''pop edx\\n''popf\\n''pop ebp\\n''sti\\n''ret\\n')"

.SS "static int __fork_child ()\fC [static]\fP"

.PP
Definition at line 148 of file task\&.c\&.
.PP
References __fork_buf, task::context, task::cr3, kmalloc(), mm_align(), mm_paddr(), TASK_STACKSIZE, uint32_t, uint8_t, VMM_FLAGS_DEFAULT, VMM_FLAGS_USER, and vmm_map()\&.
.PP
.nf
148                           {
149 
150     uint32_t oldesp = __fork_buf->esp;
151 
152     uint32_t stack = (uint32_t) mm_align(kmalloc(TASK_STACKSIZE));
153 
154     for(int i = 0; i < TASK_STACKSIZE; i++)
155         ((uint8_t*) stack)[i] = ((uint8_t*) (oldesp & ~0xFFF)) [i];
156 
157 
158     vmm_map(current_task->context\&.cr3, mm_paddr((void*) stack), (oldesp & ~0xFFF), TASK_STACKSIZE, VMM_FLAGS_DEFAULT | VMM_FLAGS_USER);  
159 
160     longjmp(__fork_buf, 1);
161     return 0;
162 }
.fi
.SS "\fBtask_t\fP* task_clone (void *entry, void *arg, void *stack, intflags)"

.PP
Definition at line 51 of file task\&.c\&.
.PP
References task::clock, CLONE_FILES, CLONE_FS, CLONE_PARENT, CLONE_SIGHAND, CLONE_VM, task::context, task::cr3, current_task, task::cwd, task::env, task::exe, task::fd, task::gid, task::image, kmalloc(), task::length, list_add(), mm_align(), mm_paddr(), task::parent, task::pid, task::priority, task::ptr, schedule_nextpid(), task::signal_handler, task::signal_sig, task::stack, task::state, TASK_MAX_FD, TASK_STACKSIZE, TASK_STATE_ALIVE, task::uid, uint32_t, task::vaddr, vmm_create(), vmm_map(), and vmm_mapkernel()\&.
.PP
.nf
51                                                                    {
52     if(entry == NULL)
53         return NULL;
54 
55     if(stack == NULL)
56         stack = (void*) ((int) mm_align(kmalloc(TASK_STACKSIZE * 2)) + TASK_STACKSIZE);
57 
58     memset(stack, 0, TASK_STACKSIZE);
59 
60 
61     task_t* child = (task_t*) kmalloc(sizeof(task_t));
62     memset(child, 0, sizeof(task_t));
63 
64     child->pid = schedule_nextpid();
65     child->exe = current_task->exe;
66     child->uid = current_task->uid;
67     child->gid = current_task->gid;
68     
69     child->state = TASK_STATE_ALIVE;
70     child->priority = current_task->priority;
71     child->clock = 0;
72 
73 
74     if(flags & CLONE_FILES) {
75         for(int i = 0; i < TASK_MAX_FD; i++)
76             child->fd[i] = current_task->fd[i];
77     }
78 
79     if(flags & CLONE_FS)
80         child->cwd = current_task->cwd;
81     else
82         child->cwd = (inode_t*) vfs_root;
83 
84     if(flags & CLONE_PARENT)
85         child->parent = current_task->parent;   
86     else
87         child->parent = current_task;
88 
89     if(flags & CLONE_SIGHAND) {
90         child->signal_handler = current_task->signal_handler;
91         child->signal_sig = current_task->signal_sig;
92     }
93 
94 
95     if(flags & CLONE_VM) {
96         child->image\&.vaddr = current_task->image\&.vaddr;
97         child->image\&.length = current_task->image\&.length;
98         child->image\&.ptr = current_task->image\&.ptr;
99 
100         child->context\&.cr3 = current_task->context\&.cr3;
101     } else {
102 
103         child->context\&.cr3 = vmm_create();
104         vmm_mapkernel(child->context\&.cr3);
105 
106         child->image\&.vaddr = current_task->image\&.vaddr;
107         child->image\&.length = current_task->image\&.length;
108 
109         if(current_task->image\&.ptr) {
110             void* addr = (void*) kmalloc(child->image\&.length);
111             memcpy(addr, (void*) child->image\&.vaddr, child->image\&.length);
112 
113             vmm_map(child->context\&.cr3, mm_paddr(addr), child->image\&.vaddr, child->image\&.length);
114             child->image\&.ptr = (uint32_t) mm_paddr(addr);
115         }
116     }
117 
118     
119     child->context\&.stack = (uint32_t) stack - TASK_STACKSIZE;
120     child->context\&.env = (task_env_t*) ((uint32_t) stack - sizeof(task_env_t));
121 
122     child->context\&.env->eax = (uint32_t) arg;
123     child->context\&.env->eip = (uint32_t) entry;
124     child->context\&.env->ebp = (uint32_t) child->context\&.env; 
125 
126     
127 
128     list_add(task_queue, (listval_t) child);
129     return child;
130 }
.fi
.SS "void task_context_switch (task_env_t **old, task_env_t **new)"

.SS "\fBtask_t\fP* task_fork ()"

.PP
Definition at line 165 of file task\&.c\&.
.PP
References __fork_buf, __fork_child(), CLONE_FILES, CLONE_FS, CLONE_SIGHAND, schedule_disable(), schedule_enable(), task_clone(), and task_switch()\&.
.PP
.nf
165                     {
166     if(!current_task)
167         return NULL;
168 
169     schedule_disable();
170     task_t* child = task_clone(__fork_child, NULL, NULL, CLONE_FILES | CLONE_FS | CLONE_SIGHAND);       
171 
172     if(setjmp(__fork_buf) == 1) {
173         schedule_enable();
174         return NULL;
175     }
176 
177 
178     task_switch(child);
179     return child; 
180 }
.fi
.SS "int task_init ()"

.PP
Definition at line 184 of file task\&.c\&.
.PP
References task::context, task::cr3, task::cwd, task::env, task::gid, kernel_vmm, kmalloc(), list_add(), task::parent, task::pid, task::priority, schedule_nextpid(), task::stack, task::state, TASK_PRIORITY_REGULAR, TASK_STATE_ALIVE, task_switch(), task::uid, and uint32_t\&.
.PP
.nf
184                 {
185 
186     extern uint32_t kernel_stack;
187     
188     kernel_task = current_task = (task_t*) kmalloc(sizeof(task_t));
189     memset(current_task, 0, sizeof(task_t));
190     
191     
192     current_task->context\&.env = (task_env_t*) 0;
193     current_task->context\&.cr3 = (uint32_t) kernel_vmm;
194     current_task->context\&.stack = (uint32_t) &kernel_stack;
195     
196     
197     current_task->pid = schedule_nextpid();
198     current_task->cwd = (inode_t*) vfs_root;
199     current_task->uid = (uid_t) 0;
200     current_task->gid = (gid_t) 0;
201     
202     current_task->state = TASK_STATE_ALIVE;
203     current_task->priority = TASK_PRIORITY_REGULAR;
204     current_task->parent = NULL;
205 
206 
207     list_add(task_queue, (listval_t) current_task);
208     task_switch(current_task);
209 
210 
211     return 0;
212 }
.fi
.SS "void task_switch (\fBtask_t\fP *newtask)"

.PP
Definition at line 133 of file task\&.c\&.
.PP
References task::context, task::cr3, current_task, task::env, task_context_switch(), and vmm_switch()\&.
.PP
.nf
133                                   {
134     
135     task_t* old = current_task;
136     current_task = newtask;
137 
138     vmm_switch(current_task->context\&.cr3);
139     outb(0x20, 0x20);
140 
141     task_context_switch(&old->context\&.env, &current_task->context\&.env);
142 }
.fi
.SH "Variable Documentation"
.PP 
.SS "jmp_buf __fork_buf\fC [static]\fP"

.PP
Definition at line 146 of file task\&.c\&.
.SS "\fBtask_t\fP* current_task"

.PP
Current task address\&. 
.PP
Definition at line 35 of file sched\&.c\&.
.SS "\fBuint32_t\fP* current_vmm"

.PP
Definition at line 46 of file paging\&.c\&.
.SS "\fBtask_t\fP* kernel_task"

.PP
Kernel task address\&. 
.PP
Definition at line 40 of file sched\&.c\&.
.SS "\fBuint32_t\fP* kernel_vmm"

.PP
Definition at line 47 of file paging\&.c\&.
.SS "\fBlist_t\fP* task_queue"

.PP
List of all Task\&. 
.PP
Definition at line 46 of file sched\&.c\&.
.SS "volatile \fBinode_t\fP* vfs_root"

.PP
Definition at line 19 of file vfs\&.c\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for aPlus from the source code\&.
