.TH "src/fs/iso9660/iso9660_readdir.c" 3 "Sun Nov 16 2014" "Version 0.1" "aPlus" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/fs/iso9660/iso9660_readdir.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include <aplus\&.h>\fP
.br
\fC#include <aplus/fs\&.h>\fP
.br
\fC#include <aplus/task\&.h>\fP
.br
\fC#include <aplus/spinlock\&.h>\fP
.br
\fC#include <aplus/mm\&.h>\fP
.br
\fC#include <stdint\&.h>\fP
.br
\fC#include <string\&.h>\fP
.br
\fC#include <unistd\&.h>\fP
.br
\fC#include <dirent\&.h>\fP
.br
\fC#include <fcntl\&.h>\fP
.br
\fC#include <sys/types\&.h>\fP
.br
\fC#include 'iso9660\&.h'\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "struct \fBdirent\fP * \fBiso9660_readdir\fP (\fBinode_t\fP *ino, int index)"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "struct \fBdirent\fP* iso9660_readdir (\fBinode_t\fP *ino, intindex)"

.PP
Definition at line 16 of file iso9660_readdir\&.c\&.
.PP
References dirent::d_ino, dirent::d_name, inode::dev, devfs_getdevice(), fs_read(), iso9660_checkname(), iso9660_getlsb32(), ISO9660_SECTOR_SIZE, kfree(), kmalloc(), inode::position, uint32_t, and inode::userdata\&.
.PP
.nf
16                                                         {
17     if(!ino)
18         return NULL;
19         
20     if(!ino->dev)
21         return NULL;
22 
23     if(!ino->userdata)
24         return NULL;
25 
26     inode_t* dev = (inode_t*) devfs_getdevice(ino->dev);
27     if(!dev)
28         return NULL;
29 
30     iso9660_dir_t* dir = (iso9660_dir_t*) ino->userdata;
31     iso9660_dir_t* nodes = (iso9660_dir_t*) kmalloc(iso9660_getlsb32(dir->length));
32     iso9660_dir_t* snodes = nodes;
33 
34     dev->position = iso9660_getlsb32(dir->lba) * ISO9660_SECTOR_SIZE;
35     if(fs_read(dev, nodes, iso9660_getlsb32(dir->length)) != iso9660_getlsb32(dir->length)) {
36         kfree(nodes);
37         return NULL;
38     }
39 
40     /* Skip dots ("\&.", "\&.\&.") */
41     nodes = (iso9660_dir_t*) ((uint32_t) nodes + nodes->size);
42     nodes = (iso9660_dir_t*) ((uint32_t) nodes + nodes->size);
43 
44     for(int i = 0; i < index; i++) {        
45         if(nodes->size == 0) {      
46             kfree(snodes);
47             return NULL;
48         }
49         
50         nodes = (iso9660_dir_t*) ((uint32_t) nodes + nodes->size);
51     }
52 
53 
54     if(nodes->size == 0) {
55         kfree(snodes);
56         return NULL;
57     }
58 
59     struct dirent* ent = (struct dirent*) kmalloc(sizeof(struct dirent));
60     memset(ent, 0, sizeof(struct dirent));
61     
62     strncpy(ent->d_name, nodes->reserved, nodes->idlen);    
63     iso9660_checkname(ent->d_name);
64 
65     ent->d_ino = 0;
66 
67     kfree(snodes);
68     return ent;
69 }
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for aPlus from the source code\&.
