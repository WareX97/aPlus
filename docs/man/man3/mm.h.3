.TH "src/include/aplus/mm.h" 3 "Sun Nov 16 2014" "Version 0.1" "aPlus" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/include/aplus/mm.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include <stdint\&.h>\fP
.br
\fC#include <aplus/task\&.h>\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBheap\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBMM_VBASE\fP   0x40000000"
.br
.ti -1c
.RI "#define \fBMM_VSIZE\fP   (0xFFFFFFFF - MM_VBASE)"
.br
.ti -1c
.RI "#define \fBMM_LBASE\fP   0x00000000"
.br
.ti -1c
.RI "#define \fBMM_LSIZE\fP   0x00800000"
.br
.ti -1c
.RI "#define \fBMM_UBASE\fP   0x00A00000"
.br
.ti -1c
.RI "#define \fBMM_USIZE\fP   (\fBMM_VBASE\fP - \fBMM_UBASE\fP)"
.br
.ti -1c
.RI "#define \fBVMM_FLAGS_PRESENT\fP   0x01"
.br
.ti -1c
.RI "#define \fBVMM_FLAGS_RDWR\fP   0x02"
.br
.ti -1c
.RI "#define \fBVMM_FLAGS_USER\fP   0x04"
.br
.ti -1c
.RI "#define \fBVMM_FLAGS_DEFAULT\fP   (\fBVMM_FLAGS_PRESENT\fP | \fBVMM_FLAGS_RDWR\fP)"
.br
.ti -1c
.RI "#define \fBVMM_MAX_MEMORY\fP   (0xFFFFFFFF - MM_VBASE)"
.br
.ti -1c
.RI "#define \fBBLKSIZE\fP   0x1000"
.br
.ti -1c
.RI "#define \fBBLKMAGIC\fP   0x1234"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct \fBheap\fP \fBheap_t\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "static void * \fBmm_paddr\fP (void *vaddr)"
.br
.ti -1c
.RI "static void * \fBmm_vaddr\fP (void *paddr)"
.br
.ti -1c
.RI "static void * \fBmm_align\fP (void *vaddr)"
.br
.ti -1c
.RI "void * \fBkmalloc\fP (size_t)"
.br
.ti -1c
.RI "void \fBkfree\fP (void *)"
.br
.RI "\fIFree memory from Kernel Heap\&. \fP"
.ti -1c
.RI "void * \fBkrealloc\fP (void *, size_t)"
.br
.RI "\fIRealloc memory from Kernel Heap\&. \fP"
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define BLKMAGIC   0x1234"

.PP
Definition at line 61 of file mm\&.h\&.
.SS "#define BLKSIZE   0x1000"

.PP
Definition at line 60 of file mm\&.h\&.
.SS "#define MM_LBASE   0x00000000"

.PP
Definition at line 44 of file mm\&.h\&.
.SS "#define MM_LSIZE   0x00800000"

.PP
Definition at line 45 of file mm\&.h\&.
.SS "#define MM_UBASE   0x00A00000"

.PP
Definition at line 47 of file mm\&.h\&.
.SS "#define MM_USIZE   (\fBMM_VBASE\fP - \fBMM_UBASE\fP)"

.PP
Definition at line 48 of file mm\&.h\&.
.SS "#define MM_VBASE   0x40000000"

.PP
Definition at line 41 of file mm\&.h\&.
.SS "#define MM_VSIZE   (0xFFFFFFFF - MM_VBASE)"

.PP
Definition at line 42 of file mm\&.h\&.
.SS "#define VMM_FLAGS_DEFAULT   (\fBVMM_FLAGS_PRESENT\fP | \fBVMM_FLAGS_RDWR\fP)"

.PP
Definition at line 55 of file mm\&.h\&.
.SS "#define VMM_FLAGS_PRESENT   0x01"

.PP
Definition at line 52 of file mm\&.h\&.
.SS "#define VMM_FLAGS_RDWR   0x02"

.PP
Definition at line 53 of file mm\&.h\&.
.SS "#define VMM_FLAGS_USER   0x04"

.PP
Definition at line 54 of file mm\&.h\&.
.SS "#define VMM_MAX_MEMORY   (0xFFFFFFFF - MM_VBASE)"

.PP
Definition at line 57 of file mm\&.h\&.
.SH "Typedef Documentation"
.PP 
.SS "typedef struct \fBheap\fP  \fBheap_t\fP"

.SH "Function Documentation"
.PP 
.SS "void kfree (void *ptr)"

.PP
Free memory from Kernel Heap\&. 
.PP
\fBParameters:\fP
.RS 4
\fIptr\fP Pointer to data allocated\&. 
.RE
.PP

.PP
Definition at line 151 of file mm\&.c\&.
.PP
References BLKMAGIC, hfree(), mm_align(), and mm_paddr()\&.
.PP
.nf
151                       {
152     if(!ptr)
153         return;
154         
155     
156     block_t* block = (block_t*) ptr;
157     block--;
158 
159     if(block->magic != BLKMAGIC)
160         return;
161 
162 
163     size_t size = block->size;
164     block->size = 0;
165     block->magic = 0;
166     
167 #ifdef CHUNKS_CHECKING
168     block->file = 0;
169     block->line = 0;
170 #endif
171     
172     hfree(current_heap, mm_paddr(mm_align(ptr)), size);
173 }
.fi
.SS "void* kmalloc (size_t)"

.SS "void* krealloc (void *ptr, size_tsize)"

.PP
Realloc memory from Kernel Heap\&. 
.PP
\fBParameters:\fP
.RS 4
\fIptr\fP Pointer to data allocated\&. 
.br
\fIsize\fP Size of data to alloc\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Virtual Address of data\&. 
.RE
.PP

.PP
Definition at line 182 of file mm\&.c\&.
.PP
References BLKMAGIC, kfree(), and kmalloc()\&.
.PP
.nf
182                                        {
183     if(ptr == NULL)
184         return kmalloc(size);
185         
186     if(size == 0) {
187         kfree(ptr);
188         return NULL;
189     }   
190 
191     block_t* block = (block_t*) ptr;
192     block--;
193 
194     if(block->magic != BLKMAGIC)
195         return NULL;
196         
197     void* newptr = kmalloc(size);
198     if(!newptr)
199         return NULL;
200         
201     if(size > block->size)
202         size = block->size;
203         
204     memcpy(newptr, ptr, size);
205     kfree(ptr);
206     
207     return newptr;
208 }
.fi
.SS "static void* mm_align (void *vaddr)\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line 88 of file mm\&.h\&.
.PP
References uint32_t\&.
.PP
.nf
88                                           {
89     return (void*) ((uint32_t) vaddr & ~0xFFF);
90 }
.fi
.SS "static void* mm_paddr (void *vaddr)\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line 74 of file mm\&.h\&.
.PP
References MM_VBASE, and uint32_t\&.
.PP
.nf
74                                           {
75     if((uint32_t) vaddr > MM_VBASE)
76         vaddr = (void*) ((uint32_t) vaddr - MM_VBASE);
77         
78     return vaddr;
79 }
.fi
.SS "static void* mm_vaddr (void *paddr)\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line 81 of file mm\&.h\&.
.PP
References MM_VBASE, and uint32_t\&.
.PP
.nf
81                                           {
82     if((uint32_t) paddr < MM_VBASE)
83         paddr = (void*) ((uint32_t) paddr + MM_VBASE);
84         
85     return paddr;
86 }
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for aPlus from the source code\&.
