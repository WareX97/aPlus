.TH "src/include/aplus/mm.h" 3 "Wed Nov 12 2014" "Version 0.1" "aPlus" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/include/aplus/mm.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include <stdint\&.h>\fP
.br
\fC#include <aplus/task\&.h>\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBheap\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBMM_VBASE\fP   0x40000000"
.br
.ti -1c
.RI "#define \fBMM_VSIZE\fP   (0xFFFFFFFF - MM_VBASE)"
.br
.ti -1c
.RI "#define \fBMM_LBASE\fP   0x00000000"
.br
.ti -1c
.RI "#define \fBMM_LSIZE\fP   0x00800000"
.br
.ti -1c
.RI "#define \fBMM_UBASE\fP   0x00A00000"
.br
.ti -1c
.RI "#define \fBMM_USIZE\fP   (\fBMM_VBASE\fP - \fBMM_UBASE\fP)"
.br
.ti -1c
.RI "#define \fBVMM_FLAGS_PRESENT\fP   0x01"
.br
.ti -1c
.RI "#define \fBVMM_FLAGS_RDWR\fP   0x02"
.br
.ti -1c
.RI "#define \fBVMM_FLAGS_USER\fP   0x04"
.br
.ti -1c
.RI "#define \fBVMM_FLAGS_DEFAULT\fP   (\fBVMM_FLAGS_PRESENT\fP | \fBVMM_FLAGS_RDWR\fP)"
.br
.ti -1c
.RI "#define \fBVMM_MAX_MEMORY\fP   (0xFFFFFFFF - MM_VBASE)"
.br
.ti -1c
.RI "#define \fBBLKSIZE\fP   0x1000"
.br
.ti -1c
.RI "#define \fBBLKMAGIC\fP   0x1234"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct \fBheap\fP \fBheap_t\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "static void * \fBmm_paddr\fP (void *vaddr)"
.br
.ti -1c
.RI "static void * \fBmm_vaddr\fP (void *paddr)"
.br
.ti -1c
.RI "static void * \fBmm_align\fP (void *vaddr)"
.br
.ti -1c
.RI "void * \fBkmalloc\fP (size_t)"
.br
.ti -1c
.RI "void \fBkfree\fP (void *)"
.br
.ti -1c
.RI "void * \fBkrealloc\fP (void *, size_t)"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define BLKMAGIC   0x1234"

.PP
Definition at line 58 of file mm\&.h\&.
.SS "#define BLKSIZE   0x1000"

.PP
Definition at line 57 of file mm\&.h\&.
.SS "#define MM_LBASE   0x00000000"

.PP
Definition at line 41 of file mm\&.h\&.
.SS "#define MM_LSIZE   0x00800000"

.PP
Definition at line 42 of file mm\&.h\&.
.SS "#define MM_UBASE   0x00A00000"

.PP
Definition at line 44 of file mm\&.h\&.
.SS "#define MM_USIZE   (\fBMM_VBASE\fP - \fBMM_UBASE\fP)"

.PP
Definition at line 45 of file mm\&.h\&.
.SS "#define MM_VBASE   0x40000000"

.PP
Definition at line 38 of file mm\&.h\&.
.SS "#define MM_VSIZE   (0xFFFFFFFF - MM_VBASE)"

.PP
Definition at line 39 of file mm\&.h\&.
.SS "#define VMM_FLAGS_DEFAULT   (\fBVMM_FLAGS_PRESENT\fP | \fBVMM_FLAGS_RDWR\fP)"

.PP
Definition at line 52 of file mm\&.h\&.
.SS "#define VMM_FLAGS_PRESENT   0x01"

.PP
Definition at line 49 of file mm\&.h\&.
.SS "#define VMM_FLAGS_RDWR   0x02"

.PP
Definition at line 50 of file mm\&.h\&.
.SS "#define VMM_FLAGS_USER   0x04"

.PP
Definition at line 51 of file mm\&.h\&.
.SS "#define VMM_MAX_MEMORY   (0xFFFFFFFF - MM_VBASE)"

.PP
Definition at line 54 of file mm\&.h\&.
.SH "Typedef Documentation"
.PP 
.SS "typedef struct \fBheap\fP  \fBheap_t\fP"

.SH "Function Documentation"
.PP 
.SS "void kfree (void *)"

.PP
Definition at line 66 of file mm\&.c\&.
.PP
References BLKMAGIC, hfree(), mm_align(), mm_paddr(), and size\&.
.PP
.nf
66                       {
67     if(!ptr)
68         return;
69         
70     
71     block_t* block = (block_t*) ptr;
72     if(block->magic != BLKMAGIC)
73         return;
74         
75     size_t size = block->size;
76     block->size = 0;
77     block->magic = 0;
78     
79     
80     hfree(current_heap, mm_paddr(mm_align(ptr)), size);
81 }
.fi
.SS "void* kmalloc (size_t)"

.SS "void* krealloc (void *, size_t)"

.PP
Definition at line 84 of file mm\&.c\&.
.PP
References BLKMAGIC, kfree(), and kmalloc()\&.
.PP
.nf
84                                        {
85     if(ptr == NULL)
86         return kmalloc(size);
87         
88     if(size == 0) {
89         kfree(ptr);
90         return NULL;
91     }   
92 
93     block_t* block = (block_t*) ptr;
94     if(block->magic != BLKMAGIC)
95         return NULL;
96         
97     void* newptr = kmalloc(size);
98     if(!newptr)
99         return NULL;
100         
101     if(size > block->size)
102         size = block->size;
103         
104     memcpy(newptr, ptr, size);
105     kfree(ptr);
106     
107     return newptr;
108 }
.fi
.SS "static void* mm_align (void *vaddr)\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line 85 of file mm\&.h\&.
.PP
References uint32_t\&.
.PP
.nf
85                                           {
86     return (void*) ((uint32_t) vaddr & ~0xFFF);
87 }
.fi
.SS "static void* mm_paddr (void *vaddr)\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line 71 of file mm\&.h\&.
.PP
References MM_VBASE, and uint32_t\&.
.PP
.nf
71                                           {
72     if((uint32_t) vaddr > MM_VBASE)
73         vaddr = (void*) ((uint32_t) vaddr - MM_VBASE);
74         
75     return vaddr;
76 }
.fi
.SS "static void* mm_vaddr (void *paddr)\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line 78 of file mm\&.h\&.
.PP
References MM_VBASE, and uint32_t\&.
.PP
.nf
78                                           {
79     if((uint32_t) paddr < MM_VBASE)
80         paddr = (void*) ((uint32_t) paddr + MM_VBASE);
81         
82     return paddr;
83 }
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for aPlus from the source code\&.
