.TH "src/include/aplus/mm.h" 3 "Fri Nov 14 2014" "Version 0.1" "aPlus" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/include/aplus/mm.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include <stdint\&.h>\fP
.br
\fC#include <aplus/task\&.h>\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBheap\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBMM_VBASE\fP   0x40000000"
.br
.ti -1c
.RI "#define \fBMM_VSIZE\fP   (0xFFFFFFFF - MM_VBASE)"
.br
.ti -1c
.RI "#define \fBMM_LBASE\fP   0x00000000"
.br
.ti -1c
.RI "#define \fBMM_LSIZE\fP   0x00800000"
.br
.ti -1c
.RI "#define \fBMM_UBASE\fP   0x00A00000"
.br
.ti -1c
.RI "#define \fBMM_USIZE\fP   (\fBMM_VBASE\fP - \fBMM_UBASE\fP)"
.br
.ti -1c
.RI "#define \fBVMM_FLAGS_PRESENT\fP   0x01"
.br
.ti -1c
.RI "#define \fBVMM_FLAGS_RDWR\fP   0x02"
.br
.ti -1c
.RI "#define \fBVMM_FLAGS_USER\fP   0x04"
.br
.ti -1c
.RI "#define \fBVMM_FLAGS_DEFAULT\fP   (\fBVMM_FLAGS_PRESENT\fP | \fBVMM_FLAGS_RDWR\fP)"
.br
.ti -1c
.RI "#define \fBVMM_MAX_MEMORY\fP   (0xFFFFFFFF - MM_VBASE)"
.br
.ti -1c
.RI "#define \fBBLKSIZE\fP   0x1000"
.br
.ti -1c
.RI "#define \fBBLKMAGIC\fP   0x1234"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct \fBheap\fP \fBheap_t\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "static void * \fBmm_paddr\fP (void *vaddr)"
.br
.ti -1c
.RI "static void * \fBmm_vaddr\fP (void *paddr)"
.br
.ti -1c
.RI "static void * \fBmm_align\fP (void *vaddr)"
.br
.ti -1c
.RI "void * \fBkmalloc\fP (size_t)"
.br
.ti -1c
.RI "void \fBkfree\fP (void *)"
.br
.RI "\fIFree memory from Kernel Heap\&. \fP"
.ti -1c
.RI "void * \fBkrealloc\fP (void *, size_t)"
.br
.RI "\fIRealloc memory from Kernel Heap\&. \fP"
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define BLKMAGIC   0x1234"

.PP
Definition at line 58 of file mm\&.h\&.
.SS "#define BLKSIZE   0x1000"

.PP
Definition at line 57 of file mm\&.h\&.
.SS "#define MM_LBASE   0x00000000"

.PP
Definition at line 41 of file mm\&.h\&.
.SS "#define MM_LSIZE   0x00800000"

.PP
Definition at line 42 of file mm\&.h\&.
.SS "#define MM_UBASE   0x00A00000"

.PP
Definition at line 44 of file mm\&.h\&.
.SS "#define MM_USIZE   (\fBMM_VBASE\fP - \fBMM_UBASE\fP)"

.PP
Definition at line 45 of file mm\&.h\&.
.SS "#define MM_VBASE   0x40000000"

.PP
Definition at line 38 of file mm\&.h\&.
.SS "#define MM_VSIZE   (0xFFFFFFFF - MM_VBASE)"

.PP
Definition at line 39 of file mm\&.h\&.
.SS "#define VMM_FLAGS_DEFAULT   (\fBVMM_FLAGS_PRESENT\fP | \fBVMM_FLAGS_RDWR\fP)"

.PP
Definition at line 52 of file mm\&.h\&.
.SS "#define VMM_FLAGS_PRESENT   0x01"

.PP
Definition at line 49 of file mm\&.h\&.
.SS "#define VMM_FLAGS_RDWR   0x02"

.PP
Definition at line 50 of file mm\&.h\&.
.SS "#define VMM_FLAGS_USER   0x04"

.PP
Definition at line 51 of file mm\&.h\&.
.SS "#define VMM_MAX_MEMORY   (0xFFFFFFFF - MM_VBASE)"

.PP
Definition at line 54 of file mm\&.h\&.
.SH "Typedef Documentation"
.PP 
.SS "typedef struct \fBheap\fP  \fBheap_t\fP"

.SH "Function Documentation"
.PP 
.SS "void kfree (void *ptr)"

.PP
Free memory from Kernel Heap\&. 
.PP
\fBParameters:\fP
.RS 4
\fIptr\fP Pointer to data allocated\&. 
.RE
.PP

.PP
Definition at line 79 of file mm\&.c\&.
.PP
References BLKMAGIC, hfree(), mm_align(), mm_paddr(), and size\&.
.PP
.nf
79                       {
80     if(!ptr)
81         return;
82         
83     
84     block_t* block = (block_t*) ptr;
85     if(block->magic != BLKMAGIC)
86         return;
87         
88     size_t size = block->size;
89     block->size = 0;
90     block->magic = 0;
91     
92     
93     hfree(current_heap, mm_paddr(mm_align(ptr)), size);
94 }
.fi
.SS "void* kmalloc (size_t)"

.SS "void* krealloc (void *ptr, size_tsize)"

.PP
Realloc memory from Kernel Heap\&. 
.PP
\fBParameters:\fP
.RS 4
\fIptr\fP Pointer to data allocated\&. 
.br
\fIsize\fP Size of data to alloc\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Virtual Address of data\&. 
.RE
.PP

.PP
Definition at line 103 of file mm\&.c\&.
.PP
References BLKMAGIC, kfree(), and kmalloc()\&.
.PP
.nf
103                                        {
104     if(ptr == NULL)
105         return kmalloc(size);
106         
107     if(size == 0) {
108         kfree(ptr);
109         return NULL;
110     }   
111 
112     block_t* block = (block_t*) ptr;
113     if(block->magic != BLKMAGIC)
114         return NULL;
115         
116     void* newptr = kmalloc(size);
117     if(!newptr)
118         return NULL;
119         
120     if(size > block->size)
121         size = block->size;
122         
123     memcpy(newptr, ptr, size);
124     kfree(ptr);
125     
126     return newptr;
127 }
.fi
.SS "static void* mm_align (void *vaddr)\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line 85 of file mm\&.h\&.
.PP
References uint32_t\&.
.PP
.nf
85                                           {
86     return (void*) ((uint32_t) vaddr & ~0xFFF);
87 }
.fi
.SS "static void* mm_paddr (void *vaddr)\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line 71 of file mm\&.h\&.
.PP
References MM_VBASE, and uint32_t\&.
.PP
.nf
71                                           {
72     if((uint32_t) vaddr > MM_VBASE)
73         vaddr = (void*) ((uint32_t) vaddr - MM_VBASE);
74         
75     return vaddr;
76 }
.fi
.SS "static void* mm_vaddr (void *paddr)\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line 78 of file mm\&.h\&.
.PP
References MM_VBASE, and uint32_t\&.
.PP
.nf
78                                           {
79     if((uint32_t) paddr < MM_VBASE)
80         paddr = (void*) ((uint32_t) paddr + MM_VBASE);
81         
82     return paddr;
83 }
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for aPlus from the source code\&.
