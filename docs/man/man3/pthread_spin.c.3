.TH "usr/src/libpthread/src/pthread_spin.c" 3 "Fri Nov 14 2014" "Version 0.1" "aPlus" \" -*- nroff -*-
.ad l
.nh
.SH NAME
usr/src/libpthread/src/pthread_spin.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include <stdint\&.h>\fP
.br
\fC#include <pthread\&.h>\fP
.br
\fC#include 'pthread_internal\&.h'\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "\fBPUBLIC\fP int \fBpthread_spin_init\fP (\fBpthread_spinlock_t\fP *\fBlock\fP, int pshared)"
.br
.ti -1c
.RI "\fBPUBLIC\fP int \fBpthread_spin_destroy\fP (\fBpthread_spinlock_t\fP *\fBlock\fP)"
.br
.ti -1c
.RI "\fBPUBLIC\fP int \fBpthread_spin_lock\fP (\fBpthread_spinlock_t\fP *\fBlock\fP)"
.br
.ti -1c
.RI "\fBPUBLIC\fP int \fBpthread_spin_trylock\fP (\fBpthread_spinlock_t\fP *\fBlock\fP)"
.br
.ti -1c
.RI "\fBPUBLIC\fP int \fBpthread_spin_unlock\fP (\fBpthread_spinlock_t\fP *\fBlock\fP)"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "\fBPUBLIC\fP int pthread_spin_destroy (\fBpthread_spinlock_t\fP *lock)"

.PP
Definition at line 19 of file pthread_spin\&.c\&.
.PP
References errno, pthread_spinlock::interlock, pthread_spinlock::mutex, and pthread_mutex_destroy()\&.
.PP
.nf
19                                                           {
20     if(!lock) {
21         errno = EINVAL;
22         return 1;
23     }
24 
25     lock->interlock = 0;
26     pthread_mutex_destroy(&lock->mutex);
27 
28     return 0;
29 }
.fi
.SS "\fBPUBLIC\fP int pthread_spin_init (\fBpthread_spinlock_t\fP *lock, intpshared)"

.PP
Definition at line 7 of file pthread_spin\&.c\&.
.PP
References errno, pthread_spinlock::interlock, pthread_spinlock::mutex, and pthread_mutex_init()\&.
.PP
.nf
7                                                                     {
8     if(!lock) {
9         errno = EINVAL;
10         return 1;
11     }
12 
13     lock->interlock = 0;
14     pthread_mutex_init(&lock->mutex, NULL);
15 
16     return 0;
17 }
.fi
.SS "\fBPUBLIC\fP int pthread_spin_lock (\fBpthread_spinlock_t\fP *lock)"

.PP
Definition at line 31 of file pthread_spin\&.c\&.
.PP
References errno, pthread_spinlock::interlock, pthread_spinlock::mutex, and pthread_mutex_lock()\&.
.PP
.nf
31                                                        {
32     if(!lock) {
33         errno = EINVAL;
34         return 1;
35     }
36 
37     if(pthread_mutex_lock(&lock->mutex) == 0)
38         lock->interlock = 1;
39     else
40         return 1; /* errno already setted */
41 
42     return 0;
43 }
.fi
.SS "\fBPUBLIC\fP int pthread_spin_trylock (\fBpthread_spinlock_t\fP *lock)"

.PP
Definition at line 45 of file pthread_spin\&.c\&.
.PP
References errno, pthread_spinlock::interlock, pthread_spinlock::mutex, and pthread_mutex_trylock()\&.
.PP
.nf
45                                                           {
46     if(!lock) {
47         errno = EINVAL;
48         return 1;
49     }
50 
51     if(pthread_mutex_trylock(&lock->mutex) == 0)
52         lock->interlock = 1;
53     else
54         return 1; /* errno already setted */
55 
56     return 0;
57 }
.fi
.SS "\fBPUBLIC\fP int pthread_spin_unlock (\fBpthread_spinlock_t\fP *lock)"

.PP
Definition at line 59 of file pthread_spin\&.c\&.
.PP
References errno, pthread_spinlock::interlock, pthread_spinlock::mutex, and pthread_mutex_unlock()\&.
.PP
.nf
59                                                          {
60     if(!lock) {
61         errno = EINVAL;
62         return 1;
63     }
64 
65     if(pthread_mutex_unlock(&lock->mutex) == 0)
66         lock->interlock = 0;
67     else
68         return 1; /* errno already setted */
69     
70     return 0;
71 }
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for aPlus from the source code\&.
