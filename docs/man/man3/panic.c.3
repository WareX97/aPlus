.TH "src/panic.c" 3 "Sun Nov 16 2014" "Version 0.1" "aPlus" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/panic.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include <aplus\&.h>\fP
.br
\fC#include <aplus/task\&.h>\fP
.br
\fC#include <aplus/mm\&.h>\fP
.br
\fC#include <aplus/fs\&.h>\fP
.br
\fC#include <aplus/list\&.h>\fP
.br
\fC#include <errno\&.h>\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "static void \fBdump_errno\fP ()"
.br
.RI "\fIPrint last error number\&. \fP"
.ti -1c
.RI "static void \fBdump_cpu\fP (regs_t *r)"
.br
.RI "\fIPrint current registers & cpu status\&. \fP"
.ti -1c
.RI "static void \fBdump_stacktrace\fP (int count)"
.br
.ti -1c
.RI "static void \fBdump_task\fP ()"
.br
.RI "\fIPrint all and current task\&. \fP"
.ti -1c
.RI "static void \fBdump_mmu\fP ()"
.br
.RI "\fIPrint MMU State\&. \fP"
.ti -1c
.RI "void \fBpanic_r\fP (char *msg, regs_t *r)"
.br
.RI "\fIGo in Kernel Panic, dump exception registers, halt system\&. \fP"
.ti -1c
.RI "void \fBpanic\fP (char *msg)"
.br
.RI "\fIGo in Kernel Panic, halt system\&. \fP"
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "\fBlist_t\fP * \fBtask_queue\fP"
.br
.RI "\fIList of all Task\&. \fP"
.ti -1c
.RI "\fBtask_t\fP * \fBcurrent_task\fP"
.br
.RI "\fICurrent task address\&. \fP"
.ti -1c
.RI "\fBtask_t\fP * \fBkernel_task\fP"
.br
.RI "\fIKernel task address\&. \fP"
.in -1c
.SH "Function Documentation"
.PP 
.SS "static void dump_cpu (regs_t *r)\fC [static]\fP"

.PP
Print current registers & cpu status\&. 
.PP
Definition at line 25 of file panic\&.c\&.
.PP
References kprintf(), and pit_getticks()\&.
.PP
.nf
25                                 {
26     kprintf("CPU:\n");
27 
28     if(r) {
29         kprintf("eip: 0x%8x\n", r->eip);
30         kprintf("err: 0x%8x\n", r->err_code);
31         kprintf("int: 0x%8x\n", r->int_no);
32         kprintf("esp: 0x%8x\n", r->esp);
33         kprintf("usp: 0x%8x\n", r->useresp);
34     }
35 
36     kprintf("pit: %dms\n", pit_getticks());
37 
38     kprintf("\n\n");
39 }
.fi
.SS "static void dump_errno ()\fC [static]\fP"

.PP
Print last error number\&. 
.PP
Definition at line 17 of file panic\&.c\&.
.PP
References errno, and kprintf()\&.
.PP
.nf
17                          {
18     kprintf("errno: %d - %s\n", errno, strerror(errno));
19 }
.fi
.SS "static void dump_mmu ()\fC [static]\fP"

.PP
Print MMU State\&. 
.PP
Definition at line 95 of file panic\&.c\&.
.PP
References kprintf(), mm_getheap(), heap::size, and heap::used\&.
.PP
.nf
95                        {
96     kprintf("Memory:\n");
97 
98     heap_t* h = (heap_t*) mm_getheap();
99 
100     kprintf("\tUsed: %d MB (%d Bytes)\n", (h->used / 1024 / 1024), h->used);
101     kprintf("\tSize: %d MB (%d Bytes)\n", (h->size / 1024 / 1024), h->size);
102 
103     kprintf("\n\n");
104 }
.fi
.SS "static void dump_stacktrace (intcount)\fC [static]\fP"
Print a stacktrace\&. 
.PP
Definition at line 45 of file panic\&.c\&.
.PP
References __asm__(), eip, elf_kernel_lookup(), esp, kprintf(), and uint32_t\&.
.PP
.nf
45                                        {
46     kprintf("Stack trace:\n");
47     
48     int* esp = NULL; 
49     __asm__("mov eax, ebp" : "=a"(esp));
50 
51 
52     for(int i = 0; i < count; i++) {
53         int eip = *(++esp);
54         kprintf("[%d] 0x%x - %s\n", i, eip, elf_kernel_lookup(eip));
55         
56 
57         esp = (uint32_t*) *(--esp);
58         if(!esp)
59             break;
60     }
61 
62     kprintf("\n\n");
63 }
.fi
.SS "static void dump_task ()\fC [static]\fP"

.PP
Print all and current task\&. 
.PP
Definition at line 69 of file panic\&.c\&.
.PP
References task::exe, kprintf(), list_foreach, inode::name, task::pid, and value\&.
.PP
.nf
69                         {
70     kprintf("Task:\n");
71     
72     list_foreach(value, task_queue) {
73         task_t* task = (task_t*) value;
74         kprintf(" # %d: ", task->pid);
75         
76         if(task->exe)
77             kprintf("%s ", task->exe->name);
78         else
79             kprintf("unknown ");
80             
81         if(task == current_task)
82             kprintf("(current) ");
83             
84         if(task == kernel_task)
85             kprintf("(kernel) ");
86             
87         kprintf("\n\n");
88     }
89 }
.fi
.SS "void panic (char *msg)"

.PP
Go in Kernel Panic, halt system\&. 
.PP
Definition at line 130 of file panic\&.c\&.
.PP
References panic_r()\&.
.PP
.nf
130                       {
131     panic_r(msg, NULL);
132 }
.fi
.SS "void panic_r (char *msg, regs_t *r)"

.PP
Go in Kernel Panic, dump exception registers, halt system\&. 
.PP
Definition at line 111 of file panic\&.c\&.
.PP
References __asm__(), dump_cpu(), dump_errno(), dump_mmu(), dump_stacktrace(), dump_task(), and kprintf()\&.
.PP
.nf
111                                    {
112     __asm__ ("cli");
113     kprintf("panic: \"%s\"\n", msg);
114     
115     
116     
117     dump_cpu(r);
118 
119     dump_stacktrace(6);
120     dump_task();
121     dump_errno();
122     dump_mmu(); 
123 
124     for(;;);
125 }
.fi
.SH "Variable Documentation"
.PP 
.SS "\fBtask_t\fP* current_task"

.PP
Current task address\&. 
.PP
Definition at line 37 of file sched\&.c\&.
.SS "\fBtask_t\fP* kernel_task"

.PP
Kernel task address\&. 
.PP
Definition at line 42 of file sched\&.c\&.
.SS "\fBlist_t\fP* task_queue"

.PP
List of all Task\&. 
.PP
Definition at line 48 of file sched\&.c\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for aPlus from the source code\&.
