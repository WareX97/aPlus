.TH "src/arch/i386/syscall.c" 3 "Sun Nov 16 2014" "Version 0.1" "aPlus" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/arch/i386/syscall.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include <aplus\&.h>\fP
.br
\fC#include <aplus/spinlock\&.h>\fP
.br
\fC#include <aplus/syscall\&.h>\fP
.br
\fC#include <aplus/attribute\&.h>\fP
.br
\fC#include <errno\&.h>\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBNSYSCALLS\fP   1024"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBsyscall_init\fP ()"
.br
.ti -1c
.RI "int \fBsyscall_invoke\fP (int idx, int p0, int p1, int p2, int p3, int p4)"
.br
.ti -1c
.RI "int \fBsyscall_handler\fP (regs_t *r)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "static void ** \fBsyscall_handlers\fP = NULL"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define NSYSCALLS   1024"

.PP
Definition at line 12 of file syscall\&.c\&.
.SH "Function Documentation"
.PP 
.SS "int syscall_handler (regs_t *r)"

.PP
Definition at line 95 of file syscall\&.c\&.
.PP
References syscall_invoke()\&.
.PP
.nf
95                                {
96     return syscall_invoke(r->eax, r->ebx, r->ecx, r->edx, r->esi, r->edi);
97 }
.fi
.SS "int syscall_init ()"

.PP
Definition at line 16 of file syscall\&.c\&.
.PP
References attribute(), __syscall::handler, kmalloc(), kprintf(), list_destroy, list_foreach, NSYSCALLS, __syscall::number, list::size, syscall_handlers, and value\&.
.PP
.nf
16                    {
17     list_t* syslist = attribute("syscall");
18 
19     syscall_handlers = (void**) kmalloc(sizeof(void*) * NSYSCALLS);
20     memset(syscall_handlers, 0, sizeof(void*) * NSYSCALLS);
21 
22     list_foreach(value, syslist) {
23         syscall_t* sys = (syscall_t*) value;
24 
25         if(syscall_handlers[sys->number])
26             kprintf("syscall: duplicate number of %d handler\n");
27 
28         syscall_handlers[sys->number] = sys->handler;
29     }
30 
31     kprintf("syscall: loaded %d handlers\n", syslist->size);
32     list_destroy(syslist);
33 
34 
35 #ifdef DEBUG
36     
37 
38     for(int i = 0, s = 0; i < NSYSCALLS; i++) {
39         if(syscall_handlers[i] == NULL) {
40             if(!s)
41                 continue;
42 
43             if(s > 1)
44                 kprintf("\t%d\&.\&.%d\n", i - s, i - 1);
45             else
46                 kprintf("\t%d\n", i - s);
47 
48             s = 0;
49         } else
50             s++;
51     }
52 #endif
53 
54     return 0;
55 }
.fi
.SS "int syscall_invoke (intidx, intp0, intp1, intp2, intp3, intp4)"

.PP
Definition at line 57 of file syscall\&.c\&.
.PP
References __asm__(), elf_kernel_lookup(), errno, kprintf(), sys_getpid(), and syscall_handlers\&.
.PP
.nf
57                                                                     {
58     void* handler = syscall_handlers[idx];  
59 
60     if(handler == NULL) {
61         errno = ENOSYS;
62         return -1;
63     }
64 
65 
66 #ifdef SYSCALL_DEBUG
67     kprintf("syscall: %d call %s [%d] (%x, %x, %x, %x, %x);\n", sys_getpid(), elf_kernel_lookup(handler), idx, p0, p1, p2, p3, p4);
68 #endif
69 
70 
71 
72     int r = 0;
73 
74     __asm__ (
75         "push ebx           \n"
76         "push ecx           \n"
77         "push edx           \n"
78         "push esi           \n"
79         "push edi           \n"
80         "call eax           \n"
81         "add esp, 20        \n"
82         : "=a"(r) 
83         : "a"(handler), "b"(p4), "c"(p3), "d"(p2), "S"(p1), "D"(p0)
84     );
85 
86 
87 #ifdef SYSCALL_DEBUG
88     kprintf("% returned %x\n", r);
89 #endif
90 
91     return r;
92 }
.fi
.SH "Variable Documentation"
.PP 
.SS "void** syscall_handlers = NULL\fC [static]\fP"

.PP
Definition at line 14 of file syscall\&.c\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for aPlus from the source code\&.
