.TH "src/arch/syscall.c" 3 "Wed Nov 12 2014" "Version 0.1" "aPlus" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/arch/syscall.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include <aplus\&.h>\fP
.br
\fC#include <aplus/spinlock\&.h>\fP
.br
\fC#include <aplus/syscall\&.h>\fP
.br
\fC#include <aplus/attribute\&.h>\fP
.br
\fC#include <errno\&.h>\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBsyscall_init\fP ()"
.br
.ti -1c
.RI "int \fBsyscall_invoke\fP (void *handler, int p0, int p1, int p2, int p3, int p4)"
.br
.ti -1c
.RI "int \fBsyscall_handler\fP (regs_t *r)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "static void ** \fBsyscall_handlers\fP = NULL"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "int syscall_handler (regs_t *r)"

.PP
Definition at line 77 of file syscall\&.c\&.
.PP
References syscall_handlers, and syscall_invoke()\&.
.PP
.nf
77                                {
78     return syscall_invoke(syscall_handlers[r->eax], r->ebx, r->ecx, r->edx, r->esi, r->edi);
79 }
.fi
.SS "int syscall_init ()"

.PP
Definition at line 11 of file syscall\&.c\&.
.PP
References attribute(), __syscall::handler, kmalloc(), kprintf(), list_destroy, list_foreach, __syscall::number, list::size, syscall_handlers, and value\&.
.PP
.nf
11                    {
12     list_t* syslist = attribute("syscall");
13 
14     syscall_handlers = (void**) kmalloc(sizeof(void*) * syslist->size);
15     memset(syscall_handlers, 0, sizeof(void*) * syslist->size);
16 
17     list_foreach(value, syslist) {
18         syscall_t* sys = (syscall_t*) value;
19 
20         if(syscall_handlers[sys->number])
21             kprintf("syscall: duplicate number of %d handler\n");
22 
23         syscall_handlers[sys->number] = sys->handler;
24     }
25 
26     kprintf("syscall: loaded %d handlers\n", syslist->size);
27     list_destroy(syslist);
28 
29 
30 #ifdef DEBUG
31     #define NSYSCALLS       1024
32 
33     for(int i = 0, s = 0; i < NSYSCALLS; i++) {
34         if(syscall_handlers[i] == NULL) {
35             if(!s)
36                 continue;
37 
38             if(s > 1)
39                 kprintf("\t%d\&.\&.%d\n", i - s, i - 1);
40             else
41                 kprintf("\t%d\n", i - s);
42 
43             s = 0;
44         } else
45             s++;
46     }
47 #endif
48 
49     return 0;
50 }
.fi
.SS "int syscall_invoke (void *handler, intp0, intp1, intp2, intp3, intp4)"

.PP
Definition at line 52 of file syscall\&.c\&.
.PP
References __asm__(), and errno\&.
.PP
.nf
52                                                                           {
53     if(handler == NULL) {
54         errno = ENOSYS;
55         return -1;
56     }
57 
58 
59     int r = 0;
60 
61     __asm__ (
62         "push ebx           \n"
63         "push ecx           \n"
64         "push edx           \n"
65         "push esi           \n"
66         "push edi           \n"
67         "call eax           \n"
68         "add esp, 20        \n"
69         : "=a"(r) 
70         : "a"(handler), "b"(p4), "c"(p3), "d"(p2), "S"(p1), "D"(p0)
71     );
72 
73     return r;
74 }
.fi
.SH "Variable Documentation"
.PP 
.SS "void** syscall_handlers = NULL\fC [static]\fP"

.PP
Definition at line 9 of file syscall\&.c\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for aPlus from the source code\&.
