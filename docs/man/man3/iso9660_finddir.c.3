.TH "src/fs/iso9660/iso9660_finddir.c" 3 "Sun Nov 16 2014" "Version 0.1" "aPlus" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/fs/iso9660/iso9660_finddir.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include <aplus\&.h>\fP
.br
\fC#include <aplus/fs\&.h>\fP
.br
\fC#include <aplus/task\&.h>\fP
.br
\fC#include <aplus/spinlock\&.h>\fP
.br
\fC#include <aplus/mm\&.h>\fP
.br
\fC#include <stdint\&.h>\fP
.br
\fC#include <string\&.h>\fP
.br
\fC#include <unistd\&.h>\fP
.br
\fC#include <dirent\&.h>\fP
.br
\fC#include <fcntl\&.h>\fP
.br
\fC#include <sys/types\&.h>\fP
.br
\fC#include 'iso9660\&.h'\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBiso9660_read\fP (\fBinode_t\fP *, char *, int)"
.br
.ti -1c
.RI "struct \fBdirent\fP * \fBiso9660_readdir\fP (\fBinode_t\fP *, int)"
.br
.ti -1c
.RI "\fBinode_t\fP * \fBiso9660_finddir\fP (\fBinode_t\fP *ino, char *\fBname\fP)"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "\fBinode_t\fP* iso9660_finddir (\fBinode_t\fP *ino, char *name)"

.PP
Definition at line 21 of file iso9660_finddir\&.c\&.
.PP
References inode::atime, inode::chown, inode::creat, inode::ctime, inode::dev, devfs_getdevice(), inode::finddir, inode::flush, fs_read(), inode::gid, inode::ino, inode::ioctl, iso9660_checkname(), iso9660_finddir(), ISO9660_FLAGS_DIRECTORY, iso9660_getlsb32(), iso9660_read(), iso9660_readdir(), ISO9660_SECTOR_SIZE, kfree(), kmalloc(), inode::link, inode::mode, inode::mtime, inode::name, inode::nlink, inode::parent, inode::position, inode::rdev, inode::read, inode::readdir, inode::rename, inode::size, sys_time(), inode::uid, uint32_t, inode::unlink, inode::userdata, and inode::write\&.
.PP
.nf
21                                                    {
22     if(!ino)
23         return NULL;
24         
25     if(!ino->dev)
26         return NULL;
27 
28     if(!ino->userdata)
29         return NULL;
30 
31     if(!name || strlen(name) == 0)
32         return NULL;
33 
34 
35     inode_t* dev = (inode_t*) devfs_getdevice(ino->dev);
36     if(!dev)
37         return NULL;
38 
39     iso9660_dir_t* dir = (iso9660_dir_t*) ino->userdata;
40     iso9660_dir_t* nodes = (iso9660_dir_t*) kmalloc(iso9660_getlsb32(dir->length));
41     iso9660_dir_t* snodes = nodes;
42 
43 
44     dev->position = iso9660_getlsb32(dir->lba) * ISO9660_SECTOR_SIZE;
45     if(fs_read(dev, nodes, iso9660_getlsb32(dir->length)) != iso9660_getlsb32(dir->length)) {
46         kfree(nodes);
47         return NULL;
48     }
49 
50     for(;;) {
51         if(nodes->size == 0) {
52             kfree(snodes);
53             return 0;
54         }
55 
56         char* nodename = (char*) kmalloc(nodes->idlen);
57         memset(nodename, 0, nodes->idlen);
58 
59         strncpy(nodename, nodes->reserved, nodes->idlen);
60         iso9660_checkname(nodename);
61 
62 
63         if(strcmp(nodename, name) == 0)
64             break;
65 
66         kfree(nodename);
67         nodes = (iso9660_dir_t*) ((uint32_t) nodes + nodes->size);
68     }
69 
70 
71     inode_t* f = (inode_t*) kmalloc(sizeof(inode_t));
72     memset(f, 0, sizeof(inode_t));
73 
74     strcpy(f->name, name);
75     
76     f->dev = ino->dev;
77     f->ino = 0;
78     f->nlink = 0;
79     f->uid = ino->uid;
80     f->gid = ino->gid;
81     f->rdev = ino->rdev;
82     f->size = (size_t) iso9660_getlsb32(nodes->length);
83     f->atime = f->ctime = f->mtime = sys_time(NULL);
84     f->parent = ino;
85     f->link = NULL;
86     
87     if(nodes->flags & ISO9660_FLAGS_DIRECTORY) {
88         f->readdir = iso9660_readdir;
89         f->finddir = iso9660_finddir;
90         f->mode = S_IFDIR;
91 
92         iso9660_dir_t* entry = (iso9660_dir_t*) kmalloc(ISO9660_SECTOR_SIZE);
93         memset(entry, 0, ISO9660_SECTOR_SIZE);
94 
95         dev->position = iso9660_getlsb32(nodes->lba) * ISO9660_SECTOR_SIZE;
96         fs_read(dev, entry, ISO9660_SECTOR_SIZE);
97 
98         f->userdata = (void*) entry;
99     } else {
100         f->read = iso9660_read;
101         f->write = NULL;    /* Read Only */
102 
103         f->mode = S_IFREG;
104         f->userdata = (void*) (iso9660_getlsb32(nodes->lba) * ISO9660_SECTOR_SIZE);
105     }
106 
107 
108 
109     f->creat = NULL;
110     f->rename = NULL;
111     f->unlink = NULL;
112     f->chown = NULL;
113     f->flush = NULL;
114     f->ioctl = NULL;
115 
116     
117     kfree(snodes);
118     return f;
119 }
.fi
.SS "int iso9660_read (\fBinode_t\fP *, char *, int)"

.PP
Definition at line 17 of file iso9660_read\&.c\&.
.PP
References inode::dev, devfs_getdevice(), fs_read(), inode::position, inode::size, size, and inode::userdata\&.
.PP
.nf
17                                                     {
18     if(!ino)
19         return 0;
20         
21     if(!buf)
22         return 0;
23         
24     if(size > ino->size)
25         size = ino->size;
26         
27     if(ino->position > ino->size)
28         ino->position = ino->size;
29         
30     if(ino->position + size > ino->size)
31         size = ino->size - ino->position;
32         
33     if(!size)
34         return 0;
35 
36     inode_t* dev = (inode_t*) devfs_getdevice(ino->dev);
37     if(!dev)
38         return 0;
39 
40     
41     dev->position = (off_t) ino->userdata + ino->position;
42     fs_read(dev, buf, size);
43 
44     return size;
45 }
.fi
.SS "struct \fBdirent\fP* iso9660_readdir (\fBinode_t\fP *, int)"

.PP
Definition at line 16 of file iso9660_readdir\&.c\&.
.PP
.nf
16                                                         {
17     if(!ino)
18         return NULL;
19         
20     if(!ino->dev)
21         return NULL;
22 
23     if(!ino->userdata)
24         return NULL;
25 
26     inode_t* dev = (inode_t*) devfs_getdevice(ino->dev);
27     if(!dev)
28         return NULL;
29 
30     iso9660_dir_t* dir = (iso9660_dir_t*) ino->userdata;
31     iso9660_dir_t* nodes = (iso9660_dir_t*) kmalloc(iso9660_getlsb32(dir->length));
32     iso9660_dir_t* snodes = nodes;
33 
34     dev->position = iso9660_getlsb32(dir->lba) * ISO9660_SECTOR_SIZE;
35     if(fs_read(dev, nodes, iso9660_getlsb32(dir->length)) != iso9660_getlsb32(dir->length)) {
36         kfree(nodes);
37         return NULL;
38     }
39 
40     /* Skip dots ("\&.", "\&.\&.") */
41     nodes = (iso9660_dir_t*) ((uint32_t) nodes + nodes->size);
42     nodes = (iso9660_dir_t*) ((uint32_t) nodes + nodes->size);
43 
44     for(int i = 0; i < index; i++) {        
45         if(nodes->size == 0) {      
46             kfree(snodes);
47             return NULL;
48         }
49         
50         nodes = (iso9660_dir_t*) ((uint32_t) nodes + nodes->size);
51     }
52 
53 
54     if(nodes->size == 0) {
55         kfree(snodes);
56         return NULL;
57     }
58 
59     struct dirent* ent = (struct dirent*) kmalloc(sizeof(struct dirent));
60     memset(ent, 0, sizeof(struct dirent));
61     
62     strncpy(ent->d_name, nodes->reserved, nodes->idlen);    
63     iso9660_checkname(ent->d_name);
64 
65     ent->d_ino = 0;
66 
67     kfree(snodes);
68     return ent;
69 }
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for aPlus from the source code\&.
