.TH "usr/src/libpthread/src/pthread_mutex.c" 3 "Sun Nov 16 2014" "Version 0.1" "aPlus" \" -*- nroff -*-
.ad l
.nh
.SH NAME
usr/src/libpthread/src/pthread_mutex.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include <stdint\&.h>\fP
.br
\fC#include <time\&.h>\fP
.br
\fC#include <pthread\&.h>\fP
.br
\fC#include 'pthread_internal\&.h'\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "\fBPRIVATE\fP int \fB__locked_mtx\fP (\fBpthread_mutex_t\fP *mutex)"
.br
.ti -1c
.RI "\fBPUBLIC\fP int \fBpthread_mutex_init\fP (\fBpthread_mutex_t\fP *mutex, const \fBpthread_mutexattr_t\fP *attr)"
.br
.ti -1c
.RI "\fBPUBLIC\fP int \fBpthread_mutex_destroy\fP (\fBpthread_mutex_t\fP *mutex)"
.br
.ti -1c
.RI "\fBPUBLIC\fP int \fBpthread_mutex_lock\fP (\fBpthread_mutex_t\fP *mutex)"
.br
.ti -1c
.RI "\fBPUBLIC\fP int \fBpthread_mutex_timedlock\fP (\fBpthread_mutex_t\fP *mutex, const struct timespec *abstime)"
.br
.ti -1c
.RI "\fBPUBLIC\fP int \fBpthread_mutex_trylock\fP (\fBpthread_mutex_t\fP *mutex)"
.br
.ti -1c
.RI "\fBPUBLIC\fP int \fBpthread_mutex_unlock\fP (\fBpthread_mutex_t\fP *mutex)"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "\fBPRIVATE\fP int __locked_mtx (\fBpthread_mutex_t\fP *mutex)"

.PP
Definition at line 9 of file pthread_mutex\&.c\&.
.PP
References pthread_mutex::lock, pthread_mutex_unlock(), and pthread_mutex::time\&.
.PP
.nf
9                                                  {
10     if(mutex->time > 0) {
11         if(time(NULL) < mutex->time)
12             return -1;
13         else {
14             pthread_mutex_unlock(mutex);
15             mutex->time = 0;
16         }
17     }
18 
19 
20     if(mutex->lock == 1)
21         return -1;
22 
23     return 0;
24 }
.fi
.SS "\fBPUBLIC\fP int pthread_mutex_destroy (\fBpthread_mutex_t\fP *mutex)"

.PP
Definition at line 46 of file pthread_mutex\&.c\&.
.PP
References errno, pthread_mutex::event, pthread_mutex::kind, pthread_mutex::lock, pthread_mutex::owner, pthread_mutex::recursion, and pthread_mutex::time\&.
.PP
.nf
46                                                          {
47     if(!mutex) {
48         errno = EINVAL;
49         return -1;
50     }
51 
52     if(mutex->lock == 1) {
53         errno = EBUSY;
54         return -1;
55     }
56 
57     mutex->lock = 0;
58     mutex->recursion = 0;
59     mutex->kind = 0;
60     mutex->owner = 0;
61     mutex->event = 0;
62     mutex->time = 0;
63 
64     return 0;
65 }
.fi
.SS "\fBPUBLIC\fP int pthread_mutex_init (\fBpthread_mutex_t\fP *mutex, const \fBpthread_mutexattr_t\fP *attr)"

.PP
Definition at line 26 of file pthread_mutex\&.c\&.
.PP
References errno, pthread_mutex::event, pthread_mutexattr::kind, pthread_mutex::kind, pthread_mutex::lock, pthread_mutex::owner, PTHREAD_MUTEX_DEFAULT, pthread_mutex::recursion, and pthread_mutex::time\&.
.PP
.nf
26                                                                                        {
27     if(!mutex) {
28         errno = EINVAL;
29         return -1;
30     }
31 
32     mutex->lock = 0;
33     mutex->recursion = 0;
34     mutex->kind = PTHREAD_MUTEX_DEFAULT;
35     mutex->owner = 0;
36     mutex->event = 0;
37     mutex->time = 0;
38 
39     if(attr)
40         mutex->kind = attr->kind;
41 
42     return 0;
43 }
.fi
.SS "\fBPUBLIC\fP int pthread_mutex_lock (\fBpthread_mutex_t\fP *mutex)"

.PP
Definition at line 67 of file pthread_mutex\&.c\&.
.PP
References __locked_mtx(), errno, pthread_mutex::kind, pthread_mutex::lock, pthread_mutex::owner, PTHREAD_MUTEX_ERRORCHECK, PTHREAD_MUTEX_RECURSIVE, pthread_self(), pthread_mutex::recursion, and sched_yield()\&.
.PP
.nf
67                                                       {
68     if(!mutex) {
69         errno = EINVAL;
70         return -1;
71     }
72 
73     if(mutex->owner != pthread_self()) {
74         while(__locked_mtx(mutex))
75             sched_yield();
76         
77         mutex->owner = pthread_self();
78         mutex->recursion = 0;
79         mutex->lock = 1;
80     } else if(mutex->kind == PTHREAD_MUTEX_ERRORCHECK) {
81         errno = EDEADLK;
82         return -1;
83     }
84 
85     if(mutex->kind == PTHREAD_MUTEX_RECURSIVE)
86         mutex->recursion += 1;
87 
88     return 0;
89 }
.fi
.SS "\fBPUBLIC\fP int pthread_mutex_timedlock (\fBpthread_mutex_t\fP *mutex, const struct timespec *abstime)"

.PP
Definition at line 92 of file pthread_mutex\&.c\&.
.PP
References errno, pthread_mutex_lock(), and pthread_mutex::time\&.
.PP
.nf
92                                                                                            {
93     if(abstime == NULL) {
94         errno = EINVAL;
95         return -1;
96     }
97 
98     if(pthread_mutex_lock(mutex) == 0)
99         mutex->time = time(NULL) + abstime->tv_sec;
100     else
101         return -1;
102 
103     return 0;
104 }
.fi
.SS "\fBPUBLIC\fP int pthread_mutex_trylock (\fBpthread_mutex_t\fP *mutex)"

.PP
Definition at line 107 of file pthread_mutex\&.c\&.
.PP
References __locked_mtx(), errno, pthread_mutex::kind, pthread_mutex::lock, pthread_mutex::owner, PTHREAD_MUTEX_ERRORCHECK, PTHREAD_MUTEX_RECURSIVE, pthread_self(), and pthread_mutex::recursion\&.
.PP
.nf
107                                                          {
108     if(!mutex) {
109         errno = EINVAL;
110         return -1;
111     }
112 
113     if(mutex->owner != pthread_self()) {
114         if(__locked_mtx(mutex)) {
115             errno = EBUSY;
116             return -1;
117         }
118 
119         mutex->owner = pthread_self();
120         mutex->recursion = 0;
121         mutex->lock = 1;
122     } else if(mutex->kind == PTHREAD_MUTEX_ERRORCHECK) {
123         errno = EDEADLK;
124         return -1;
125     }
126 
127     if(mutex->kind == PTHREAD_MUTEX_RECURSIVE)
128         mutex->recursion += 1;
129 
130     return 0;
131 }
.fi
.SS "\fBPUBLIC\fP int pthread_mutex_unlock (\fBpthread_mutex_t\fP *mutex)"

.PP
Definition at line 133 of file pthread_mutex\&.c\&.
.PP
References errno, pthread_mutex::kind, pthread_mutex::lock, pthread_mutex::owner, PTHREAD_MUTEX_ERRORCHECK, PTHREAD_MUTEX_RECURSIVE, pthread_self(), and pthread_mutex::recursion\&.
.PP
.nf
133                                                         {
134     if(!mutex) {
135         errno = EINVAL;
136         return -1;
137     }
138 
139     if(mutex->owner == pthread_self()) {
140         if(mutex->kind == PTHREAD_MUTEX_RECURSIVE) {
141             if(--(mutex->recursion))
142                 return 0;
143         }
144 
145         mutex->owner = 0;
146         mutex->lock = 0;
147     } else if(mutex->kind == PTHREAD_MUTEX_ERRORCHECK) {
148         errno = EPERM;
149         return -1;
150     }
151 
152     return 0;
153 }
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for aPlus from the source code\&.
