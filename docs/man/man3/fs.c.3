.TH "src/fs/fs.c" 3 "Sun Nov 16 2014" "Version 0.1" "aPlus" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/fs/fs.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include <aplus\&.h>\fP
.br
\fC#include <aplus/fs\&.h>\fP
.br
\fC#include <aplus/mm\&.h>\fP
.br
\fC#include <stdint\&.h>\fP
.br
\fC#include <stddef\&.h>\fP
.br
\fC#include <unistd\&.h>\fP
.br
\fC#include <sys/stat\&.h>\fP
.br
\fC#include <sys/types\&.h>\fP
.br
\fC#include <fcntl\&.h>\fP
.br
\fC#include <dirent\&.h>\fP
.br
\fC#include <errno\&.h>\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBfs_read\fP (struct \fBinode\fP *\fBinode\fP, char *ptr, int len)"
.br
.ti -1c
.RI "int \fBfs_write\fP (struct \fBinode\fP *\fBinode\fP, char *ptr, int len)"
.br
.ti -1c
.RI "struct \fBdirent\fP * \fBfs_readdir\fP (struct \fBinode\fP *\fBinode\fP, int index)"
.br
.ti -1c
.RI "struct \fBinode\fP * \fBfs_finddir\fP (struct \fBinode\fP *\fBinode\fP, char *\fBname\fP)"
.br
.ti -1c
.RI "struct \fBinode\fP * \fBfs_creat\fP (struct \fBinode\fP *\fBinode\fP, char *\fBname\fP, mode_t mode)"
.br
.ti -1c
.RI "int \fBfs_rename\fP (struct \fBinode\fP *\fBinode\fP, char *oldname, char *newname)"
.br
.ti -1c
.RI "int \fBfs_unlink\fP (struct \fBinode\fP *\fBinode\fP, char *\fBname\fP)"
.br
.ti -1c
.RI "int \fBfs_chown\fP (struct \fBinode\fP *\fBinode\fP, uid_t owner, gid_t group)"
.br
.ti -1c
.RI "void \fBfs_flush\fP (struct \fBinode\fP *\fBinode\fP)"
.br
.ti -1c
.RI "int \fBfs_ioctl\fP (struct \fBinode\fP *\fBinode\fP, int req, void *buf)"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "int fs_chown (struct \fBinode\fP *inode, uid_towner, gid_tgroup)"

.PP
Definition at line 94 of file fs\&.c\&.
.PP
References inode::chown, and errno\&.
.PP
.nf
94                                                              {
95     if(inode->chown)
96         return inode->chown(inode, owner, group);
97         
98     errno = ENOSYS; 
99     return -1;
100 }
.fi
.SS "struct \fBinode\fP* fs_creat (struct \fBinode\fP *inode, char *name, mode_tmode)"

.PP
Definition at line 70 of file fs\&.c\&.
.PP
References inode::creat, and errno\&.
.PP
.nf
70                                                                       {
71     if(inode->creat)
72         return inode->creat(inode, name, mode);
73     
74     errno = ENOSYS;     
75     return NULL;
76 }
.fi
.SS "struct \fBinode\fP* fs_finddir (struct \fBinode\fP *inode, char *name)"

.PP
Definition at line 51 of file fs\&.c\&.
.PP
References errno, inode::finddir, inode::parent, and vfs_mapped()\&.
.PP
.nf
51                                                            {
52 
53     if(strcmp(name, "\&.") == 0)
54         return inode;
55 
56     if(strcmp(name, "\&.\&.") == 0)
57         return inode->parent;
58 
59     inode_t* map = NULL;
60     if((map = (inode_t*) vfs_mapped(inode, name)) != NULL)
61         return map;
62 
63     if(inode->finddir)
64         return inode->finddir(inode, name);
65         
66     errno = ENOSYS; 
67     return NULL;
68 }
.fi
.SS "void fs_flush (struct \fBinode\fP *inode)"

.PP
Definition at line 102 of file fs\&.c\&.
.PP
References errno, and inode::flush\&.
.PP
.nf
102                                    {
103     if(inode->flush)
104         inode->flush(inode);
105         
106     errno = ENOSYS; 
107     return;
108 }
.fi
.SS "int fs_ioctl (struct \fBinode\fP *inode, intreq, void *buf)"

.PP
Definition at line 110 of file fs\&.c\&.
.PP
References errno, and inode::ioctl\&.
.PP
.nf
110                                                       {
111     if(inode->ioctl)
112         return inode->ioctl(inode, req, buf);
113     
114     errno = ENOSYS; 
115     return -1;
116 }
.fi
.SS "int fs_read (struct \fBinode\fP *inode, char *ptr, intlen)"

.PP
Definition at line 17 of file fs\&.c\&.
.PP
References errno, and inode::read\&.
.PP
.nf
17                                                       {
18     if(inode->read)
19         return inode->read(inode, ptr, len);
20     
21     errno = ENOSYS;     
22     return 0;
23 }
.fi
.SS "struct \fBdirent\fP* fs_readdir (struct \fBinode\fP *inode, intindex)"

.PP
Definition at line 33 of file fs\&.c\&.
.PP
References dirent::d_ino, dirent::d_name, errno, inode::ino, kmalloc(), inode::name, inode::readdir, vfs_mapped_at_index(), and vfs_mapped_count()\&.
.PP
.nf
33                                                            {
34 
35     inode_t* map = NULL;
36     if((map = (inode_t*) vfs_mapped_at_index(inode, index)) != NULL) {
37         struct dirent* ent = (struct dirent*) kmalloc(sizeof(struct dirent));
38         strcpy(ent->d_name, map->name);
39         ent->d_ino = map->ino;
40         
41         return ent;
42     }
43 
44     if(inode->readdir)
45         return inode->readdir(inode, index - vfs_mapped_count(inode));
46         
47     errno = ENOSYS; 
48     return NULL;
49 }
.fi
.SS "int fs_rename (struct \fBinode\fP *inode, char *oldname, char *newname)"

.PP
Definition at line 78 of file fs\&.c\&.
.PP
References errno, and inode::rename\&.
.PP
.nf
78                                                                   {
79     if(inode->rename)
80         return inode->rename(inode, oldname, newname);
81     
82     errno = ENOSYS;     
83     return -1;
84 }
.fi
.SS "int fs_unlink (struct \fBinode\fP *inode, char *name)"

.PP
Definition at line 86 of file fs\&.c\&.
.PP
References errno, and inode::unlink\&.
.PP
.nf
86                                                 {
87     if(inode->unlink)
88         return inode->unlink(inode, name);
89         
90     errno = ENOSYS; 
91     return -1;
92 }
.fi
.SS "int fs_write (struct \fBinode\fP *inode, char *ptr, intlen)"

.PP
Definition at line 25 of file fs\&.c\&.
.PP
References errno, and inode::write\&.
.PP
.nf
25                                                        {
26     if(inode->write)
27         return inode->write(inode, ptr, len);
28         
29     errno = ENOSYS; 
30     return 0;
31 }
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for aPlus from the source code\&.
