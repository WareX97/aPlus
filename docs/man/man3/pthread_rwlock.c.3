.TH "usr/src/libpthread/src/pthread_rwlock.c" 3 "Dom 9 Nov 2014" "Version 0.1" "aPlus" \" -*- nroff -*-
.ad l
.nh
.SH NAME
usr/src/libpthread/src/pthread_rwlock.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include <stdint\&.h>\fP
.br
\fC#include <sched\&.h>\fP
.br
\fC#include <time\&.h>\fP
.br
\fC#include <pthread\&.h>\fP
.br
\fC#include 'pthread_internal\&.h'\fP
.br

.SS "Funzioni"

.in +1c
.ti -1c
.RI "\fBPUBLIC\fP int \fBpthread_rwlock_init\fP (\fBpthread_rwlock_t\fP *\fBlock\fP, const \fBpthread_rwlockattr_t\fP *attr)"
.br
.ti -1c
.RI "\fBPUBLIC\fP int \fBpthread_rwlock_destroy\fP (\fBpthread_rwlock_t\fP *\fBlock\fP)"
.br
.ti -1c
.RI "\fBPUBLIC\fP int \fBpthread_rwlock_tryrdlock\fP (\fBpthread_rwlock_t\fP *\fBlock\fP)"
.br
.ti -1c
.RI "\fBPUBLIC\fP int \fBpthread_rwlock_trywrlock\fP (\fBpthread_rwlock_t\fP *\fBlock\fP)"
.br
.ti -1c
.RI "\fBPUBLIC\fP int \fBpthread_rwlock_rdlock\fP (\fBpthread_rwlock_t\fP *\fBlock\fP)"
.br
.ti -1c
.RI "\fBPUBLIC\fP int \fBpthread_rwlock_timedrdlock\fP (\fBpthread_rwlock_t\fP *\fBlock\fP, const struct timespec *abstime)"
.br
.ti -1c
.RI "\fBPUBLIC\fP int \fBpthread_rwlock_wrlock\fP (\fBpthread_rwlock_t\fP *\fBlock\fP)"
.br
.ti -1c
.RI "\fBPUBLIC\fP int \fBpthread_rwlock_timedwrlock\fP (\fBpthread_rwlock_t\fP *\fBlock\fP, const struct timespec *abstime)"
.br
.ti -1c
.RI "\fBPUBLIC\fP int \fBpthread_rwlock_unlock\fP (\fBpthread_rwlock_t\fP *\fBlock\fP)"
.br
.in -1c
.SH "Documentazione delle funzioni"
.PP 
.SS "\fBPUBLIC\fP int pthread_rwlock_destroy (\fBpthread_rwlock_t\fP *lock)"

.PP
Definizione alla linea 34 del file pthread_rwlock\&.c\&.
.PP
Referenzia errno, pthread_rwlock::exclusive_waiters, pthread_rwlock::num_exclusive_waiters, pthread_rwlock::num_shared_waiters, pthread_rwlock::owner, pthread_mutex_destroy(), pthread_self(), pthread_rwlock::rdmutex, pthread_rwlock::shared_waiters, e pthread_rwlock::wrmutex\&.
.PP
.nf
34                                                           {
35     if(lock == NULL) {
36         errno = EINVAL;
37         return 1;
38     }
39 
40     pthread_t thread = pthread_self();
41     if(!thread) {
42         errno = EFAULT;
43         return 1;
44     }
45 
46     if(thread != lock->owner) {
47         errno = EPERM;
48         return 1;
49     }
50 
51     pthread_mutex_destroy(&lock->rdmutex);
52     pthread_mutex_destroy(&lock->wrmutex);
53 
54     lock->shared_waiters = (handle_t) 0;
55     lock->exclusive_waiters = (handle_t) 0;
56     lock->num_shared_waiters = 0;
57     lock->num_exclusive_waiters = 0;
58     lock->owner = 0;
59     
60     return 0;
61 }
.fi
.SS "\fBPUBLIC\fP int pthread_rwlock_init (\fBpthread_rwlock_t\fP *lock, const \fBpthread_rwlockattr_t\fP *attr)"

.PP
Definizione alla linea 10 del file pthread_rwlock\&.c\&.
.PP
Referenzia errno, pthread_rwlock::exclusive_waiters, pthread_rwlock::num_exclusive_waiters, pthread_rwlock::num_shared_waiters, pthread_rwlock::owner, pthread_mutex_init(), pthread_self(), pthread_rwlock::rdmutex, pthread_rwlock::shared_waiters, e pthread_rwlock::wrmutex\&.
.PP
.nf
10                                                                                          {
11     if(lock == NULL) {
12         errno = EINVAL;
13         return 1;
14     }
15 
16     pthread_t thread = pthread_self();
17     if(!thread) {
18         errno = EFAULT;
19         return 1;
20     }
21 
22     pthread_mutex_init(&lock->rdmutex, NULL);
23     pthread_mutex_init(&lock->wrmutex, NULL);
24 
25     lock->shared_waiters = (handle_t) 0;
26     lock->exclusive_waiters = (handle_t) 0;
27     lock->num_shared_waiters = 0;
28     lock->num_exclusive_waiters = 0;
29     lock->owner = thread;
30 
31     return 0;
32 }
.fi
.SS "\fBPUBLIC\fP int pthread_rwlock_rdlock (\fBpthread_rwlock_t\fP *lock)"

.PP
Definizione alla linea 81 del file pthread_rwlock\&.c\&.
.PP
Referenzia errno, pthread_mutex_lock(), e pthread_rwlock::rdmutex\&.
.PP
.nf
81                                                          {
82     if(lock == NULL) {
83         errno = EINVAL;
84         return 1;
85     }
86 
87     return pthread_mutex_lock(&lock->rdmutex);
88 }
.fi
.SS "\fBPUBLIC\fP int pthread_rwlock_timedrdlock (\fBpthread_rwlock_t\fP *lock, const struct timespec *abstime)"

.PP
Definizione alla linea 90 del file pthread_rwlock\&.c\&.
.PP
Referenzia errno, pthread_mutex_timedlock(), e pthread_rwlock::rdmutex\&.
.PP
.nf
90                                                                                               {
91     if(lock == NULL) {
92         errno = EINVAL;
93         return 1;
94     }
95 
96     return pthread_mutex_timedlock(&lock->rdmutex, abstime);
97 }
.fi
.SS "\fBPUBLIC\fP int pthread_rwlock_timedwrlock (\fBpthread_rwlock_t\fP *lock, const struct timespec *abstime)"

.PP
Definizione alla linea 108 del file pthread_rwlock\&.c\&.
.PP
Referenzia errno, pthread_mutex_timedlock(), e pthread_rwlock::wrmutex\&.
.PP
.nf
108                                                                                               {
109     if(lock == NULL) {
110         errno = EINVAL;
111         return 1;
112     }
113 
114     return pthread_mutex_timedlock(&lock->wrmutex, abstime);
115 }
.fi
.SS "\fBPUBLIC\fP int pthread_rwlock_tryrdlock (\fBpthread_rwlock_t\fP *lock)"

.PP
Definizione alla linea 63 del file pthread_rwlock\&.c\&.
.PP
Referenzia errno, pthread_mutex_trylock(), e pthread_rwlock::rdmutex\&.
.PP
.nf
63                                                             {
64     if(lock == NULL) {
65         errno = EINVAL;
66         return 1;
67     }
68 
69     return pthread_mutex_trylock(&lock->rdmutex);
70 }
.fi
.SS "\fBPUBLIC\fP int pthread_rwlock_trywrlock (\fBpthread_rwlock_t\fP *lock)"

.PP
Definizione alla linea 72 del file pthread_rwlock\&.c\&.
.PP
Referenzia errno, pthread_mutex_trylock(), e pthread_rwlock::wrmutex\&.
.PP
.nf
72                                                             {
73     if(lock == NULL) {
74         errno = EINVAL;
75         return 1;
76     }
77 
78     return pthread_mutex_trylock(&lock->wrmutex);
79 }
.fi
.SS "\fBPUBLIC\fP int pthread_rwlock_unlock (\fBpthread_rwlock_t\fP *lock)"

.PP
Definizione alla linea 117 del file pthread_rwlock\&.c\&.
.PP
Referenzia errno, pthread_mutex_unlock(), pthread_rwlock::rdmutex, e pthread_rwlock::wrmutex\&.
.PP
.nf
117                                                          {
118     if(lock == NULL) {
119         errno = EINVAL;
120         return 1;
121     }
122 
123     if(pthread_mutex_unlock(&lock->rdmutex) != 0)
124         return 1;
125 
126     if(pthread_mutex_unlock(&lock->wrmutex) != 0)
127         return 1;
128 
129     return 0;
130 }
.fi
.SS "\fBPUBLIC\fP int pthread_rwlock_wrlock (\fBpthread_rwlock_t\fP *lock)"

.PP
Definizione alla linea 99 del file pthread_rwlock\&.c\&.
.PP
Referenzia errno, pthread_mutex_lock(), e pthread_rwlock::wrmutex\&.
.PP
.nf
99                                                          {
100     if(lock == NULL) {
101         errno = EINVAL;
102         return 1;
103     }
104 
105     return pthread_mutex_lock(&lock->wrmutex);
106 }
.fi
.SH "Autore"
.PP 
Generato automaticamente da Doxygen per aPlus a partire dal codice sorgente\&.
