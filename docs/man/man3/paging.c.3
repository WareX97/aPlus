.TH "src/mm/paging.c" 3 "Sun Nov 9 2014" "Version 0.1" "aPlus" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/mm/paging.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include <stdint\&.h>\fP
.br
\fC#include <stddef\&.h>\fP
.br
\fC#include <string\&.h>\fP
.br
\fC#include <sys/types\&.h>\fP
.br
\fC#include <aplus\&.h>\fP
.br
\fC#include <aplus/mm\&.h>\fP
.br
\fC#include <aplus/task\&.h>\fP
.br
\fC#include <aplus/list\&.h>\fP
.br
\fC#include <grub\&.h>\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBPGSIZE\fP   (\fBBLKSIZE\fP)"
.br
.ti -1c
.RI "#define \fBPGFLAGS\fP   (0x00000000)"
.br
.ti -1c
.RI "#define \fBPDSIZE\fP   (1024)"
.br
.ti -1c
.RI "#define \fBPDENTRY\fP(x)   ((\fBuint32_t\fP) x >> 22)"
.br
.ti -1c
.RI "#define \fBPTSIZE\fP   (1024)"
.br
.ti -1c
.RI "#define \fBPTENTRY\fP(x)   ((\fBuint32_t\fP) x << 10 >> 10 >> 12)"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBvmm_switch\fP (\fBuint32_t\fP *addr)"
.br
.ti -1c
.RI "void \fBvmm_enable\fP ()"
.br
.ti -1c
.RI "void \fBvmm_disable\fP ()"
.br
.ti -1c
.RI "void * \fBvmm_map\fP (\fBuint32_t\fP *pd, void *paddr, void *vaddr, size_t len, int \fBflags\fP)"
.br
.ti -1c
.RI "void \fBvmm_umap\fP (\fBuint32_t\fP *pd, void *addr, size_t len)"
.br
.ti -1c
.RI "void * \fBvmm_alloc\fP (void *vaddr, size_t \fBsize\fP, int \fBflags\fP)"
.br
.ti -1c
.RI "void \fBvmm_mapkernel\fP (\fBuint32_t\fP *\fBdest\fP)"
.br
.ti -1c
.RI "\fBuint32_t\fP * \fBvmm_create\fP ()"
.br
.ti -1c
.RI "void \fBvmm_destroy\fP (\fBuint32_t\fP *vmm)"
.br
.ti -1c
.RI "int \fBvmm_init\fP ()"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "volatile \fBheap_t\fP * \fBcurrent_heap\fP"
.br
.ti -1c
.RI "\fBuint32_t\fP \fBmemsize\fP"
.br
.ti -1c
.RI "\fBuint32_t\fP * \fBcurrent_vmm\fP"
.br
.ti -1c
.RI "\fBuint32_t\fP * \fBkernel_vmm\fP"
.br
.ti -1c
.RI "\fBlist_t\fP * \fBvmm_queue\fP"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define PDENTRY(x)   ((\fBuint32_t\fP) x >> 22)"

.PP
Definition at line 38 of file paging\&.c\&.
.SS "#define PDSIZE   (1024)"

.PP
Definition at line 37 of file paging\&.c\&.
.SS "#define PGFLAGS   (0x00000000)"

.PP
Definition at line 35 of file paging\&.c\&.
.SS "#define PGSIZE   (\fBBLKSIZE\fP)"

.PP
Definition at line 34 of file paging\&.c\&.
.SS "#define PTENTRY(x)   ((\fBuint32_t\fP) x << 10 >> 10 >> 12)"

.PP
Definition at line 41 of file paging\&.c\&.
.SS "#define PTSIZE   (1024)"

.PP
Definition at line 40 of file paging\&.c\&.
.SH "Function Documentation"
.PP 
.SS "void* vmm_alloc (void *vaddr, size_tsize, intflags)"

.PP
Definition at line 130 of file paging\&.c\&.
.PP
References current_vmm, halloc(), and vmm_map()\&.
.PP
.nf
130                                                      {
131     void* paddr = (void*) halloc(current_heap, size);
132 
133     vmm_map(current_vmm, paddr, vaddr, size, flags);
134 
135     return paddr;
136 }
.fi
.SS "\fBuint32_t\fP* vmm_create ()"

.PP
Definition at line 151 of file paging\&.c\&.
.PP
References kmalloc(), mm_align(), PDSIZE, and uint32_t\&.
.PP
.nf
151                        {
152     uint32_t* addr = (uint32_t*) mm_align((void*) kmalloc(PDSIZE * sizeof(uint32_t)));
153     if(!addr)
154         return NULL;
155         
156 
157     memset(addr, 0, PDSIZE * sizeof(uint32_t));
158     return addr;
159 }
.fi
.SS "void vmm_destroy (\fBuint32_t\fP *vmm)"

.PP
Definition at line 161 of file paging\&.c\&.
.PP
References PDSIZE, and uint32_t\&.
.PP
.nf
161                                 {
162     memset(vmm, 0, PDSIZE * sizeof(uint32_t));
163 }
.fi
.SS "void vmm_disable ()"

.PP
Definition at line 65 of file paging\&.c\&.
.PP
.nf
65                    {
66     write_cr0(read_cr0() & ~0x80000000);
67 }
.fi
.SS "void vmm_enable ()"

.PP
Definition at line 60 of file paging\&.c\&.
.PP
.nf
60                   {
61     write_cr4(read_cr4() & ~0x00000010);
62     write_cr0(read_cr0() | 0x80000000);
63 }
.fi
.SS "int vmm_init ()"

.PP
Definition at line 165 of file paging\&.c\&.
.PP
References halloc(), kernel_vmm, list_init, panic(), PDSIZE, uint32_t, vmm_enable(), vmm_mapkernel(), and vmm_switch()\&.
.PP
.nf
165                {
166 
167     kernel_vmm = (uint32_t*) halloc(current_heap, PDSIZE * sizeof(uint32_t));
168     if(!kernel_vmm)
169         panic("Could not initialize VMM");
170     
171 
172     memset(kernel_vmm, 0, PDSIZE * sizeof(uint32_t));
173     
174     vmm_mapkernel(kernel_vmm);
175     vmm_switch(kernel_vmm);
176     vmm_enable();
177 
178     list_init(vmm_queue);
179     return 0;
180 }
.fi
.SS "void* vmm_map (\fBuint32_t\fP *pd, void *paddr, void *vaddr, size_tlen, intflags)"

.PP
Definition at line 72 of file paging\&.c\&.
.PP
References current_vmm, flags, halloc(), mm_align(), panic(), PDENTRY, PGSIZE, PTENTRY, PTSIZE, uint32_t, and VMM_FLAGS_DEFAULT\&.
.PP
.nf
72                                                                              { 
73     if(!pd)
74         return paddr;
75         
76     paddr = mm_align(paddr);
77     vaddr = mm_align(vaddr);
78         
79     int pages = (len / PGSIZE) + 1;
80     uint32_t pframe = (uint32_t) paddr;
81     uint32_t vframe = (uint32_t) vaddr;
82     
83     for(int i = 0; i < pages; i++) {
84         uint32_t* e = &pd[PDENTRY(vframe)];
85         
86         if(*e == 0) {
87             uint32_t* table = (uint32_t*) halloc(current_heap, PTSIZE * sizeof(uint32_t));
88             if(!table)
89                 panic("vmm_map(): cannot allocate more table\n");
90                 
91             if(current_vmm)
92                 vmm_map(current_vmm, table, table, PTSIZE * sizeof(uint32_t), VMM_FLAGS_DEFAULT);
93             
94             memset(table, 0, PTSIZE * sizeof(uint32_t));
95             *e = (uint32_t) table | flags;  
96         }
97         
98         uint32_t* t = (uint32_t*) (*e & ~0xFFF);
99         t[PTENTRY(vframe)] = pframe | flags;
100         
101         pframe += PGSIZE;
102         vframe += PGSIZE;
103     }
104     
105     return vaddr;
106 }
.fi
.SS "void vmm_mapkernel (\fBuint32_t\fP *dest)"

.PP
Definition at line 138 of file paging\&.c\&.
.PP
References memsize, MM_LBASE, MM_LSIZE, mm_vaddr(), VMM_FLAGS_DEFAULT, VMM_FLAGS_USER, and vmm_map()\&.
.PP
.nf
138                                    {
139     // Map 8MB to low area (kernel reserved)
140     vmm_map(dest, (void*) MM_LBASE, (void*) MM_LBASE, MM_LSIZE, VMM_FLAGS_DEFAULT);
141 
142     // Map all high-memory (kernel reserved)
143     vmm_map(dest, (void*) 0, mm_vaddr((void*) 0), memsize, VMM_FLAGS_DEFAULT);
144 
145     // Map Linear Frame Buffer
146     vmm_map(dest, (void*) 0xE0000000, (void*) 0xE0000000, 0x10000000, VMM_FLAGS_DEFAULT | VMM_FLAGS_USER);
147 }
.fi
.SS "void vmm_switch (\fBuint32_t\fP *addr)"

.PP
Definition at line 54 of file paging\&.c\&.
.PP
References current_vmm, mm_paddr(), and uint32_t\&.
.PP
.nf
54                                 {
55     current_vmm = addr;
56     
57     write_cr3((uint32_t) mm_paddr((void*) addr));
58 }
.fi
.SS "void vmm_umap (\fBuint32_t\fP *pd, void *addr, size_tlen)"

.PP
Definition at line 109 of file paging\&.c\&.
.PP
References mm_align(), PDENTRY, PGSIZE, PTENTRY, and uint32_t\&.
.PP
.nf
109                                                     {
110     if(!pd)
111         return;
112         
113     addr = mm_align(addr);
114         
115     int pages = (len / PGSIZE) + 1;
116     
117     
118     for(uint32_t i = 0, frame = (uint32_t) addr; i < pages; i++, frame += PGSIZE) {
119         uint32_t* e = &pd[PDENTRY(frame)];
120         if((*e & 1) != 1)
121             continue;
122             
123         uint32_t* table = (uint32_t*) (*e & ~0xFFF);
124         table[PTENTRY(frame)] = 0;
125     }
126     
127 }
.fi
.SH "Variable Documentation"
.PP 
.SS "volatile \fBheap_t\fP* current_heap"

.PP
Definition at line 36 of file mm\&.c\&.
.SS "\fBuint32_t\fP* current_vmm"

.PP
Definition at line 46 of file paging\&.c\&.
.SS "\fBuint32_t\fP* kernel_vmm"

.PP
Definition at line 47 of file paging\&.c\&.
.SS "\fBuint32_t\fP memsize"

.PP
Definition at line 35 of file mm\&.c\&.
.SS "\fBlist_t\fP* vmm_queue"

.PP
Definition at line 49 of file paging\&.c\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for aPlus from the source code\&.
