.TH "src/syscall/execve.c" 3 "Sun Nov 9 2014" "Version 0.1" "aPlus" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/syscall/execve.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include <aplus\&.h>\fP
.br
\fC#include <aplus/task\&.h>\fP
.br
\fC#include <aplus/syscall\&.h>\fP
.br
\fC#include <unistd\&.h>\fP
.br
\fC#include <fcntl\&.h>\fP
.br
\fC#include <errno\&.h>\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBsys_execve\fP (char *filename, char **argv, char **\fBenviron\fP)"
.br
.RI "\fIExecutes the program pointed to by filename\&.
.br
 filename must be either a binary executable, or a script starting with a line of the form\&.
.br
 #! interpreter [optional-arg]\&. \fP"
.ti -1c
.RI "\fBSYSCALL\fP (\fBsys_execve\fP, 2)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "\fBtask_t\fP * \fBcurrent_task\fP"
.br
.RI "\fICurrent task address\&. \fP"
.in -1c
.SH "Function Documentation"
.PP 
.SS "int sys_execve (char *filename, char **argv, char **environ)"

.PP
Executes the program pointed to by filename\&.
.br
 filename must be either a binary executable, or a script starting with a line of the form\&.
.br
 #! interpreter [optional-arg]\&. 
.PP
\fBParameters:\fP
.RS 4
\fIfilename\fP executable path\&. 
.br
\fIargv\fP Is an array of argument strings passed to the new program\&.
.br
 By convention, the first of these strings should contain the filename associated with the file being executed\&. 
.br
\fIenviron\fP Is an array of strings, conventionally of the form key=value, which are passed as environment to the new program\&. 
.RE
.PP
\fBWarning:\fP
.RS 4
Both argv and environ must be terminated by a null pointer\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Does not return on success, and the text, data, bss, and stack of the calling process are overwritten by that of the program loaded\&. 
.RE
.PP

.PP
Definition at line 27 of file execve\&.c\&.
.PP
References task::argv, elf32_load(), environ, task::envp, errno, task::exe, task::fd, kfree(), kmalloc(), size, sys_close(), sys_lseek(), sys_open(), and sys_read()\&.
.PP
.nf
27                                                             {
28     
29     int fd = sys_open(filename, O_RDONLY, 0644);
30     if(fd < 0) {
31         errno = ENOENT;
32         return -1;
33     }
34 
35     sys_lseek(fd, 0, SEEK_END);
36     size_t size = sys_lseek(fd, 0, SEEK_CUR);
37     sys_lseek(fd, 0, SEEK_SET);
38 
39     void* image = kmalloc(size);
40     if(!image) {
41         sys_close(fd);
42 
43         errno = ENOMEM;
44         return -1;
45     }
46 
47     if(sys_read(fd, image, size) < size) {
48         sys_close(fd);
49         kfree(image);
50         
51         errno = EIO;
52         return -1;
53     }
54 
55     
56 
57     void (*entry) () = (void (*) ()) elf32_load(image);
58     if(entry) {
59 
60         current_task->exe = current_task->fd[fd];
61         current_task->argv = argv;
62         current_task->envp = environ;
63 
64         sys_close(fd);
65 
66 
67         entry(); /* never return */
68     }
69 
70     sys_close(fd);
71     kfree(image);
72     return -1;
73 }
.fi
.SS "SYSCALL (\fBsys_execve\fP, 2)"

.SH "Variable Documentation"
.PP 
.SS "\fBtask_t\fP* current_task"

.PP
Current task address\&. 
.PP
Definition at line 35 of file sched\&.c\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for aPlus from the source code\&.
