.TH "src/syscall/execve.c" 3 "Sun Nov 16 2014" "Version 0.1" "aPlus" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/syscall/execve.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include <aplus\&.h>\fP
.br
\fC#include <aplus/task\&.h>\fP
.br
\fC#include <aplus/syscall\&.h>\fP
.br
\fC#include <unistd\&.h>\fP
.br
\fC#include <fcntl\&.h>\fP
.br
\fC#include <errno\&.h>\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "static char ** \fB__args_dup\fP (char **a)"
.br
.ti -1c
.RI "int \fBsys_execve\fP (char *filename, char **argv, char **\fBenviron\fP)"
.br
.RI "\fIExecutes the program pointed to by filename\&.
.br
 filename must be either a binary executable, or a script starting with a line of the form\&.
.br
 #! interpreter [optional-arg]\&. \fP"
.ti -1c
.RI "\fBSYSCALL\fP (\fBsys_execve\fP, 2)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "\fBtask_t\fP * \fBcurrent_task\fP"
.br
.RI "\fICurrent task address\&. \fP"
.in -1c
.SH "Function Documentation"
.PP 
.SS "static char** __args_dup (char **a)\fC [static]\fP"

.PP
Definition at line 13 of file execve\&.c\&.
.PP
References kmalloc()\&.
.PP
.nf
13                                    {
14     if(!a)
15         return NULL;
16 
17     char** p = (char**) kmalloc(255 * sizeof(char*));
18     memset(p, 0, 255 * sizeof(char*));
19 
20     int i = 0;
21     while(a[i]) {
22         p[i] = (char*) kmalloc(strlen(a[i]) + 1);
23         strcpy(p[i], a[i]);
24 
25         i++;
26     }
27 
28     return p;
29 }
.fi
.SS "int sys_execve (char *filename, char **argv, char **environ)"

.PP
Executes the program pointed to by filename\&.
.br
 filename must be either a binary executable, or a script starting with a line of the form\&.
.br
 #! interpreter [optional-arg]\&. 
.PP
\fBParameters:\fP
.RS 4
\fIfilename\fP executable path\&. 
.br
\fIargv\fP Is an array of argument strings passed to the new program\&.
.br
 By convention, the first of these strings should contain the filename associated with the file being executed\&. 
.br
\fIenviron\fP Is an array of strings, conventionally of the form key=value, which are passed as environment to the new program\&. 
.RE
.PP
\fBWarning:\fP
.RS 4
Both argv and environ must be terminated by a null pointer\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Does not return on success, and the text, data, bss, and stack of the calling process are overwritten by that of the program loaded\&. 
.RE
.PP

.PP
Definition at line 47 of file execve\&.c\&.
.PP
References __args_dup(), task::argv, elf32_load(), environ, task::envp, errno, task::exe, task::fd, task::image, kfree(), kmalloc(), task::length, task::ptr, size, sys_close(), sys_lseek(), sys_open(), sys_read(), and task::vaddr\&.
.PP
.nf
47                                                             {
48     
49     int fd = sys_open(filename, O_RDONLY, 0644);
50     if(fd < 0) {
51         errno = ENOENT;
52         return -1;
53     }
54 
55     sys_lseek(fd, 0, SEEK_END);
56     size_t size = sys_lseek(fd, 0, SEEK_CUR);
57     sys_lseek(fd, 0, SEEK_SET);
58 
59     void* image = kmalloc(size);
60     if(!image) {
61         sys_close(fd);
62 
63         errno = ENOMEM;
64         return -1;
65     }
66 
67     if(sys_read(fd, image, size) < size) {
68         sys_close(fd);
69         kfree(image);
70         
71         errno = EIO;
72         return -1;
73     }
74 
75     
76     int vaddr, vsize;
77     void (*entry) () = (void (*) ()) elf32_load(image, &vaddr, &vsize);
78     if(entry) {
79 
80         argv = __args_dup(argv);
81         environ = __args_dup(environ);
82 
83         current_task->exe = current_task->fd[fd];
84         current_task->argv = argv;
85         current_task->envp = environ;
86 
87         current_task->image\&.ptr = (int) image;
88         current_task->image\&.vaddr = vaddr;
89         current_task->image\&.length = vsize;
90 
91         sys_close(fd);
92 
93 
94         entry(); /* never return */
95     }
96 
97     sys_close(fd);
98     kfree(image);
99     return -1;
100 }
.fi
.SS "SYSCALL (\fBsys_execve\fP, 2)"

.SH "Variable Documentation"
.PP 
.SS "\fBtask_t\fP* current_task"

.PP
Current task address\&. 
.PP
Definition at line 37 of file sched\&.c\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for aPlus from the source code\&.
