.TH "src/exec.c" 3 "Dom 9 Nov 2014" "Version 0.1" "aPlus" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/exec.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include <aplus\&.h>\fP
.br
\fC#include <aplus/mm\&.h>\fP
.br
\fC#include <stdint\&.h>\fP
.br
\fC#include <errno\&.h>\fP
.br

.SS "Strutture dati"

.in +1c
.ti -1c
.RI "struct \fBelf32_hdr\fP"
.br
.ti -1c
.RI "struct \fBelf32_shdr\fP"
.br
.in -1c
.SS "Definizioni"

.in +1c
.ti -1c
.RI "#define \fBEI_NIDENT\fP   16"
.br
.ti -1c
.RI "#define \fBEI_MAG0\fP   0"
.br
.ti -1c
.RI "#define \fBEI_MAG1\fP   1"
.br
.ti -1c
.RI "#define \fBEI_MAG2\fP   2"
.br
.ti -1c
.RI "#define \fBEI_MAG3\fP   3"
.br
.ti -1c
.RI "#define \fBEI_CLASS\fP   4"
.br
.ti -1c
.RI "#define \fBEI_DATA\fP   5"
.br
.ti -1c
.RI "#define \fBEI_VERSION\fP   6"
.br
.ti -1c
.RI "#define \fBEI_PAD\fP   7"
.br
.ti -1c
.RI "#define \fBELF_MAG0\fP   0x7F"
.br
.ti -1c
.RI "#define \fBELF_MAG1\fP   'E'"
.br
.ti -1c
.RI "#define \fBELF_MAG2\fP   'L'"
.br
.ti -1c
.RI "#define \fBELF_MAG3\fP   'F'"
.br
.ti -1c
.RI "#define \fBELF_CLASS_32\fP   1"
.br
.ti -1c
.RI "#define \fBELF_CLASS_64\fP   2"
.br
.ti -1c
.RI "#define \fBELF_DATA_LSB\fP   1"
.br
.ti -1c
.RI "#define \fBELF_DATA_MSB\fP   2"
.br
.ti -1c
.RI "#define \fBSHT_NULL\fP   0"
.br
.ti -1c
.RI "#define \fBSHT_PROGBITS\fP   1"
.br
.ti -1c
.RI "#define \fBSHT_SYMTAB\fP   2"
.br
.ti -1c
.RI "#define \fBSHT_STRTAB\fP   3"
.br
.ti -1c
.RI "#define \fBSHT_RELA\fP   4"
.br
.ti -1c
.RI "#define \fBSHT_HASH\fP   5"
.br
.ti -1c
.RI "#define \fBSHT_DYNAMIC\fP   6"
.br
.ti -1c
.RI "#define \fBSHT_NOTE\fP   7"
.br
.ti -1c
.RI "#define \fBSHT_NOBITS\fP   8"
.br
.ti -1c
.RI "#define \fBSHT_REL\fP   9"
.br
.ti -1c
.RI "#define \fBSHT_SHLIB\fP   10"
.br
.ti -1c
.RI "#define \fBSHT_DYNSYM\fP   11"
.br
.ti -1c
.RI "#define \fBSHF_WRITE\fP   1"
.br
.ti -1c
.RI "#define \fBSHF_ALLOC\fP   2"
.br
.ti -1c
.RI "#define \fBSHF_EXECINSTR\fP   4"
.br
.ti -1c
.RI "#define \fBSHF_MASK\fP   0xF0000000"
.br
.ti -1c
.RI "#define \fBcheck\fP(cond)"
.br
.in -1c
.SS "Ridefinizioni di tipo (typedef)"

.in +1c
.ti -1c
.RI "typedef \fBuint32_t\fP \fBElf32_Addr\fP"
.br
.ti -1c
.RI "typedef \fBuint16_t\fP \fBElf32_Half\fP"
.br
.ti -1c
.RI "typedef \fBuint32_t\fP \fBElf32_Off\fP"
.br
.ti -1c
.RI "typedef int32_t \fBElf32_Sword\fP"
.br
.ti -1c
.RI "typedef \fBuint32_t\fP \fBElf32_Word\fP"
.br
.ti -1c
.RI "typedef struct \fBelf32_hdr\fP \fBelf32_hdr_t\fP"
.br
.ti -1c
.RI "typedef struct \fBelf32_shdr\fP \fBelf32_shdr_t\fP"
.br
.in -1c
.SS "Funzioni"

.in +1c
.ti -1c
.RI "int \fBelf32_check\fP (\fBelf32_hdr_t\fP *hdr)"
.br
.ti -1c
.RI "void * \fBelf32_load\fP (void *image)"
.br
.in -1c
.SH "Documentazione delle definizioni"
.PP 
.SS "#define check(cond)"
\fBValore:\fP
.PP
.nf
if(cond) {                   \\
			errno = ENOEXEC;     \
            return -1;              \
        }
.fi
.SS "#define EI_CLASS   4"

.PP
Definizione alla linea 20 del file exec\&.c\&.
.SS "#define EI_DATA   5"

.PP
Definizione alla linea 21 del file exec\&.c\&.
.SS "#define EI_MAG0   0"

.PP
Definizione alla linea 16 del file exec\&.c\&.
.SS "#define EI_MAG1   1"

.PP
Definizione alla linea 17 del file exec\&.c\&.
.SS "#define EI_MAG2   2"

.PP
Definizione alla linea 18 del file exec\&.c\&.
.SS "#define EI_MAG3   3"

.PP
Definizione alla linea 19 del file exec\&.c\&.
.SS "#define EI_NIDENT   16"

.PP
Definizione alla linea 15 del file exec\&.c\&.
.SS "#define EI_PAD   7"

.PP
Definizione alla linea 23 del file exec\&.c\&.
.SS "#define EI_VERSION   6"

.PP
Definizione alla linea 22 del file exec\&.c\&.
.SS "#define ELF_CLASS_32   1"

.PP
Definizione alla linea 30 del file exec\&.c\&.
.SS "#define ELF_CLASS_64   2"

.PP
Definizione alla linea 31 del file exec\&.c\&.
.SS "#define ELF_DATA_LSB   1"

.PP
Definizione alla linea 33 del file exec\&.c\&.
.SS "#define ELF_DATA_MSB   2"

.PP
Definizione alla linea 34 del file exec\&.c\&.
.SS "#define ELF_MAG0   0x7F"

.PP
Definizione alla linea 25 del file exec\&.c\&.
.SS "#define ELF_MAG1   'E'"

.PP
Definizione alla linea 26 del file exec\&.c\&.
.SS "#define ELF_MAG2   'L'"

.PP
Definizione alla linea 27 del file exec\&.c\&.
.SS "#define ELF_MAG3   'F'"

.PP
Definizione alla linea 28 del file exec\&.c\&.
.SS "#define SHF_ALLOC   2"

.PP
Definizione alla linea 51 del file exec\&.c\&.
.SS "#define SHF_EXECINSTR   4"

.PP
Definizione alla linea 52 del file exec\&.c\&.
.SS "#define SHF_MASK   0xF0000000"

.PP
Definizione alla linea 53 del file exec\&.c\&.
.SS "#define SHF_WRITE   1"

.PP
Definizione alla linea 50 del file exec\&.c\&.
.SS "#define SHT_DYNAMIC   6"

.PP
Definizione alla linea 43 del file exec\&.c\&.
.SS "#define SHT_DYNSYM   11"

.PP
Definizione alla linea 48 del file exec\&.c\&.
.SS "#define SHT_HASH   5"

.PP
Definizione alla linea 42 del file exec\&.c\&.
.SS "#define SHT_NOBITS   8"

.PP
Definizione alla linea 45 del file exec\&.c\&.
.SS "#define SHT_NOTE   7"

.PP
Definizione alla linea 44 del file exec\&.c\&.
.SS "#define SHT_NULL   0"

.PP
Definizione alla linea 37 del file exec\&.c\&.
.SS "#define SHT_PROGBITS   1"

.PP
Definizione alla linea 38 del file exec\&.c\&.
.SS "#define SHT_REL   9"

.PP
Definizione alla linea 46 del file exec\&.c\&.
.SS "#define SHT_RELA   4"

.PP
Definizione alla linea 41 del file exec\&.c\&.
.SS "#define SHT_SHLIB   10"

.PP
Definizione alla linea 47 del file exec\&.c\&.
.SS "#define SHT_STRTAB   3"

.PP
Definizione alla linea 40 del file exec\&.c\&.
.SS "#define SHT_SYMTAB   2"

.PP
Definizione alla linea 39 del file exec\&.c\&.
.SH "Documentazione delle ridefinizioni di tipo (typedef)"
.PP 
.SS "typedef \fBuint32_t\fP \fBElf32_Addr\fP"

.PP
Definizione alla linea 8 del file exec\&.c\&.
.SS "typedef \fBuint16_t\fP \fBElf32_Half\fP"

.PP
Definizione alla linea 9 del file exec\&.c\&.
.SS "typedef struct \fBelf32_hdr\fP  \fBelf32_hdr_t\fP"

.SS "typedef \fBuint32_t\fP \fBElf32_Off\fP"

.PP
Definizione alla linea 10 del file exec\&.c\&.
.SS "typedef struct \fBelf32_shdr\fP  \fBelf32_shdr_t\fP"

.SS "typedef int32_t \fBElf32_Sword\fP"

.PP
Definizione alla linea 11 del file exec\&.c\&.
.SS "typedef \fBuint32_t\fP \fBElf32_Word\fP"

.PP
Definizione alla linea 12 del file exec\&.c\&.
.SH "Documentazione delle funzioni"
.PP 
.SS "int elf32_check (\fBelf32_hdr_t\fP *hdr)"

.PP
Definizione alla linea 89 del file exec\&.c\&.
.PP
Referenzia check, elf32_hdr::e_ident, EI_CLASS, EI_DATA, EI_MAG0, EI_MAG1, EI_MAG2, EI_MAG3, ELF_CLASS_32, ELF_DATA_LSB, ELF_MAG0, ELF_MAG1, ELF_MAG2, e ELF_MAG3\&.
.PP
.nf
89                                   {
90 
91     #define check(cond)             \
92         if(cond) {                  \
93             errno = ENOEXEC;        \
94             return -1;              \
95         }
96 
97     check(
98         (hdr->e_ident[EI_MAG0] != ELF_MAG0) ||
99         (hdr->e_ident[EI_MAG1] != ELF_MAG1) ||
100         (hdr->e_ident[EI_MAG2] != ELF_MAG2) ||
101         (hdr->e_ident[EI_MAG3] != ELF_MAG3)
102     )
103 
104     check(hdr->e_ident[EI_CLASS] != ELF_CLASS_32)
105     check(hdr->e_ident[EI_DATA] != ELF_DATA_LSB)
106 
107     return 0;
108 }
.fi
.SS "void* elf32_load (void *image)"

.PP
Definizione alla linea 111 del file exec\&.c\&.
.PP
Referenzia elf32_hdr::e_shoff, elf32_check(), errno, kprintf, MM_UBASE, MM_USIZE, panic(), elf32_shdr::sh_addr, elf32_shdr::sh_offset, elf32_shdr::sh_size, uint32_t, vmm_alloc(), VMM_FLAGS_DEFAULT, e VMM_FLAGS_USER\&.
.PP
.nf
111                               {
112     if(image == NULL) {
113         errno = EINVAL;
114         return NULL;
115     }
116 
117     if(elf32_check(image) < 0)
118         return NULL;
119 
120     elf32_hdr_t* hdr = (elf32_hdr_t*) image;
121     elf32_shdr_t* sec = (elf32_shdr_t*) ((uint32_t) hdr->e_shoff + (uint32_t) hdr);
122     
123     int sn = hdr->e_shnum;
124     int ss = hdr->e_shentsize;
125      
126     for(int i = 0; i < sn; i++) {
127         if((sec->sh_addr + sec->sh_size) < MM_UBASE || (sec->sh_addr + sec->sh_size) > (MM_UBASE + MM_USIZE))
128             panic("elf section overflow");
129             
130 
131 #ifdef ELF_DEBUG
132         kprintf("elf: copy section to 0x%8x (%d KB)\n", sec->sh_addr, sh->sh_size / 1024);
133 #endif
134         
135         if(sec->sh_addr && sec->sh_offset) {
136             if(vmm_alloc((void*) sec->sh_addr, sec->sh_size, VMM_FLAGS_DEFAULT | VMM_FLAGS_USER))
137                 memcpy((void*) sec->sh_addr, (void*) ((uint32_t) hdr + sec->sh_offset), sec->sh_size);
138             else
139                 panic("elf: cannot allocate memory");
140         }
141 
142         sec = (elf32_shdr_t*) ((uint32_t) sec + ss);
143     }
144 
145     return (void*) hdr->e_entry;
146 }
.fi
.SH "Autore"
.PP 
Generato automaticamente da Doxygen per aPlus a partire dal codice sorgente\&.
