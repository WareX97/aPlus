.TH "src/exec.c" 3 "Fri Nov 14 2014" "Version 0.1" "aPlus" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/exec.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include <aplus\&.h>\fP
.br
\fC#include <aplus/mm\&.h>\fP
.br
\fC#include <stdint\&.h>\fP
.br
\fC#include <errno\&.h>\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBelf32_hdr\fP"
.br
.RI "\fIELF32 Header\&. \fP"
.ti -1c
.RI "struct \fBelf32_shdr\fP"
.br
.RI "\fIELF32 Section Header\&. \fP"
.ti -1c
.RI "struct \fBelf32_phdr\fP"
.br
.RI "\fIELF32 Program Header\&. \fP"
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBELF32_ADDRSPACE_MIN_LENGTH\fP   0x100000"
.br
.ti -1c
.RI "#define \fBEI_NIDENT\fP   16"
.br
.ti -1c
.RI "#define \fBEI_MAG0\fP   0"
.br
.ti -1c
.RI "#define \fBEI_MAG1\fP   1"
.br
.ti -1c
.RI "#define \fBEI_MAG2\fP   2"
.br
.ti -1c
.RI "#define \fBEI_MAG3\fP   3"
.br
.ti -1c
.RI "#define \fBEI_CLASS\fP   4"
.br
.ti -1c
.RI "#define \fBEI_DATA\fP   5"
.br
.ti -1c
.RI "#define \fBEI_VERSION\fP   6"
.br
.ti -1c
.RI "#define \fBEI_PAD\fP   7"
.br
.ti -1c
.RI "#define \fBELF_MAG0\fP   0x7F"
.br
.ti -1c
.RI "#define \fBELF_MAG1\fP   'E'"
.br
.ti -1c
.RI "#define \fBELF_MAG2\fP   'L'"
.br
.ti -1c
.RI "#define \fBELF_MAG3\fP   'F'"
.br
.ti -1c
.RI "#define \fBELF_CLASS_32\fP   1"
.br
.ti -1c
.RI "#define \fBELF_CLASS_64\fP   2"
.br
.ti -1c
.RI "#define \fBELF_DATA_LSB\fP   1"
.br
.ti -1c
.RI "#define \fBELF_DATA_MSB\fP   2"
.br
.ti -1c
.RI "#define \fBSHT_NULL\fP   0"
.br
.ti -1c
.RI "#define \fBSHT_PROGBITS\fP   1"
.br
.ti -1c
.RI "#define \fBSHT_SYMTAB\fP   2"
.br
.ti -1c
.RI "#define \fBSHT_STRTAB\fP   3"
.br
.ti -1c
.RI "#define \fBSHT_RELA\fP   4"
.br
.ti -1c
.RI "#define \fBSHT_HASH\fP   5"
.br
.ti -1c
.RI "#define \fBSHT_DYNAMIC\fP   6"
.br
.ti -1c
.RI "#define \fBSHT_NOTE\fP   7"
.br
.ti -1c
.RI "#define \fBSHT_NOBITS\fP   8"
.br
.ti -1c
.RI "#define \fBSHT_REL\fP   9"
.br
.ti -1c
.RI "#define \fBSHT_SHLIB\fP   10"
.br
.ti -1c
.RI "#define \fBSHT_DYNSYM\fP   11"
.br
.ti -1c
.RI "#define \fBSHF_WRITE\fP   1"
.br
.ti -1c
.RI "#define \fBSHF_ALLOC\fP   2"
.br
.ti -1c
.RI "#define \fBSHF_EXECINSTR\fP   4"
.br
.ti -1c
.RI "#define \fBSHF_MASK\fP   0xF0000000"
.br
.ti -1c
.RI "#define \fBPT_NULL\fP   0"
.br
.ti -1c
.RI "#define \fBPT_LOAD\fP   1"
.br
.ti -1c
.RI "#define \fBPT_DYNAMIC\fP   2"
.br
.ti -1c
.RI "#define \fBPT_INTERP\fP   3"
.br
.ti -1c
.RI "#define \fBPT_NOTE\fP   4"
.br
.ti -1c
.RI "#define \fBPT_SHLIB\fP   5"
.br
.ti -1c
.RI "#define \fBPT_PHDR\fP   6"
.br
.ti -1c
.RI "#define \fBPT_LOPROC\fP   0x70000000"
.br
.ti -1c
.RI "#define \fBPT_HIPROC\fP   0x7FFFFFFF"
.br
.ti -1c
.RI "#define \fBELF_DEBUG\fP"
.br
.RI "\fIEnable or disable debug for ELF\&. \fP"
.ti -1c
.RI "#define \fBcheck\fP(cond)"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef \fBuint32_t\fP \fBElf32_Addr\fP"
.br
.ti -1c
.RI "typedef \fBuint16_t\fP \fBElf32_Half\fP"
.br
.ti -1c
.RI "typedef \fBuint32_t\fP \fBElf32_Off\fP"
.br
.ti -1c
.RI "typedef int32_t \fBElf32_Sword\fP"
.br
.ti -1c
.RI "typedef \fBuint32_t\fP \fBElf32_Word\fP"
.br
.ti -1c
.RI "typedef struct \fBelf32_hdr\fP \fBelf32_hdr_t\fP"
.br
.RI "\fIELF32 Header\&. \fP"
.ti -1c
.RI "typedef struct \fBelf32_shdr\fP \fBelf32_shdr_t\fP"
.br
.RI "\fIELF32 Section Header\&. \fP"
.ti -1c
.RI "typedef struct \fBelf32_phdr\fP \fBelf32_phdr_t\fP"
.br
.RI "\fIELF32 Program Header\&. \fP"
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBelf32_check\fP (\fBelf32_hdr_t\fP *hdr)"
.br
.RI "\fICheck for valid ELF32 header\&. \fP"
.ti -1c
.RI "int \fBelf32_getspace\fP (\fBelf32_hdr_t\fP *hdr, void **ptr, size_t *\fBsize\fP)"
.br
.RI "\fIGet Address Space of ELF32 Executable\&. \fP"
.ti -1c
.RI "void * \fBelf32_load\fP (void *image, int *vaddr, int *vsize)"
.br
.RI "\fILoad a ELF32 Executable image\&. \fP"
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define check(cond)"
\fBValue:\fP
.PP
.nf
if(cond) {                 \\
			errno = ENOEXEC;     \
            return -1;              \
        }
.fi
.SS "#define EI_CLASS   4"

.PP
Definition at line 22 of file exec\&.c\&.
.SS "#define EI_DATA   5"

.PP
Definition at line 23 of file exec\&.c\&.
.SS "#define EI_MAG0   0"

.PP
Definition at line 18 of file exec\&.c\&.
.SS "#define EI_MAG1   1"

.PP
Definition at line 19 of file exec\&.c\&.
.SS "#define EI_MAG2   2"

.PP
Definition at line 20 of file exec\&.c\&.
.SS "#define EI_MAG3   3"

.PP
Definition at line 21 of file exec\&.c\&.
.SS "#define EI_NIDENT   16"

.PP
Definition at line 17 of file exec\&.c\&.
.SS "#define EI_PAD   7"

.PP
Definition at line 25 of file exec\&.c\&.
.SS "#define EI_VERSION   6"

.PP
Definition at line 24 of file exec\&.c\&.
.SS "#define ELF32_ADDRSPACE_MIN_LENGTH   0x100000"

.PP
Definition at line 7 of file exec\&.c\&.
.SS "#define ELF_CLASS_32   1"

.PP
Definition at line 32 of file exec\&.c\&.
.SS "#define ELF_CLASS_64   2"

.PP
Definition at line 33 of file exec\&.c\&.
.SS "#define ELF_DATA_LSB   1"

.PP
Definition at line 35 of file exec\&.c\&.
.SS "#define ELF_DATA_MSB   2"

.PP
Definition at line 36 of file exec\&.c\&.
.SS "#define ELF_DEBUG"

.PP
Enable or disable debug for ELF\&. 
.PP
Definition at line 72 of file exec\&.c\&.
.SS "#define ELF_MAG0   0x7F"

.PP
Definition at line 27 of file exec\&.c\&.
.SS "#define ELF_MAG1   'E'"

.PP
Definition at line 28 of file exec\&.c\&.
.SS "#define ELF_MAG2   'L'"

.PP
Definition at line 29 of file exec\&.c\&.
.SS "#define ELF_MAG3   'F'"

.PP
Definition at line 30 of file exec\&.c\&.
.SS "#define PT_DYNAMIC   2"

.PP
Definition at line 61 of file exec\&.c\&.
.SS "#define PT_HIPROC   0x7FFFFFFF"

.PP
Definition at line 67 of file exec\&.c\&.
.SS "#define PT_INTERP   3"

.PP
Definition at line 62 of file exec\&.c\&.
.SS "#define PT_LOAD   1"

.PP
Definition at line 60 of file exec\&.c\&.
.SS "#define PT_LOPROC   0x70000000"

.PP
Definition at line 66 of file exec\&.c\&.
.SS "#define PT_NOTE   4"

.PP
Definition at line 63 of file exec\&.c\&.
.SS "#define PT_NULL   0"

.PP
Definition at line 59 of file exec\&.c\&.
.SS "#define PT_PHDR   6"

.PP
Definition at line 65 of file exec\&.c\&.
.SS "#define PT_SHLIB   5"

.PP
Definition at line 64 of file exec\&.c\&.
.SS "#define SHF_ALLOC   2"

.PP
Definition at line 53 of file exec\&.c\&.
.SS "#define SHF_EXECINSTR   4"

.PP
Definition at line 54 of file exec\&.c\&.
.SS "#define SHF_MASK   0xF0000000"

.PP
Definition at line 55 of file exec\&.c\&.
.SS "#define SHF_WRITE   1"

.PP
Definition at line 52 of file exec\&.c\&.
.SS "#define SHT_DYNAMIC   6"

.PP
Definition at line 45 of file exec\&.c\&.
.SS "#define SHT_DYNSYM   11"

.PP
Definition at line 50 of file exec\&.c\&.
.SS "#define SHT_HASH   5"

.PP
Definition at line 44 of file exec\&.c\&.
.SS "#define SHT_NOBITS   8"

.PP
Definition at line 47 of file exec\&.c\&.
.SS "#define SHT_NOTE   7"

.PP
Definition at line 46 of file exec\&.c\&.
.SS "#define SHT_NULL   0"

.PP
Definition at line 39 of file exec\&.c\&.
.SS "#define SHT_PROGBITS   1"

.PP
Definition at line 40 of file exec\&.c\&.
.SS "#define SHT_REL   9"

.PP
Definition at line 48 of file exec\&.c\&.
.SS "#define SHT_RELA   4"

.PP
Definition at line 43 of file exec\&.c\&.
.SS "#define SHT_SHLIB   10"

.PP
Definition at line 49 of file exec\&.c\&.
.SS "#define SHT_STRTAB   3"

.PP
Definition at line 42 of file exec\&.c\&.
.SS "#define SHT_SYMTAB   2"

.PP
Definition at line 41 of file exec\&.c\&.
.SH "Typedef Documentation"
.PP 
.SS "typedef \fBuint32_t\fP \fBElf32_Addr\fP"

.PP
Definition at line 10 of file exec\&.c\&.
.SS "typedef \fBuint16_t\fP \fBElf32_Half\fP"

.PP
Definition at line 11 of file exec\&.c\&.
.SS "typedef struct \fBelf32_hdr\fP  \fBelf32_hdr_t\fP"

.PP
ELF32 Header\&. 
.SS "typedef \fBuint32_t\fP \fBElf32_Off\fP"

.PP
Definition at line 12 of file exec\&.c\&.
.SS "typedef struct \fBelf32_phdr\fP  \fBelf32_phdr_t\fP"

.PP
ELF32 Program Header\&. 
.SS "typedef struct \fBelf32_shdr\fP  \fBelf32_shdr_t\fP"

.PP
ELF32 Section Header\&. 
.SS "typedef int32_t \fBElf32_Sword\fP"

.PP
Definition at line 13 of file exec\&.c\&.
.SS "typedef \fBuint32_t\fP \fBElf32_Word\fP"

.PP
Definition at line 14 of file exec\&.c\&.
.SH "Function Documentation"
.PP 
.SS "int elf32_check (\fBelf32_hdr_t\fP *hdr)"

.PP
Check for valid ELF32 header\&. 
.PP
\fBParameters:\fP
.RS 4
\fIhdr\fP ELF32 Header\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
0 for valid header or -1 in case of errors\&. 
.RE
.PP

.PP
Definition at line 132 of file exec\&.c\&.
.PP
References check, elf32_hdr::e_ident, EI_CLASS, EI_DATA, EI_MAG0, EI_MAG1, EI_MAG2, EI_MAG3, ELF_CLASS_32, ELF_DATA_LSB, ELF_MAG0, ELF_MAG1, ELF_MAG2, ELF_MAG3, and errno\&.
.PP
.nf
132                                   {
133 
134     if(!hdr) {
135         errno = EINVAL; 
136         return -1;
137     }
138 
139     #define check(cond)             \
140         if(cond) {                  \
141             errno = ENOEXEC;        \
142             return -1;              \
143         }
144 
145     check(
146         (hdr->e_ident[EI_MAG0] != ELF_MAG0) ||
147         (hdr->e_ident[EI_MAG1] != ELF_MAG1) ||
148         (hdr->e_ident[EI_MAG2] != ELF_MAG2) ||
149         (hdr->e_ident[EI_MAG3] != ELF_MAG3)
150     )
151 
152     check(hdr->e_ident[EI_CLASS] != ELF_CLASS_32)
153     check(hdr->e_ident[EI_DATA] != ELF_DATA_LSB)
154 
155     return 0;
156 }
.fi
.SS "int elf32_getspace (\fBelf32_hdr_t\fP *hdr, void **ptr, size_t *size)"

.PP
Get Address Space of ELF32 Executable\&. 
.PP
\fBParameters:\fP
.RS 4
\fIhdr\fP ELF32 Header\&. 
.br
\fIptr\fP Pointer to start of memory address\&. 
.br
\fIsize\fP Size of memory address\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
if success 0, otherwise -1\&. 
.RE
.PP

.PP
Definition at line 166 of file exec\&.c\&.
.PP
References elf32_hdr::e_phoff, ELF32_ADDRSPACE_MIN_LENGTH, elf32_check(), kprintf(), elf32_phdr::p_memsz, elf32_phdr::p_vaddr, and uint32_t\&.
.PP
.nf
166                                                                {
167     if(elf32_check(hdr) < 0)
168         return -1;
169 
170     elf32_phdr_t* phdr = (elf32_phdr_t*) ((uint32_t) hdr->e_phoff + (uint32_t) hdr);
171     int pn = hdr->e_phnum;
172     int ps = hdr->e_phentsize;
173 
174     int p = 0;
175     int s = 0;
176 
177     for(int i = 0; i < pn; i++) {
178         if(!p || p > phdr->p_vaddr)
179             p = phdr->p_vaddr;
180 
181         s += phdr->p_memsz;
182         phdr = (elf32_phdr_t*) ((uint32_t) phdr + ps);
183     }
184 
185     if(s < ELF32_ADDRSPACE_MIN_LENGTH)
186         s = ELF32_ADDRSPACE_MIN_LENGTH;
187 
188 #ifdef ELF_DEBUG
189     kprintf("elf: address space at 0x%x (%d Bytes)\n", p, s);
190 #endif
191 
192 
193     if(ptr)
194         *ptr = p;
195 
196     if(size)
197         *size = s;
198 
199     return 0;
200 }
.fi
.SS "void* elf32_load (void *image, int *vaddr, int *vsize)"

.PP
Load a ELF32 Executable image\&. 
.PP
\fBParameters:\fP
.RS 4
\fIimage\fP pointer to buffer address of a executable loaded in memory\&. 
.br
\fIvaddr\fP Address of memory space needed\&. 
.br
\fIvsize\fP Size of memory space\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Entry Point address\&. 
.RE
.PP

.PP
Definition at line 210 of file exec\&.c\&.
.PP
References elf32_hdr::e_shoff, elf32_check(), elf32_getspace(), errno, kprintf(), MM_UBASE, MM_USIZE, panic(), elf32_shdr::sh_addr, elf32_shdr::sh_offset, elf32_shdr::sh_size, uint32_t, vmm_alloc(), VMM_FLAGS_DEFAULT, and VMM_FLAGS_USER\&.
.PP
.nf
210                                                       {
211     if(image == NULL) {
212         errno = EINVAL;
213         return NULL;
214     }
215 
216     if(elf32_check(image) < 0)
217         return NULL;
218 
219     elf32_hdr_t* hdr = (elf32_hdr_t*) image;
220 
221     int iptr, isiz;
222     if(elf32_getspace(hdr, &iptr, &isiz) != 0)
223         panic("elf: cannot found a valid address space"); 
224     vmm_alloc(iptr, isiz, VMM_FLAGS_DEFAULT | VMM_FLAGS_USER);
225 
226 
227     if(vaddr)
228         *vaddr = iptr;
229     if(vsize)
230         *vsize = isiz;
231 
232 
233     elf32_shdr_t* sec = (elf32_shdr_t*) ((uint32_t) hdr->e_shoff + (uint32_t) hdr);
234     
235     int sn = hdr->e_shnum;
236     int ss = hdr->e_shentsize;
237 
238     for(int i = 0; i < sn; i++) {
239         
240         if(sec->sh_addr && sec->sh_offset) {
241 
242 #ifdef ELF_DEBUG
243             kprintf("elf: copy section to 0x%8x (%d Bytes)\n", sec->sh_addr, sec->sh_size);
244 #endif
245 
246 
247             if((sec->sh_addr + sec->sh_size) < MM_UBASE || (sec->sh_addr + sec->sh_size) > (MM_UBASE + MM_USIZE))
248                 panic("elf: section overflow");
249             
250             
251             memcpy((void*) sec->sh_addr, (void*) ((uint32_t) hdr + sec->sh_offset), sec->sh_size);
252         }
253 
254         sec = (elf32_shdr_t*) ((uint32_t) sec + ss);
255     }
256 
257 #ifdef ELF_DEBUG
258     kprintf("elf: entrypoint at 0x%8x\n", hdr->e_entry);
259 #endif
260 
261     return (void*) hdr->e_entry;
262 }
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for aPlus from the source code\&.
