.TH "src/fs/iso9660/iso9660.c" 3 "Sun Nov 16 2014" "Version 0.1" "aPlus" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/fs/iso9660/iso9660.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include <aplus\&.h>\fP
.br
\fC#include <aplus/fs\&.h>\fP
.br
\fC#include <aplus/task\&.h>\fP
.br
\fC#include <aplus/mm\&.h>\fP
.br
\fC#include <stdint\&.h>\fP
.br
\fC#include <string\&.h>\fP
.br
\fC#include <unistd\&.h>\fP
.br
\fC#include <dirent\&.h>\fP
.br
\fC#include <fcntl\&.h>\fP
.br
\fC#include <sys/types\&.h>\fP
.br
\fC#include 'iso9660\&.h'\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "\fBuint32_t\fP \fBiso9660_getroot\fP (\fBinode_t\fP *dev)"
.br
.ti -1c
.RI "int \fBiso9660_check\fP (\fBinode_t\fP *dev)"
.br
.ti -1c
.RI "void \fBiso9660_checkname\fP (char *\fBname\fP)"
.br
.ti -1c
.RI "\fBuint16_t\fP \fBiso9660_getmsb16\fP (\fBuint32_t\fP val)"
.br
.ti -1c
.RI "\fBuint32_t\fP \fBiso9660_getmsb32\fP (uint64_t val)"
.br
.ti -1c
.RI "\fBuint16_t\fP \fBiso9660_getlsb16\fP (\fBuint32_t\fP val)"
.br
.ti -1c
.RI "\fBuint32_t\fP \fBiso9660_getlsb32\fP (uint64_t val)"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "int iso9660_check (\fBinode_t\fP *dev)"

.PP
Definition at line 30 of file iso9660\&.c\&.
.PP
References fs_read(), ISO9660_ID, ISO9660_PVD, ISO9660_VOLDESC_SIZE, kfree(), kmalloc(), and inode::position\&.
.PP
.nf
30                                 {
31     iso9660_pvd_t* pvd = (iso9660_pvd_t*) kmalloc(ISO9660_VOLDESC_SIZE);
32     memset(pvd, 0, ISO9660_VOLDESC_SIZE);
33 
34     dev->position = ISO9660_PVD;
35     if(fs_read(dev, pvd, ISO9660_VOLDESC_SIZE) != ISO9660_VOLDESC_SIZE) {
36         kfree(pvd);
37         return 0;
38     }
39 
40     int ret = strncmp(pvd->id, ISO9660_ID, 5);
41     kfree(pvd);
42 
43     return ret;
44 }
.fi
.SS "void iso9660_checkname (char *name)"

.PP
Definition at line 46 of file iso9660\&.c\&.
.PP
.nf
46                                    {
47     char* p = strchr(name, ';');
48     if(p) {
49         *p-- = 0;
50     
51         if(*p == '\&.')
52             *p = 0;
53     }
54 
55     for(int i = 0; i < strlen(name); i++)
56         if(name[i] >= 'A' && name[i] <= 'Z')
57             name[i] += 32;
58 }
.fi
.SS "\fBuint16_t\fP iso9660_getlsb16 (\fBuint32_t\fPval)"

.PP
Definition at line 68 of file iso9660\&.c\&.
.PP
.nf
68                                         {
69     return (val >> 0) & 0xFFFF;
70 }
.fi
.SS "\fBuint32_t\fP iso9660_getlsb32 (uint64_tval)"

.PP
Definition at line 72 of file iso9660\&.c\&.
.PP
.nf
72                                         {
73     return (val >> 0) & 0xFFFFFFFF;
74 }
.fi
.SS "\fBuint16_t\fP iso9660_getmsb16 (\fBuint32_t\fPval)"

.PP
Definition at line 60 of file iso9660\&.c\&.
.PP
.nf
60                                         {
61     return (val >> 16) & 0xFFFF;
62 }
.fi
.SS "\fBuint32_t\fP iso9660_getmsb32 (uint64_tval)"

.PP
Definition at line 64 of file iso9660\&.c\&.
.PP
.nf
64                                         {
65     return (val >> 32) & 0xFFFFFFFF;
66 }
.fi
.SS "\fBuint32_t\fP iso9660_getroot (\fBinode_t\fP *dev)"

.PP
Definition at line 15 of file iso9660\&.c\&.
.PP
References fs_read(), ISO9660_PVD, ISO9660_VOLDESC_SIZE, kfree(), kmalloc(), inode::position, and uint32_t\&.
.PP
.nf
15                                        {
16     iso9660_pvd_t* pvd = (iso9660_pvd_t*) kmalloc(ISO9660_VOLDESC_SIZE);
17     memset(pvd, 0, ISO9660_VOLDESC_SIZE);
18 
19     dev->position = ISO9660_PVD;
20     if(fs_read(dev, pvd, ISO9660_VOLDESC_SIZE) != ISO9660_VOLDESC_SIZE) {
21         kfree(pvd);
22         return 0;
23     }
24 
25 
26     return (uint32_t) pvd->rootdir;
27 }
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for aPlus from the source code\&.
