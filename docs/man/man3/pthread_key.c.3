.TH "usr/src/libpthread/src/pthread_key.c" 3 "Fri Nov 14 2014" "Version 0.1" "aPlus" \" -*- nroff -*-
.ad l
.nh
.SH NAME
usr/src/libpthread/src/pthread_key.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include <stdint\&.h>\fP
.br
\fC#include <pthread\&.h>\fP
.br
\fC#include 'pthread_internal\&.h'\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "\fBPUBLIC\fP int \fBpthread_key_create\fP (\fBpthread_key_t\fP *key, void(*destructor)(void *))"
.br
.ti -1c
.RI "\fBPUBLIC\fP int \fBpthread_key_delete\fP (\fBpthread_key_t\fP key)"
.br
.ti -1c
.RI "\fBPUBLIC\fP int \fBpthread_setspecific\fP (\fBpthread_key_t\fP key, const void *\fBvalue\fP)"
.br
.ti -1c
.RI "\fBPUBLIC\fP void * \fBpthread_getspecific\fP (\fBpthread_key_t\fP key)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "\fBPRIVATE\fP \fB__pthread_key_t\fP \fB__pthread_keys\fP [\fBPTHREAD_KEYS_MAX\fP] = { }"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "\fBPUBLIC\fP void* pthread_getspecific (\fBpthread_key_t\fPkey)"

.PP
Definition at line 65 of file pthread_key\&.c\&.
.PP
References __pthread_keys, errno, PTHREAD_KEYS_MAX, and __pthread_key::value\&.
.PP
.nf
65                                                     {
66     if(key > PTHREAD_KEYS_MAX) {
67         errno = EINVAL;
68         return 0;
69     }
70 
71     if(__pthread_keys[key]\&.used == 0) {
72         errno = EINVAL;
73         return 0;
74     }
75 
76     return __pthread_keys[key]\&.value;
77 }
.fi
.SS "\fBPUBLIC\fP int pthread_key_create (\fBpthread_key_t\fP *key, void(*)(void *)destructor)"

.PP
Definition at line 9 of file pthread_key\&.c\&.
.PP
References __pthread_keys, __pthread_key::dtor, errno, PTHREAD_KEYS_MAX, __pthread_key::used, and __pthread_key::value\&.
.PP
.nf
9                                                                               {
10     if(!key) {
11         errno = EINVAL;
12         return 1;
13     }
14 
15     int i;
16     for(i = 0; i < PTHREAD_KEYS_MAX; i++) {
17         if(__pthread_keys[i]\&.used == 0) {
18             __pthread_keys[i]\&.used = 1;
19             __pthread_keys[i]\&.dtor = destructor;
20             __pthread_keys[i]\&.value = NULL;
21 
22             *key = i;
23             return 0;
24         }
25     }
26 
27     errno = EAGAIN;
28     return 1;
29 }
.fi
.SS "\fBPUBLIC\fP int pthread_key_delete (\fBpthread_key_t\fPkey)"

.PP
Definition at line 32 of file pthread_key\&.c\&.
.PP
References __pthread_keys, __pthread_key::dtor, errno, PTHREAD_KEYS_MAX, __pthread_key::used, __pthread_key::value, and value\&.
.PP
.nf
32                                                  {
33     if(key > PTHREAD_KEYS_MAX) {
34         errno = EINVAL;
35         return 1;
36     }
37 
38     if(__pthread_keys[key]\&.dtor)
39         __pthread_keys[key]\&.dtor(__pthread_keys[key]\&.value);
40 
41     __pthread_keys[key]\&.used = 0;
42     __pthread_keys[key]\&.dtor = 0;
43     __pthread_keys[key]\&.value = NULL;
44     
45     return 0;
46 }
.fi
.SS "\fBPUBLIC\fP int pthread_setspecific (\fBpthread_key_t\fPkey, const void *value)"

.PP
Definition at line 49 of file pthread_key\&.c\&.
.PP
References __pthread_keys, errno, PTHREAD_KEYS_MAX, and __pthread_key::value\&.
.PP
.nf
49                                                                      {
50     if(key > PTHREAD_KEYS_MAX) {
51         errno = EINVAL;
52         return 1;
53     }
54 
55     if(__pthread_keys[key]\&.used == 0) {
56         errno = EINVAL;
57         return 1;
58     }
59 
60     __pthread_keys[key]\&.value = (void*) value;
61     return 0;
62 }
.fi
.SH "Variable Documentation"
.PP 
.SS "\fBPRIVATE\fP \fB__pthread_key_t\fP __pthread_keys[\fBPTHREAD_KEYS_MAX\fP] = { }"

.PP
Definition at line 7 of file pthread_key\&.c\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for aPlus from the source code\&.
