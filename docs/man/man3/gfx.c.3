.TH "usr/src/libatk/src/gfx.c" 3 "Sun Nov 16 2014" "Version 0.1" "aPlus" \" -*- nroff -*-
.ad l
.nh
.SH NAME
usr/src/libatk/src/gfx.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include <atk\&.h>\fP
.br
\fC#include <atk/gfx\&.h>\fP
.br
\fC#include <atk/bitmap\&.h>\fP
.br
\fC#include <stdint\&.h>\fP
.br
\fC#include <math\&.h>\fP
.br
\fC#include <errno\&.h>\fP
.br
\fC#include 'clrconv\&.h'\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "static void \fB__gfx_plot_pixel_32\fP (void *d, \fBatk_color_t\fP color)"
.br
.ti -1c
.RI "static void \fB__gfx_plot_pixel_24\fP (void *d, \fBatk_color_t\fP color)"
.br
.ti -1c
.RI "static void \fB__gfx_plot_pixel_16\fP (void *d, \fBatk_color_t\fP color)"
.br
.ti -1c
.RI "static \fBatk_color_t\fP \fB__gfx_read_pixel_32\fP (void *d)"
.br
.ti -1c
.RI "static \fBatk_color_t\fP \fB__gfx_read_pixel_24\fP (void *d)"
.br
.ti -1c
.RI "static \fBatk_color_t\fP \fB__gfx_read_pixel_16\fP (void *d)"
.br
.ti -1c
.RI "\fBatk_gfx_t\fP * \fBatk_gfx_create\fP (short width, short height, short \fBbpp\fP, void *buffer)"
.br
.ti -1c
.RI "void \fBatk_gfx_set\fP (\fBatk_gfx_t\fP *gfx)"
.br
.ti -1c
.RI "\fBatk_gfx_t\fP * \fBatk_gfx_get\fP ()"
.br
.ti -1c
.RI "int \fBatk_gfx_line\fP (\fBatk_bitmap_t\fP *b, int x0, int y0, int x1, int y1, \fBatk_color_t\fP color)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "\fBatk_gfx_t\fP * \fB__gfx\fP"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "static void __gfx_plot_pixel_16 (void *d, \fBatk_color_t\fPcolor)\fC [static]\fP"

.PP
Definition at line 26 of file gfx\&.c\&.
.PP
References __alphablend(), ATK_COLOR_A, R5G6B5_TO_V4F, uint16_t, and V4F_TO_R5G6B5\&.
.PP
.nf
26                                                             {
27     atk_color_t dc = R5G6B5_TO_V4F((*(uint16_t*) d));
28     atk_color_t df = __alphablend(dc, color, color[ATK_COLOR_A]);
29 
30     *(uint16_t*) d = V4F_TO_R5G6B5(df);
31 }
.fi
.SS "static void __gfx_plot_pixel_24 (void *d, \fBatk_color_t\fPcolor)\fC [static]\fP"

.PP
Definition at line 19 of file gfx\&.c\&.
.PP
References __alphablend(), ATK_COLOR_A, RGB_TO_V4F, uint32_t, and V4F_TO_RGB\&.
.PP
.nf
19                                                             {
20     atk_color_t dc = RGB_TO_V4F((*(uint32_t*) d));
21     atk_color_t df = __alphablend(dc, color, color[ATK_COLOR_A]);
22 
23     *(uint32_t*) d = V4F_TO_RGB(df);
24 }
.fi
.SS "static void __gfx_plot_pixel_32 (void *d, \fBatk_color_t\fPcolor)\fC [static]\fP"

.PP
Definition at line 12 of file gfx\&.c\&.
.PP
References __alphablend(), ARGB_TO_V4F, ATK_COLOR_A, uint32_t, and V4F_TO_ARGB\&.
.PP
.nf
12                                                             {
13     atk_color_t dc = ARGB_TO_V4F((*(uint32_t*) d));
14     atk_color_t df = __alphablend(dc, color, color[ATK_COLOR_A]);
15 
16     *(uint32_t*) d = V4F_TO_ARGB(df);
17 }
.fi
.SS "static \fBatk_color_t\fP __gfx_read_pixel_16 (void *d)\fC [static]\fP"

.PP
Definition at line 45 of file gfx\&.c\&.
.PP
References R5G6B5_TO_V4F, and uint16_t\&.
.PP
.nf
45                                                 {
46     atk_color_t dc = R5G6B5_TO_V4F((*(uint16_t*) d));
47 
48     return dc;
49 }
.fi
.SS "static \fBatk_color_t\fP __gfx_read_pixel_24 (void *d)\fC [static]\fP"

.PP
Definition at line 39 of file gfx\&.c\&.
.PP
References RGB_TO_V4F, and uint32_t\&.
.PP
.nf
39                                                 {
40     atk_color_t dc = RGB_TO_V4F((*(uint32_t*) d));
41 
42     return dc;
43 }
.fi
.SS "static \fBatk_color_t\fP __gfx_read_pixel_32 (void *d)\fC [static]\fP"

.PP
Definition at line 33 of file gfx\&.c\&.
.PP
References ARGB_TO_V4F, and uint32_t\&.
.PP
.nf
33                                                 {
34     atk_color_t dc = ARGB_TO_V4F((*(uint32_t*) d));
35 
36     return dc;
37 }
.fi
.SS "\fBatk_gfx_t\fP* atk_gfx_create (shortwidth, shortheight, shortbpp, void *buffer)"

.PP
Definition at line 53 of file gfx\&.c\&.
.PP
References atk_gfx::__get, __gfx_plot_pixel_16(), __gfx_plot_pixel_24(), __gfx_plot_pixel_32(), __gfx_read_pixel_16(), __gfx_read_pixel_24(), __gfx_read_pixel_32(), atk_gfx::__plot, atk_gfx::bpp, bpp, errno, atk_gfx::framebuffer, atk_gfx::height, atk_gfx::stride, and atk_gfx::width\&.
.PP
.nf
53                                                                               {
54     if(!(width && height && bpp && buffer)) {
55         errno = EINVAL;
56         return NULL;
57     }
58 
59     atk_gfx_t* gfx = (atk_gfx_t*) malloc(width * height * (bpp / 8));
60     gfx->width = width;
61     gfx->height = height;
62     gfx->bpp = bpp;
63     gfx->stride = width * (bpp / 8);
64     gfx->framebuffer = buffer;
65 
66     switch(bpp) {
67         case 16:
68             gfx->__plot = __gfx_plot_pixel_16;
69             gfx->__get = __gfx_read_pixel_16;
70             break;
71         case 24:
72             gfx->__plot = __gfx_plot_pixel_24;
73             gfx->__get = __gfx_read_pixel_24;
74             break;
75         case 32:
76             gfx->__plot = __gfx_plot_pixel_32;
77             gfx->__get = __gfx_read_pixel_32;
78             break;
79         default:
80             free(gfx);
81             errno = EINVAL;
82             return NULL;
83     }
84 
85     return gfx;
86 }
.fi
.SS "\fBatk_gfx_t\fP* atk_gfx_get ()"

.PP
Definition at line 92 of file gfx\&.c\&.
.PP
References __gfx\&.
.PP
.nf
92                          {
93     return __gfx;
94 }
.fi
.SS "int atk_gfx_line (\fBatk_bitmap_t\fP *b, intx0, inty0, intx1, inty1, \fBatk_color_t\fPcolor)"

.PP
Definition at line 98 of file gfx\&.c\&.
.PP
References atk_gfx::__plot, __SWAP, ATK_BITMAP_LOCK_RDWR, atk_bitmap_lockbits(), atk_bitmap_unlockbits(), ATK_COLOR_A, atk_gfx::bpp, bpp, errno, and uint32_t\&.
.PP
.nf
98                                                                                      {
99 
100     if(!b) {
101         errno = EINVAL;
102         return -1;
103     }
104 
105     if(x0 > x1)
106         __SWAP(x0, x1)
107 
108     if(y0 > y1)
109         __SWAP(y0, y1)
110 
111     atk_rect_t region = { x0, y0, x1, y1 };
112     void* buffer = atk_bitmap_lockbits(b, region, ATK_BITMAP_LOCK_RDWR);
113     if(!buffer)
114         return -1;
115     
116     x1 -= x0;
117     y1 -= y1;
118     x0 = 0;
119     y0 = 0;
120     
121     int x2 = 0;
122     int sx = 0;
123     int sy = 0;
124     int dx = x1;
125     int dy = y1;
126     int e = dx - dy;
127     int e2 = 0;
128     int ed = dx + dy == 0 ? 1 : sqrt((float) (dx * dx) + (float) (dy * dy));
129     int bpp = __gfx->bpp >> 3;
130     int stride = x1 * bpp;
131 
132     for(;;) {
133         color[ATK_COLOR_A] = abs(e - dx + dy) / ed;
134         __gfx->__plot((void*) ((uint32_t) buffer + (y0 * stride) + (x0 * bpp)), color);
135         
136         e2 = e;
137         x2 = x0;    
138 
139         if((e2 << 1) >= -dx) {
140             if(x0 == x1)
141                 break;
142 
143             if(e2 + dy < ed) {
144                 color[ATK_COLOR_A] = abs(e2 - dy) / ed;
145                 __gfx->__plot((void*) ((uint32_t) buffer + ((y0 + sy) * stride) + (x0 * bpp)), color);      
146             }
147 
148             e -= dy;
149             x0 += sx;
150         }
151 
152         if((e2 << 1) <= dy) {
153             if(y0 == y1)
154                 break;
155 
156             if(dx - e2 < ed) {
157                 color[ATK_COLOR_A] = abs(dx - e2) / ed;
158                 __gfx->__plot((void*) ((uint32_t) buffer + (y0 * stride) + ((x2 + sx) * bpp)), color);      
159             }
160 
161             e += dx;
162             y0 += sy;
163         }
164     }
165     
166     atk_bitmap_unlockbits(b);
167 }
.fi
.SS "void atk_gfx_set (\fBatk_gfx_t\fP *gfx)"

.PP
Definition at line 88 of file gfx\&.c\&.
.PP
.nf
88                                  {
89     __gfx = gfx;
90 }
.fi
.SH "Variable Documentation"
.PP 
.SS "\fBatk_gfx_t\fP* __gfx"

.PP
Definition at line 10 of file gfx\&.c\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for aPlus from the source code\&.
