.TH "usr/src/libatk/src/bitmap.c" 3 "Sun Nov 16 2014" "Version 0.1" "aPlus" \" -*- nroff -*-
.ad l
.nh
.SH NAME
usr/src/libatk/src/bitmap.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include <atk\&.h>\fP
.br
\fC#include <atk/bitmap\&.h>\fP
.br
\fC#include <atk/gfx\&.h>\fP
.br
\fC#include <stdint\&.h>\fP
.br
\fC#include <stdlib\&.h>\fP
.br
\fC#include <string\&.h>\fP
.br
\fC#include <errno\&.h>\fP
.br
\fC#include 'clrconv\&.h'\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "\fBatk_bitmap_t\fP * \fBatk_bitmap_create_for_data\fP (\fBuint16_t\fP width, \fBuint16_t\fP height, void *buffer)"
.br
.ti -1c
.RI "\fBatk_bitmap_t\fP * \fBatk_bitmap_create\fP (\fBuint16_t\fP width, \fBuint16_t\fP height)"
.br
.ti -1c
.RI "int \fBatk_destroy_bitmap\fP (\fBatk_bitmap_t\fP *b)"
.br
.ti -1c
.RI "void * \fBatk_bitmap_lockbits\fP (\fBatk_bitmap_t\fP *b, \fBatk_rect_t\fP rectangle, int \fBflags\fP)"
.br
.ti -1c
.RI "void \fBatk_bitmap_unlockbits\fP (\fBatk_bitmap_t\fP *b)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "\fBatk_gfx_t\fP * \fB__gfx\fP"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "\fBatk_bitmap_t\fP* atk_bitmap_create (\fBuint16_t\fPwidth, \fBuint16_t\fPheight)"

.PP
Definition at line 35 of file bitmap\&.c\&.
.PP
References atk_gfx::bpp, data, and errno\&.
.PP
.nf
35                                                                  {
36     if(!(width && height)) {
37         errno = EINVAL;
38         return NULL;
39     }
40 
41     void* data = (void*) malloc(width * height * (__gfx->bpp >> 3));
42     if(!data) {
43         errno = ENOMEM;
44         return NULL;
45     }
46 
47     return atk_create_bitmap_for_data(width, height, data);
48 }
.fi
.SS "\fBatk_bitmap_t\fP* atk_bitmap_create_for_data (\fBuint16_t\fPwidth, \fBuint16_t\fPheight, void *buffer)"

.PP
Definition at line 13 of file bitmap\&.c\&.
.PP
References ATK_SIZE_H, ATK_SIZE_W, atk_gfx::bpp, atk_bitmap::buffer, errno, atk_bitmap::lock, atk_bitmap::size, and atk_bitmap::stride\&.
.PP
.nf
13                                                                                         {
14     if(!(width && height && buffer)) {
15         errno = EINVAL;
16         return NULL;
17     }
18 
19     atk_bitmap_t* b = (atk_bitmap_t*) malloc(sizeof(atk_bitmap_t));
20     if(!b) {
21         errno = ENOMEM;
22         return NULL;
23     }
24 
25     b->size[ATK_SIZE_W] = width;
26     b->size[ATK_SIZE_H] = height;
27 
28     b->stride = width * (__gfx->bpp / 8);
29     b->lock = 0;
30     b->buffer = buffer;
31 
32     return b;
33 }
.fi
.SS "void* atk_bitmap_lockbits (\fBatk_bitmap_t\fP *b, \fBatk_rect_t\fPrectangle, intflags)"

.PP
Definition at line 68 of file bitmap\&.c\&.
.PP
References atk_bitmap::__lockdata, ATK_RECT_H, ATK_RECT_W, ATK_RECT_X, ATK_RECT_Y, atk_gfx::bpp, atk_bitmap::buffer, atk_bitmap_lockdata::data, data, errno, atk_bitmap_lockdata::flags, flags, atk_bitmap::lock, atk_bitmap_lockdata::region, size, atk_bitmap::stride, and uint32_t\&.
.PP
.nf
68                                                                             {
69     if(!b) {
70         errno = EINVAL;
71         return NULL;
72     }
73 
74     if(b->lock) {
75         errno = EBUSY;
76         return NULL;
77     }
78 
79     b->lock = 1;
80 
81     int stride = rectangle[ATK_RECT_W] * (__gfx->bpp >> 3);
82     int size = stride * rectangle[ATK_RECT_H];
83 
84     void* data = (void*) malloc(size);
85     
86     for(register int i = 0,
87                      s = 0, 
88                      p = (b->stride * rectangle[ATK_RECT_Y]) + (rectangle[ATK_RECT_X] * (__gfx->bpp >> 3));
89             i < rectangle[ATK_RECT_H];
90             i++, s += stride, p += b->stride
91         )
92         memcpy(
93                 (void*) ((uint32_t) data + s), 
94                 (void*) ((uint32_t) b->buffer + p),
95                 stride
96             );
97 
98 
99     b->__lockdata\&.region = rectangle;
100     b->__lockdata\&.data = data;
101     b->__lockdata\&.flags = flags;
102 
103     return data;
104 }
.fi
.SS "void atk_bitmap_unlockbits (\fBatk_bitmap_t\fP *b)"

.PP
Definition at line 106 of file bitmap\&.c\&.
.PP
References atk_bitmap::__lockdata, ATK_BITMAP_LOCK_RDWR, ATK_RECT_H, ATK_RECT_W, ATK_RECT_X, ATK_RECT_Y, atk_gfx::bpp, atk_bitmap::buffer, atk_bitmap_lockdata::data, errno, atk_bitmap_lockdata::flags, atk_bitmap::lock, atk_bitmap_lockdata::region, atk_bitmap::stride, and uint32_t\&.
.PP
.nf
106                                             {
107     if(!b) {
108         errno = EINVAL;
109         return NULL;
110     }
111 
112     
113     if(b->__lockdata\&.flags & ATK_BITMAP_LOCK_RDWR) {
114 
115         int stride = b->__lockdata\&.region[ATK_RECT_W] * (__gfx->bpp >> 3);
116 
117         for(register int i = 0,
118                          s = 0, 
119                          p = (b->stride * b->__lockdata\&.region[ATK_RECT_Y]) + (b->__lockdata\&.region[ATK_RECT_X] * (__gfx->bpp >> 3));
120                 i < b->__lockdata\&.region[ATK_RECT_H];
121                 i++, s += stride, p += b->stride
122             )
123             memcpy(
124                     (void*) ((uint32_t) b->buffer + p),
125                     (void*) ((uint32_t) b->__lockdata\&.data + s),
126                     stride
127                 );
128     }
129 
130     b->__lockdata\&.region[0] = b->__lockdata\&.region[1] = b->__lockdata\&.region[2] = b->__lockdata\&.region[3] = 0;
131     b->__lockdata\&.flags = 0;
132 
133     free(b->__lockdata\&.data);
134     b->__lockdata\&.data = 0;
135 
136     b->lock = 0;
137 }
.fi
.SS "int atk_destroy_bitmap (\fBatk_bitmap_t\fP *b)"

.PP
Definition at line 50 of file bitmap\&.c\&.
.PP
References atk_bitmap::buffer, errno, and atk_bitmap::lock\&.
.PP
.nf
50                                         {
51     if(!b) {
52         errno = EINVAL;
53         return -1;
54     }
55 
56     if(b->lock) {
57         errno = EBUSY;
58         return -1;
59     }
60 
61     free(b->buffer);
62     free(b);
63 
64     return 0;   
65 }
.fi
.SH "Variable Documentation"
.PP 
.SS "\fBatk_gfx_t\fP* __gfx"

.PP
Definition at line 10 of file gfx\&.c\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for aPlus from the source code\&.
