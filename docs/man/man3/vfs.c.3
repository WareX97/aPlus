.TH "src/fs/vfs.c" 3 "Fri Nov 14 2014" "Version 0.1" "aPlus" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/fs/vfs.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include <aplus\&.h>\fP
.br
\fC#include <aplus/fs\&.h>\fP
.br
\fC#include <aplus/list\&.h>\fP
.br
\fC#include <stdint\&.h>\fP
.br
\fC#include <stddef\&.h>\fP
.br
\fC#include <unistd\&.h>\fP
.br
\fC#include <sys/stat\&.h>\fP
.br
\fC#include <sys/types\&.h>\fP
.br
\fC#include <fcntl\&.h>\fP
.br
\fC#include <dirent\&.h>\fP
.br
\fC#include <errno\&.h>\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBvfs_map\fP (\fBinode_t\fP *\fBinode\fP)"
.br
.ti -1c
.RI "void \fBvfs_umap\fP (\fBinode_t\fP *\fBinode\fP)"
.br
.ti -1c
.RI "\fBinode_t\fP * \fBvfs_mapped\fP (\fBinode_t\fP *parent, char *\fBname\fP)"
.br
.ti -1c
.RI "\fBinode_t\fP * \fBvfs_mapped_at_index\fP (\fBinode_t\fP *parent, int index)"
.br
.ti -1c
.RI "int \fBvfs_mapped_count\fP (\fBinode_t\fP *parent)"
.br
.ti -1c
.RI "int \fBvfs_chroot\fP (\fBinode_t\fP *root)"
.br
.ti -1c
.RI "int \fBvfs_init\fP ()"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "static \fBlist_t\fP * \fBlist_inodes\fP = 0"
.br
.ti -1c
.RI "static \fBuint32_t\fP \fBnextinode\fP = 0"
.br
.ti -1c
.RI "\fBinode_t\fP * \fBvfs_root\fP"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "int vfs_chroot (\fBinode_t\fP *root)"

.PP
Definition at line 72 of file vfs\&.c\&.
.PP
References inode::parent\&.
.PP
.nf
72                               {
73     vfs_root = root;
74     vfs_root->parent = 0;
75     
76     return 0;
77 }
.fi
.SS "int vfs_init ()"

.PP
Definition at line 81 of file vfs\&.c\&.
.PP
References inode::atime, inode::chown, inode::creat, inode::ctime, inode::dev, devfs_mount(), inode::finddir, inode::flush, inode::gid, GID_ROOT, inode::ino, inode::ioctl, kmalloc(), inode::link, list_add(), list_init, inode::mode, inode::mtime, inode::name, nextinode, inode::nlink, inode::parent, inode::rdev, inode::read, inode::readdir, inode::rename, inode::size, sys_time(), inode::uid, UID_ROOT, inode::unlink, vfs_map(), and inode::write\&.
.PP
.nf
81                {
82     list_init(list_inodes);
83     
84     
85     vfs_root = (inode_t*) kmalloc(sizeof(inode_t));
86     vfs_root->name[0] = '/';
87     vfs_root->name[1] = 0;
88     
89     vfs_root->dev = (dev_t) 0;
90     vfs_root->ino = (ino_t) nextinode++;
91     vfs_root->mode = S_IFDIR;
92     vfs_root->nlink = 0;
93     vfs_root->uid = UID_ROOT;
94     vfs_root->gid = GID_ROOT;
95     vfs_root->rdev = (dev_t) 0;
96     vfs_root->size = (size_t) 0;
97     vfs_root->atime = vfs_root->ctime = vfs_root->mtime = sys_time(NULL);
98     vfs_root->parent = (inode_t*) NULL;
99     vfs_root->link = (inode_t*) NULL;
100     
101     vfs_root->read = NULL;
102     vfs_root->write = NULL;
103     vfs_root->readdir = NULL;
104     vfs_root->finddir = NULL;
105     vfs_root->creat = NULL;
106     vfs_root->rename = NULL;
107     vfs_root->unlink = NULL;
108     vfs_root->chown = NULL;
109     vfs_root->flush = NULL;
110     vfs_root->ioctl = NULL;
111     
112     list_add(list_inodes, (listval_t) vfs_root);
113 
114 
115     vfs_map((inode_t*) devfs_mount());
116     
117     return 0;
118 }
.fi
.SS "void vfs_map (\fBinode_t\fP *inode)"

.PP
Definition at line 22 of file vfs\&.c\&.
.PP
References inode::ino, list_add(), and nextinode\&.
.PP
.nf
22                              {
23     inode->ino = (ino_t) nextinode++;
24     list_add(list_inodes, (listval_t) inode);
25 }
.fi
.SS "\fBinode_t\fP* vfs_mapped (\fBinode_t\fP *parent, char *name)"

.PP
Definition at line 32 of file vfs\&.c\&.
.PP
References list_foreach, inode::name, inode::parent, and value\&.
.PP
.nf
32                                                  {
33     list_foreach(tmp, list_inodes) {
34         inode_t* value = (inode_t*) tmp;
35         
36         if(value->parent == parent)
37             if(strcmp(value->name, name) == 0)
38                 return value;
39     }
40     
41     return NULL;
42 }
.fi
.SS "\fBinode_t\fP* vfs_mapped_at_index (\fBinode_t\fP *parent, intindex)"

.PP
Definition at line 44 of file vfs\&.c\&.
.PP
References list_foreach, inode::parent, and value\&.
.PP
.nf
44                                                          {
45     list_foreach(tmp, list_inodes) {
46         inode_t* value = (inode_t*) tmp;
47         
48         if(value->parent == parent)
49             index--;
50             
51         if(index == -1)
52             return value;
53     }
54     
55     return NULL;
56 }
.fi
.SS "int vfs_mapped_count (\fBinode_t\fP *parent)"

.PP
Definition at line 58 of file vfs\&.c\&.
.PP
References list_foreach, inode::parent, and value\&.
.PP
.nf
58                                       {
59     int index = 0;
60     
61     list_foreach(tmp, list_inodes) {
62         inode_t* value = (inode_t*) tmp;
63         
64         if(value->parent == parent)
65             index++;
66     }
67     
68     return index;
69 }
.fi
.SS "void vfs_umap (\fBinode_t\fP *inode)"

.PP
Definition at line 27 of file vfs\&.c\&.
.PP
References kfree(), and list_remove()\&.
.PP
.nf
27                               {
28     list_remove(list_inodes, (listval_t) inode);
29     kfree(inode);
30 }
.fi
.SH "Variable Documentation"
.PP 
.SS "\fBlist_t\fP* list_inodes = 0\fC [static]\fP"

.PP
Definition at line 16 of file vfs\&.c\&.
.SS "\fBuint32_t\fP nextinode = 0\fC [static]\fP"

.PP
Definition at line 17 of file vfs\&.c\&.
.SS "\fBinode_t\fP* vfs_root"

.PP
Definition at line 19 of file vfs\&.c\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for aPlus from the source code\&.
