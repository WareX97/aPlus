.TH "src/syscall/mount.c" 3 "Fri Nov 14 2014" "Version 0.1" "aPlus" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/syscall/mount.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include <aplus\&.h>\fP
.br
\fC#include <aplus/fs\&.h>\fP
.br
\fC#include <aplus/task\&.h>\fP
.br
\fC#include <aplus/list\&.h>\fP
.br
\fC#include <aplus/attribute\&.h>\fP
.br
\fC#include <aplus/syscall\&.h>\fP
.br
\fC#include <aplus/fsys\&.h>\fP
.br
\fC#include <stdint\&.h>\fP
.br
\fC#include <unistd\&.h>\fP
.br
\fC#include <dirent\&.h>\fP
.br
\fC#include <fcntl\&.h>\fP
.br
\fC#include <sys/types\&.h>\fP
.br
\fC#include <errno\&.h>\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBsys_mount\fP (const char *dev, const char *dir, const char *fstype, int options, const void *\fBdata\fP)"
.br
.ti -1c
.RI "\fBSYSCALL\fP (\fBsys_mount\fP, 24)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "\fBtask_t\fP * \fBcurrent_task\fP"
.br
.RI "\fICurrent task address\&. \fP"
.in -1c
.SH "Function Documentation"
.PP 
.SS "int sys_mount (const char *dev, const char *dir, const char *fstype, intoptions, const void *data)"

.PP
Definition at line 22 of file mount\&.c\&.
.PP
References attribute(), inode::dev, errno, task::fd, fs, im_superuser(), inode::ino, list_destroy, list_empty(), list_foreach, inode::mode, fsys::mount, fsys::name, O_DIRECTORY, sys_close(), sys_open(), and value\&.
.PP
.nf
22                                                                                                    {
23     if(!current_task)
24         return -1;
25 
26 
27     if(!im_superuser()) {
28         errno = EPERM;
29         return -1;
30     }
31 
32 
33     if(dir == NULL || strlen(dir) == 0) {
34         errno = EINVAL;
35         return -1;
36     }
37 
38     inode_t* idev = NULL;
39     inode_t* idir = NULL;
40 
41 
42     if(dev && strlen(dev) > 0) {
43         int dfd = sys_open(dev, O_RDONLY, 0644);
44         if(dfd < 0) {
45             errno = ENOENT;
46             return -1;
47         }
48 
49         idev = current_task->fd[dfd];
50         sys_close(dfd);
51     }
52 
53 
54     int sfd = sys_open(dir, O_CREAT | O_DIRECTORY | O_RDONLY, S_IFDIR);
55     if(sfd < 0) {
56         errno = ENOENT;
57         return -1;
58     }
59 
60     idir = current_task->fd[sfd];
61     sys_close(sfd);
62 
63     list_t* fs = attribute("fs");
64     if(list_empty(fs)) {
65         errno = ENODEV;
66         return -1;
67     }
68     
69 
70     fsys_t* found = NULL;
71 
72     list_foreach(value, fs) {
73         fsys_t* f = (fsys_t*) value;
74 
75         if(strcmp(f->name, fstype) == 0)
76             found = f;
77     }
78 
79     list_destroy(fs);
80 
81     if(found == NULL) {
82         errno = ENODEV;
83         return -1;
84     }
85 
86     idir->mode |= S_IFMT;
87     idir->dev = idev->ino;
88 
89     if(found->mount(idev, idir, options) < 0) {
90 
91         idir->mode &= ~S_IFMT;
92         idir->dev = 0;      
93 
94         errno = ENODEV;
95         return -1;
96     }
97 
98     return 0;
99 }
.fi
.SS "SYSCALL (\fBsys_mount\fP, 24)"

.SH "Variable Documentation"
.PP 
.SS "\fBtask_t\fP* current_task"

.PP
Current task address\&. 
.PP
Definition at line 35 of file sched\&.c\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for aPlus from the source code\&.
