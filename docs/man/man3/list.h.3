.TH "src/include/aplus/list.h" 3 "Wed Nov 12 2014" "Version 0.1" "aPlus" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/include/aplus/list.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include <stddef\&.h>\fP
.br
\fC#include <stdint\&.h>\fP
.br
\fC#include <sys/types\&.h>\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBlist_body\fP"
.br
.ti -1c
.RI "struct \fBlist\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBlist_safe_begin\fP(\fBlist\fP)   __list_lock(&\fBlist\fP->\fBlock\fP)"
.br
.RI "\fILock a list for safe operations on it\&. \fP"
.ti -1c
.RI "#define \fBlist_safe_end\fP(\fBlist\fP)   __list_unlock(&\fBlist\fP->\fBlock\fP)"
.br
.RI "\fIUnlock a list\&. \fP"
.ti -1c
.RI "#define \fBlist_foreach\fP(\fBvalue\fP, \fBlist\fP)"
.br
.RI "\fIIterating a list and save each value in 'value'\&. \fP"
.ti -1c
.RI "#define \fBlist_foreach_reverse\fP(\fBvalue\fP, \fBlist\fP)"
.br
.RI "\fIIterating a list and save each value in 'value' conversely\&. \fP"
.ti -1c
.RI "#define \fBlist_size\fP(\fBlist\fP)   \fBlist\fP->\fBsize\fP"
.br
.RI "\fIGet size of list\&. \fP"
.ti -1c
.RI "#define \fBlist_init\fP(\fBlist\fP)"
.br
.RI "\fIInitialize a list\&. \fP"
.ti -1c
.RI "#define \fBlist_destroy\fP(\fBlist\fP)"
.br
.RI "\fIDestroy a list\&. \fP"
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef \fBuint32_t\fP \fBlistval_t\fP"
.br
.ti -1c
.RI "typedef struct \fBlist_body\fP \fBlist_body_t\fP"
.br
.ti -1c
.RI "typedef struct \fBlist\fP \fBlist_t\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "static int \fBlist_empty\fP (\fBlist_t\fP *\fBlist\fP)"
.br
.RI "\fICheck if list is empty or unitialized\&. \fP"
.ti -1c
.RI "static int \fBlist_add\fP (\fBlist_t\fP *\fBlist\fP, \fBlistval_t\fP v)"
.br
.RI "\fIAdd value to the list\&. \fP"
.ti -1c
.RI "static int \fBlist_remove\fP (\fBlist_t\fP *\fBlist\fP, \fBlistval_t\fP v)"
.br
.RI "\fIRemove value to the list\&. \fP"
.ti -1c
.RI "static int \fBlist_clear\fP (\fBlist_t\fP *\fBlist\fP)"
.br
.RI "\fIErase all values in the list\&. \fP"
.ti -1c
.RI "static void \fBlist_clone\fP (\fBlist_t\fP *\fBdest\fP, \fBlist_t\fP *src)"
.br
.RI "\fICopy all values in the src's list to dest's list\&. \fP"
.ti -1c
.RI "static \fBlistval_t\fP \fBlist_prev\fP (\fBlist_t\fP *\fBlist\fP, \fBlistval_t\fP val)"
.br
.RI "\fIGet previous value in the list\&. \fP"
.ti -1c
.RI "static \fBlistval_t\fP \fBlist_next\fP (\fBlist_t\fP *\fBlist\fP, \fBlistval_t\fP val)"
.br
.RI "\fIGet next value in the list\&. \fP"
.ti -1c
.RI "static \fBlistval_t\fP \fBlist_tail\fP (\fBlist_t\fP *\fBlist\fP)"
.br
.RI "\fIGet last value in the list\&. \fP"
.ti -1c
.RI "static \fBlistval_t\fP \fBlist_head\fP (\fBlist_t\fP *\fBlist\fP)"
.br
.RI "\fIGet first value in the list\&. \fP"
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define list_destroy(\fBlist\fP)"
\fBValue:\fP
.PP
.nf
list_clear(list);                                        \
    __list_free(list)
.fi
.PP
Destroy a list\&. 
.PP
\fBParameters:\fP
.RS 4
\fIlist\fP Pointer to list\&. 
.RE
.PP

.PP
Definition at line 292 of file list\&.h\&.
.SS "#define list_foreach(\fBvalue\fP, \fBlist\fP)"
\fBValue:\fP
.PP
.nf
for(listval_t value = list_head(list);                     \\
		value;                                                \\
		value = list_next(list, value)                        \
        )
.fi
.PP
Iterating a list and save each value in 'value'\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvalue\fP Value where save each iteration\&. 
.br
\fIlist\fP Pointer to list\&. 
.RE
.PP

.PP
Definition at line 253 of file list\&.h\&.
.SS "#define list_foreach_reverse(\fBvalue\fP, \fBlist\fP)"
\fBValue:\fP
.PP
.nf
for(listval_t value = list_tail(list);                     \\
		value;                                                \\
		value = list_prev(list, value)                        \
        )
.fi
.PP
Iterating a list and save each value in 'value' conversely\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvalue\fP Value where save each iteration\&. 
.br
\fIlist\fP Pointer to list\&. 
.RE
.PP

.PP
Definition at line 264 of file list\&.h\&.
.SS "#define list_init(\fBlist\fP)"
\fBValue:\fP
.PP
.nf
list = (list_t*) __list_malloc(sizeof(list_t));          \
    list->body = 0;                                         \
    list->size = 0;                                         \
    list->lock = 0
.fi
.PP
Initialize a list\&. 
.PP
\fBParameters:\fP
.RS 4
\fIlist\fP Pointer to list\&. 
.RE
.PP

.PP
Definition at line 282 of file list\&.h\&.
.SS "#define list_safe_begin(\fBlist\fP)   __list_lock(&\fBlist\fP->\fBlock\fP)"

.PP
Lock a list for safe operations on it\&. 
.PP
\fBParameters:\fP
.RS 4
\fIlist\fP Pointer to list\&. 
.RE
.PP

.PP
Definition at line 237 of file list\&.h\&.
.SS "#define list_safe_end(\fBlist\fP)   __list_unlock(&\fBlist\fP->\fBlock\fP)"

.PP
Unlock a list\&. 
.PP
\fBParameters:\fP
.RS 4
\fIlist\fP Pointer to list\&. 
.RE
.PP

.PP
Definition at line 244 of file list\&.h\&.
.SS "#define list_size(\fBlist\fP)   \fBlist\fP->\fBsize\fP"

.PP
Get size of list\&. 
.PP
\fBParameters:\fP
.RS 4
\fIlist\fP Pointer to list\&. 
.RE
.PP

.PP
Definition at line 275 of file list\&.h\&.
.SH "Typedef Documentation"
.PP 
.SS "typedef struct \fBlist_body\fP  \fBlist_body_t\fP"

.PP
\fBExamples: \fP
.in +1c
\fBlist\&.h\fP\&.
.SS "typedef struct \fBlist\fP  \fBlist_t\fP"

.PP
\fBExamples: \fP
.in +1c
\fBlist\&.h\fP\&.
.SS "typedef \fBuint32_t\fP \fBlistval_t\fP"

.PP
\fBExamples: \fP
.in +1c
\fBlist\&.h\fP\&.
.PP
Definition at line 42 of file list\&.h\&.
.SH "Function Documentation"
.PP 
.SS "static int list_add (\fBlist_t\fP *list, \fBlistval_t\fPv)\fC [inline]\fP, \fC [static]\fP"

.PP
Add value to the list\&. 
.PP
\fBParameters:\fP
.RS 4
\fIlist\fP Pointer to list\&. 
.br
\fIv\fP Value to add\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
0 if success, otherwise -1\&. 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBlist\&.h\fP\&.
.PP
Definition at line 78 of file list\&.h\&.
.PP
References list::body, list::lock, list_body::next, list::size, and list_body::value\&.
.PP
.nf
78                                                       {
79     list_body_t* val = (list_body_t*) __list_malloc(sizeof(list_body_t));
80     if(!val)
81         return -1;
82         
83     __list_lock(&list->lock);
84         
85     val->value = v;
86     val->next = list->body;
87     
88     list->body = val;
89     list->size += 1;
90     
91     __list_unlock(&list->lock);
92     return 0;
93 }
.fi
.SS "static int list_clear (\fBlist_t\fP *list)\fC [inline]\fP, \fC [static]\fP"

.PP
Erase all values in the list\&. 
.PP
\fBParameters:\fP
.RS 4
\fIlist\fP Pointer to list\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
0 if success, otherwise -1\&. 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBlist\&.h\fP\&.
.PP
Definition at line 134 of file list\&.h\&.
.PP
References list::body, list::lock, list_body::next, and list::size\&.
.PP
.nf
134                                            {
135     __list_lock(&list->lock);
136     
137     list_body_t* body = list->body;
138     list_body_t* tmp = list->body;
139     
140     while(body) {
141         tmp = body->next;
142         __list_free(body);
143         body = tmp;
144     }
145     
146     list->body = 0;
147     list->size = 0;
148     
149     __list_unlock(&list->lock);
150     return 0;
151 }
.fi
.SS "static void list_clone (\fBlist_t\fP *dest, \fBlist_t\fP *src)\fC [inline]\fP, \fC [static]\fP"

.PP
Copy all values in the src's list to dest's list\&. 
.PP
\fBParameters:\fP
.RS 4
\fIdest\fP Pointer to list\&. 
.br
\fIsrc\fP Pointer to list\&. 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBlist\&.h\fP\&.
.PP
Definition at line 159 of file list\&.h\&.
.PP
References list::body, list_add(), list::lock, and list_body::next\&.
.PP
.nf
159                                                          {
160     __list_lock(&src->lock);
161     
162     for(list_body_t* i = src->body; i; i = i->next) {
163         list_add(dest, i->value);
164     }
165     
166     __list_unlock(&src->lock);
167 }
.fi
.SS "static int list_empty (\fBlist_t\fP *list)\fC [inline]\fP, \fC [static]\fP"

.PP
Check if list is empty or unitialized\&. 
.PP
\fBParameters:\fP
.RS 4
\fIlist\fP Pointer to list\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
true or false\&. 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBlist\&.h\fP\&.
.PP
Definition at line 64 of file list\&.h\&.
.PP
References list::size\&.
.PP
.nf
64                                            {
65     if(list)
66         return list->size == 0;
67     else
68         return 1;   /* empty */
69 }
.fi
.SS "static \fBlistval_t\fP list_head (\fBlist_t\fP *list)\fC [inline]\fP, \fC [static]\fP"

.PP
Get first value in the list\&. 
.PP
\fBParameters:\fP
.RS 4
\fIlist\fP Pointer to list\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
First value if success, otherwise NULL\&. 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBlist\&.h\fP\&.
.PP
Definition at line 220 of file list\&.h\&.
.PP
References list::body, list_body::next, and list_body::value\&.
.PP
.nf
220                                                 {
221 
222     if(!list->body)
223         return (listval_t) NULL;
224     
225     list_body_t* tmp = list->body;
226     while(tmp->next)
227         tmp = tmp->next;
228         
229     return (listval_t) tmp->value;
230 }
.fi
.SS "static \fBlistval_t\fP list_next (\fBlist_t\fP *list, \fBlistval_t\fPval)\fC [inline]\fP, \fC [static]\fP"

.PP
Get next value in the list\&. 
.PP
\fBParameters:\fP
.RS 4
\fIlist\fP Pointer to list\&. 
.br
\fIval\fP A Value in the list\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Next value if success, otherwise NULL\&. 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBlist\&.h\fP\&.
.PP
Definition at line 193 of file list\&.h\&.
.PP
References list::body, and list_body::next\&.
.PP
.nf
193                                                                {
194     for(list_body_t* i = list->body; i; i = i->next) {
195         if(i->next)
196             if(i->next->value == val)
197                 return i->value;
198     }
199     
200     return (listval_t) NULL;
201 }
.fi
.SS "static \fBlistval_t\fP list_prev (\fBlist_t\fP *list, \fBlistval_t\fPval)\fC [inline]\fP, \fC [static]\fP"

.PP
Get previous value in the list\&. 
.PP
\fBParameters:\fP
.RS 4
\fIlist\fP Pointer to list\&. 
.br
\fIval\fP A Value in the list\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Previous value if success, otherwise NULL\&. 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBlist\&.h\fP\&.
.PP
Definition at line 176 of file list\&.h\&.
.PP
References list::body, and list_body::next\&.
.PP
.nf
176                                                                {
177     for(list_body_t* i = list->body; i; i = i->next) {
178         if(i->value == val)
179             if(i->next)
180                 return i->next->value;
181     }
182     
183     return (listval_t) NULL;
184 }
.fi
.SS "static int list_remove (\fBlist_t\fP *list, \fBlistval_t\fPv)\fC [inline]\fP, \fC [static]\fP"

.PP
Remove value to the list\&. 
.PP
\fBParameters:\fP
.RS 4
\fIlist\fP Pointer to list\&. 
.br
\fIv\fP Value to remove\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
0 if success, otherwise -1\&. 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBlist\&.h\fP\&.
.PP
Definition at line 102 of file list\&.h\&.
.PP
References list::body, list::lock, list_body::next, and list_body::value\&.
.PP
.nf
102                                                          {
103     __list_lock(&list->lock);
104     
105     list_body_t* body = list->body;
106     list_body_t* prev = 0;
107     
108     while(body) {
109         if(body->value == v) {
110             if(prev)
111                 prev->next = body->next;
112             else
113                 list->body = body->next;
114                 
115             body->value = 0;
116             __list_free(body);
117             break;
118         }
119         
120         prev = body;
121         body = body->next;
122     }
123     
124     __list_unlock(&list->lock);
125     return 0;
126 }
.fi
.SS "static \fBlistval_t\fP list_tail (\fBlist_t\fP *list)\fC [inline]\fP, \fC [static]\fP"

.PP
Get last value in the list\&. 
.PP
\fBParameters:\fP
.RS 4
\fIlist\fP Pointer to list\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Last value if success, otherwise NULL\&. 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBlist\&.h\fP\&.
.PP
Definition at line 208 of file list\&.h\&.
.PP
References list::body, and list_body::value\&.
.PP
.nf
208                                                 {
209     if(list->body)
210         return list->body->value;
211         
212     return (listval_t) NULL;
213 }
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for aPlus from the source code\&.
