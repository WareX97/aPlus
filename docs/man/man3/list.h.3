.TH "src/include/aplus/list.h" 3 "Dom 9 Nov 2014" "Version 0.1" "aPlus" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/include/aplus/list.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include <stddef\&.h>\fP
.br
\fC#include <stdint\&.h>\fP
.br
\fC#include <sys/types\&.h>\fP
.br
\fC#include <aplus/spinlock\&.h>\fP
.br
\fC#include <aplus/mm\&.h>\fP
.br

.SS "Strutture dati"

.in +1c
.ti -1c
.RI "struct \fBlist_body\fP"
.br
.ti -1c
.RI "struct \fBlist\fP"
.br
.in -1c
.SS "Definizioni"

.in +1c
.ti -1c
.RI "#define \fBlist_safe_begin\fP(\fBlist\fP)   \fBspinlock_lock\fP(&\fBlist\fP->\fBlock\fP)"
.br
.ti -1c
.RI "#define \fBlist_safe_end\fP(\fBlist\fP)   \fBspinlock_unlock\fP(&\fBlist\fP->\fBlock\fP)"
.br
.ti -1c
.RI "#define \fBlist_foreach\fP(\fBvalue\fP, \fBlist\fP)"
.br
.ti -1c
.RI "#define \fBlist_foreach_inverse\fP(\fBvalue\fP, \fBlist\fP)"
.br
.ti -1c
.RI "#define \fBlist_init\fP(\fBlist\fP)"
.br
.ti -1c
.RI "#define \fBlist_destroy\fP(\fBlist\fP)"
.br
.in -1c
.SS "Ridefinizioni di tipo (typedef)"

.in +1c
.ti -1c
.RI "typedef \fBuint32_t\fP \fBlistval_t\fP"
.br
.ti -1c
.RI "typedef struct \fBlist_body\fP \fBlist_body_t\fP"
.br
.ti -1c
.RI "typedef struct \fBlist\fP \fBlist_t\fP"
.br
.in -1c
.SS "Funzioni"

.in +1c
.ti -1c
.RI "static int \fBlist_empty\fP (\fBlist_t\fP *\fBlist\fP)"
.br
.ti -1c
.RI "static int \fBlist_add\fP (\fBlist_t\fP *\fBlist\fP, \fBlistval_t\fP v)"
.br
.ti -1c
.RI "static int \fBlist_remove\fP (\fBlist_t\fP *\fBlist\fP, \fBlistval_t\fP v)"
.br
.ti -1c
.RI "static int \fBlist_clear\fP (\fBlist_t\fP *\fBlist\fP)"
.br
.ti -1c
.RI "static void \fBlist_clone\fP (\fBlist_t\fP *\fBdest\fP, \fBlist_t\fP *src)"
.br
.ti -1c
.RI "static \fBlistval_t\fP \fBlist_prev\fP (\fBlist_t\fP *\fBlist\fP, \fBlistval_t\fP val)"
.br
.ti -1c
.RI "static \fBlistval_t\fP \fBlist_next\fP (\fBlist_t\fP *\fBlist\fP, \fBlistval_t\fP val)"
.br
.ti -1c
.RI "static \fBlistval_t\fP \fBlist_tail\fP (\fBlist_t\fP *\fBlist\fP)"
.br
.ti -1c
.RI "static \fBlistval_t\fP \fBlist_head\fP (\fBlist_t\fP *\fBlist\fP)"
.br
.in -1c
.SH "Documentazione delle definizioni"
.PP 
.SS "#define list_destroy(\fBlist\fP)"
\fBValore:\fP
.PP
.nf
list_clear(list);                                        \\
	kfree(list)
.fi
.PP
Definizione alla linea 193 del file list\&.h\&.
.SS "#define list_foreach(\fBvalue\fP, \fBlist\fP)"
\fBValore:\fP
.PP
.nf
for(listval_t value = list_head(list);                     \\
		value;                                                \\
		value = list_next(list, value)                        \
        )
.fi
.PP
Definizione alla linea 175 del file list\&.h\&.
.SS "#define list_foreach_inverse(\fBvalue\fP, \fBlist\fP)"
\fBValore:\fP
.PP
.nf
for(listval_t value = list_tail(list);                     \\
		value;                                                \\
		value = list_prev(list, value)                        \
        )
.fi
.PP
Definizione alla linea 181 del file list\&.h\&.
.SS "#define list_init(\fBlist\fP)"
\fBValore:\fP
.PP
.nf
list = (list_t*) kmalloc(sizeof(list_t));                \
    list->body = 0;                                         \
    list->size = 0;                                         \
    list->lock = 0
.fi
.PP
Definizione alla linea 187 del file list\&.h\&.
.SS "#define list_safe_begin(\fBlist\fP)   \fBspinlock_lock\fP(&\fBlist\fP->\fBlock\fP)"

.PP
Definizione alla linea 169 del file list\&.h\&.
.SS "#define list_safe_end(\fBlist\fP)   \fBspinlock_unlock\fP(&\fBlist\fP->\fBlock\fP)"

.PP
Definizione alla linea 172 del file list\&.h\&.
.SH "Documentazione delle ridefinizioni di tipo (typedef)"
.PP 
.SS "typedef struct \fBlist_body\fP  \fBlist_body_t\fP"

.SS "typedef struct \fBlist\fP  \fBlist_t\fP"

.SS "typedef \fBuint32_t\fP \fBlistval_t\fP"

.PP
Definizione alla linea 33 del file list\&.h\&.
.SH "Documentazione delle funzioni"
.PP 
.SS "static int list_add (\fBlist_t\fP *list, \fBlistval_t\fPv)\fC [inline]\fP, \fC [static]\fP"

.PP
Definizione alla linea 56 del file list\&.h\&.
.PP
Referenzia list::body, kmalloc(), list::lock, list_body::next, list::size, spinlock_lock(), spinlock_unlock(), e list_body::value\&.
.PP
.nf
56                                                       {
57     list_body_t* val = (list_body_t*) kmalloc(sizeof(list_body_t));
58     if(!val)
59         return -1;
60         
61     spinlock_lock(&list->lock);
62         
63     val->value = v;
64     val->next = list->body;
65     
66     list->body = val;
67     list->size += 1;
68     
69     spinlock_unlock(&list->lock);
70     return 0;
71 }
.fi
.SS "static int list_clear (\fBlist_t\fP *list)\fC [inline]\fP, \fC [static]\fP"

.PP
Definizione alla linea 99 del file list\&.h\&.
.PP
Referenzia list::body, kfree(), list::lock, list_body::next, list::size, spinlock_lock(), e spinlock_unlock()\&.
.PP
.nf
99                                            {
100     spinlock_lock(&list->lock);
101     
102     list_body_t* body = list->body;
103     list_body_t* tmp = list->body;
104     
105     while(body) {
106         tmp = body->next;
107         kfree(body);
108         body = tmp;
109     }
110     
111     list->body = 0;
112     list->size = 0;
113     
114     spinlock_unlock(&list->lock);
115     return 0;
116 }
.fi
.SS "static void list_clone (\fBlist_t\fP *dest, \fBlist_t\fP *src)\fC [inline]\fP, \fC [static]\fP"

.PP
Definizione alla linea 119 del file list\&.h\&.
.PP
Referenzia list::body, list_add(), list::lock, list_body::next, spinlock_lock(), e spinlock_unlock()\&.
.PP
.nf
119                                                          {
120     spinlock_lock(&src->lock);
121     
122     for(list_body_t* i = src->body; i; i = i->next) {
123         list_add(dest, i->value);
124     }
125     
126     spinlock_unlock(&src->lock);
127 }
.fi
.SS "static int list_empty (\fBlist_t\fP *list)\fC [inline]\fP, \fC [static]\fP"

.PP
Definizione alla linea 49 del file list\&.h\&.
.PP
Referenzia list::size\&.
.PP
.nf
49                                            {
50     if(list)
51         return list->size == 0;
52     else
53         return 1;   /* empty */
54 }
.fi
.SS "static \fBlistval_t\fP list_head (\fBlist_t\fP *list)\fC [inline]\fP, \fC [static]\fP"

.PP
Definizione alla linea 156 del file list\&.h\&.
.PP
Referenzia list::body, list_body::next, e list_body::value\&.
.PP
.nf
156                                                 {
157 
158     if(!list->body)
159         return (listval_t) NULL;
160     
161     list_body_t* tmp = list->body;
162     while(tmp->next)
163         tmp = tmp->next;
164         
165     return (listval_t) tmp->value;
166 }
.fi
.SS "static \fBlistval_t\fP list_next (\fBlist_t\fP *list, \fBlistval_t\fPval)\fC [inline]\fP, \fC [static]\fP"

.PP
Definizione alla linea 139 del file list\&.h\&.
.PP
Referenzia list::body, e list_body::next\&.
.PP
.nf
139                                                                {
140     for(list_body_t* i = list->body; i; i = i->next) {
141         if(i->next)
142             if(i->next->value == val)
143                 return i->value;
144     }
145     
146     return (listval_t) NULL;
147 }
.fi
.SS "static \fBlistval_t\fP list_prev (\fBlist_t\fP *list, \fBlistval_t\fPval)\fC [inline]\fP, \fC [static]\fP"

.PP
Definizione alla linea 129 del file list\&.h\&.
.PP
Referenzia list::body, e list_body::next\&.
.PP
.nf
129                                                                {
130     for(list_body_t* i = list->body; i; i = i->next) {
131         if(i->value == val)
132             if(i->next)
133                 return i->next->value;
134     }
135     
136     return (listval_t) NULL;
137 }
.fi
.SS "static int list_remove (\fBlist_t\fP *list, \fBlistval_t\fPv)\fC [inline]\fP, \fC [static]\fP"

.PP
Definizione alla linea 73 del file list\&.h\&.
.PP
Referenzia list::body, kfree(), list::lock, list_body::next, spinlock_lock(), spinlock_unlock(), e list_body::value\&.
.PP
.nf
73                                                          {
74     spinlock_lock(&list->lock);
75     
76     list_body_t* body = list->body;
77     list_body_t* prev = 0;
78     
79     while(body) {
80         if(body->value == v) {
81             if(prev)
82                 prev->next = body->next;
83             else
84                 list->body = body->next;
85                 
86             body->value = 0;
87             kfree(body);
88             break;
89         }
90         
91         prev = body;
92         body = body->next;
93     }
94     
95     spinlock_unlock(&list->lock);
96     return 0;
97 }
.fi
.SS "static \fBlistval_t\fP list_tail (\fBlist_t\fP *list)\fC [inline]\fP, \fC [static]\fP"

.PP
Definizione alla linea 149 del file list\&.h\&.
.PP
Referenzia list::body, e list_body::value\&.
.PP
.nf
149                                                 {
150     if(list->body)
151         return list->body->value;
152         
153     return (listval_t) NULL;
154 }
.fi
.SH "Autore"
.PP 
Generato automaticamente da Doxygen per aPlus a partire dal codice sorgente\&.
