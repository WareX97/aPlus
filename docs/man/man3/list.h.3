.TH "src/include/aplus/list.h" 3 "Wed Nov 12 2014" "Version 0.1" "aPlus" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/include/aplus/list.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include <stddef\&.h>\fP
.br
\fC#include <stdint\&.h>\fP
.br
\fC#include <sys/types\&.h>\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBlist_body\fP"
.br
.ti -1c
.RI "struct \fBlist\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBlist_safe_begin\fP(\fBlist\fP)   __list_lock(&\fBlist\fP->\fBlock\fP)"
.br
.ti -1c
.RI "#define \fBlist_safe_end\fP(\fBlist\fP)   __list_unlock(&\fBlist\fP->\fBlock\fP)"
.br
.ti -1c
.RI "#define \fBlist_foreach\fP(\fBvalue\fP, \fBlist\fP)"
.br
.ti -1c
.RI "#define \fBlist_foreach_inverse\fP(\fBvalue\fP, \fBlist\fP)"
.br
.ti -1c
.RI "#define \fBlist_init\fP(\fBlist\fP)"
.br
.ti -1c
.RI "#define \fBlist_destroy\fP(\fBlist\fP)"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef \fBuint32_t\fP \fBlistval_t\fP"
.br
.ti -1c
.RI "typedef struct \fBlist_body\fP \fBlist_body_t\fP"
.br
.ti -1c
.RI "typedef struct \fBlist\fP \fBlist_t\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "static int \fBlist_empty\fP (\fBlist_t\fP *\fBlist\fP)"
.br
.ti -1c
.RI "static int \fBlist_add\fP (\fBlist_t\fP *\fBlist\fP, \fBlistval_t\fP v)"
.br
.ti -1c
.RI "static int \fBlist_remove\fP (\fBlist_t\fP *\fBlist\fP, \fBlistval_t\fP v)"
.br
.ti -1c
.RI "static int \fBlist_clear\fP (\fBlist_t\fP *\fBlist\fP)"
.br
.ti -1c
.RI "static void \fBlist_clone\fP (\fBlist_t\fP *\fBdest\fP, \fBlist_t\fP *src)"
.br
.ti -1c
.RI "static \fBlistval_t\fP \fBlist_prev\fP (\fBlist_t\fP *\fBlist\fP, \fBlistval_t\fP val)"
.br
.ti -1c
.RI "static \fBlistval_t\fP \fBlist_next\fP (\fBlist_t\fP *\fBlist\fP, \fBlistval_t\fP val)"
.br
.ti -1c
.RI "static \fBlistval_t\fP \fBlist_tail\fP (\fBlist_t\fP *\fBlist\fP)"
.br
.ti -1c
.RI "static \fBlistval_t\fP \fBlist_head\fP (\fBlist_t\fP *\fBlist\fP)"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define list_destroy(\fBlist\fP)"
\fBValue:\fP
.PP
.nf
list_clear(list);                                     \
    __list_free(list)
.fi
.PP
Definition at line 202 of file list\&.h\&.
.SS "#define list_foreach(\fBvalue\fP, \fBlist\fP)"
\fBValue:\fP
.PP
.nf
for(listval_t value = list_head(list);                     \\
		value;                                                \\
		value = list_next(list, value)                        \
        )
.fi
.PP
Definition at line 184 of file list\&.h\&.
.SS "#define list_foreach_inverse(\fBvalue\fP, \fBlist\fP)"
\fBValue:\fP
.PP
.nf
for(listval_t value = list_tail(list);                     \\
		value;                                                \\
		value = list_prev(list, value)                        \
        )
.fi
.PP
Definition at line 190 of file list\&.h\&.
.SS "#define list_init(\fBlist\fP)"
\fBValue:\fP
.PP
.nf
list = (list_t*) __list_malloc(sizeof(list_t));          \
    list->body = 0;                                         \
    list->size = 0;                                         \
    list->lock = 0
.fi
.PP
Definition at line 196 of file list\&.h\&.
.SS "#define list_safe_begin(\fBlist\fP)   __list_lock(&\fBlist\fP->\fBlock\fP)"

.PP
Definition at line 178 of file list\&.h\&.
.SS "#define list_safe_end(\fBlist\fP)   __list_unlock(&\fBlist\fP->\fBlock\fP)"

.PP
Definition at line 181 of file list\&.h\&.
.SH "Typedef Documentation"
.PP 
.SS "typedef struct \fBlist_body\fP  \fBlist_body_t\fP"

.SS "typedef struct \fBlist\fP  \fBlist_t\fP"

.SS "typedef \fBuint32_t\fP \fBlistval_t\fP"

.PP
Definition at line 42 of file list\&.h\&.
.SH "Function Documentation"
.PP 
.SS "static int list_add (\fBlist_t\fP *list, \fBlistval_t\fPv)\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line 65 of file list\&.h\&.
.PP
References list::body, list::lock, list_body::next, list::size, and list_body::value\&.
.PP
.nf
65                                                       {
66     list_body_t* val = (list_body_t*) __list_malloc(sizeof(list_body_t));
67     if(!val)
68         return -1;
69         
70     __list_lock(&list->lock);
71         
72     val->value = v;
73     val->next = list->body;
74     
75     list->body = val;
76     list->size += 1;
77     
78     __list_unlock(&list->lock);
79     return 0;
80 }
.fi
.SS "static int list_clear (\fBlist_t\fP *list)\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line 108 of file list\&.h\&.
.PP
References list::body, list::lock, list_body::next, and list::size\&.
.PP
.nf
108                                            {
109     __list_lock(&list->lock);
110     
111     list_body_t* body = list->body;
112     list_body_t* tmp = list->body;
113     
114     while(body) {
115         tmp = body->next;
116         __list_free(body);
117         body = tmp;
118     }
119     
120     list->body = 0;
121     list->size = 0;
122     
123     __list_unlock(&list->lock);
124     return 0;
125 }
.fi
.SS "static void list_clone (\fBlist_t\fP *dest, \fBlist_t\fP *src)\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line 128 of file list\&.h\&.
.PP
References list::body, list_add(), list::lock, and list_body::next\&.
.PP
.nf
128                                                          {
129     __list_lock(&src->lock);
130     
131     for(list_body_t* i = src->body; i; i = i->next) {
132         list_add(dest, i->value);
133     }
134     
135     __list_unlock(&src->lock);
136 }
.fi
.SS "static int list_empty (\fBlist_t\fP *list)\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line 58 of file list\&.h\&.
.PP
References list::size\&.
.PP
.nf
58                                            {
59     if(list)
60         return list->size == 0;
61     else
62         return 1;   /* empty */
63 }
.fi
.SS "static \fBlistval_t\fP list_head (\fBlist_t\fP *list)\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line 165 of file list\&.h\&.
.PP
References list::body, list_body::next, and list_body::value\&.
.PP
.nf
165                                                 {
166 
167     if(!list->body)
168         return (listval_t) NULL;
169     
170     list_body_t* tmp = list->body;
171     while(tmp->next)
172         tmp = tmp->next;
173         
174     return (listval_t) tmp->value;
175 }
.fi
.SS "static \fBlistval_t\fP list_next (\fBlist_t\fP *list, \fBlistval_t\fPval)\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line 148 of file list\&.h\&.
.PP
References list::body, and list_body::next\&.
.PP
.nf
148                                                                {
149     for(list_body_t* i = list->body; i; i = i->next) {
150         if(i->next)
151             if(i->next->value == val)
152                 return i->value;
153     }
154     
155     return (listval_t) NULL;
156 }
.fi
.SS "static \fBlistval_t\fP list_prev (\fBlist_t\fP *list, \fBlistval_t\fPval)\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line 138 of file list\&.h\&.
.PP
References list::body, and list_body::next\&.
.PP
.nf
138                                                                {
139     for(list_body_t* i = list->body; i; i = i->next) {
140         if(i->value == val)
141             if(i->next)
142                 return i->next->value;
143     }
144     
145     return (listval_t) NULL;
146 }
.fi
.SS "static int list_remove (\fBlist_t\fP *list, \fBlistval_t\fPv)\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line 82 of file list\&.h\&.
.PP
References list::body, list::lock, list_body::next, and list_body::value\&.
.PP
.nf
82                                                          {
83     __list_lock(&list->lock);
84     
85     list_body_t* body = list->body;
86     list_body_t* prev = 0;
87     
88     while(body) {
89         if(body->value == v) {
90             if(prev)
91                 prev->next = body->next;
92             else
93                 list->body = body->next;
94                 
95             body->value = 0;
96             __list_free(body);
97             break;
98         }
99         
100         prev = body;
101         body = body->next;
102     }
103     
104     __list_unlock(&list->lock);
105     return 0;
106 }
.fi
.SS "static \fBlistval_t\fP list_tail (\fBlist_t\fP *list)\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line 158 of file list\&.h\&.
.PP
References list::body, and list_body::value\&.
.PP
.nf
158                                                 {
159     if(list->body)
160         return list->body->value;
161         
162     return (listval_t) NULL;
163 }
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for aPlus from the source code\&.
