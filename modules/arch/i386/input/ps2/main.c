#include <xdev.h>
#include <xdev/debug.h>
#include <xdev/module.h>
#include <xdev/vfs.h>
#include <xdev/intr.h>
#include <aplus/input.h>
#include <libc.h>

MODULE_NAME("i386/input/ps2");
MODULE_DEPS("");
MODULE_AUTHOR("Antonio Natale");
MODULE_LICENSE("GPL");


#if defined(__i386__)
#include <arch/i386/i386.h>


#define PS2_DATA		0x60
#define PS2_CTRL		0x64
#define PS2_ACK			0xFA
#define PS2_RESEND		0xFE



#define PS2_WAIT									\
	{												\
		int t = 100000;								\
		while((inb(PS2_CTRL) & 0x02) && t > 0)		\
			t--;									\
	}

#define PS2_WAIT_0									\
	{												\
		int t = 100000;								\
		while(!(inb(PS2_CTRL) & 0x01) && t > 0)		\
			t--;									\
	}






static mouse_t mouse;

static struct {
	uint8_t keymap[1024];
	uint8_t vkeys[256];
	uint8_t capslock;
	uint8_t numlock;
	uint8_t scorrlock;
	uint8_t e0;
} kb = {
	.keymap = {
		0x00, 0x1B, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
		0x27, 0xEC, 0x08, 0x09, 0x71, 0x77, 0x65, 0x72, 0x74, 0x79, 0x75, 0x69,
		0x6F, 0x70, 0xE8, 0x2B, '\n', 0x00, 0x61, 0x73, 0x64, 0x66, 0x67, 0x68,
		0x6A, 0x6B, 0x6C, 0xF2, 0xE0, 0x5C, 0x00, 0xF9, 0x7A, 0x78, 0x63, 0x76,
		0x62, 0x6E, 0x6D, 0x2C, 0x2E, 0x2D, 0x00, 0x2A, 0x00, 0x20, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 0x2B, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x21, 0x22, 0xA3, 0x24, 0x25, 0x26,
		0x2F, 0x28, 0x29, 0x3D, 0x3F, 0x5E, 0x08, 0x09, 0x51, 0x57, 0x45, 0x52,
		0x54, 0x59, 0x55, 0x49, 0x4F, 0x50, 0xE9, 0x2A, '\n', 0x00, 0x41, 0x53,
		0x44, 0x46, 0x47, 0x48, 0x4A, 0x4B, 0x4C, 0xE7, 0xB0, 0x7C, 0x00, 0xA7,
		0x5A, 0x58, 0x43, 0x56, 0x42, 0x4E, 0x4D, 0x3B, 0x3A, 0x5F, 0x00, 0x2A,
		0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 0x2B, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	}
};


static void __fifo_send(const char* dev, void* ptr, size_t size) {
	int fd = sys_open(dev, O_WRONLY, 0);
	if(fd < 0)
		return;
	
	sys_write(fd, ptr, size);
	sys_close(fd);
}


void kb_intr(void* unused) {
	if(!(inb(PS2_CTRL) & 0x01))
		return;

	uint8_t vkscan = inb(PS2_DATA);
	
	switch(vkscan) {
		case PS2_ACK:
		case PS2_RESEND:
			return;
		case 0xE0:
		case 0xE1:
			kb.e0++;
			return;
		default:
			break;
	}


	switch(vkscan) {
		case VK_CAPSLOCK:
			kb.capslock != kb.capslock;
			goto setled;
		case VK_NUMLOCK:
			kb.numlock != kb.numlock;
			goto setled;
		case VK_SCORRLOCK:
			kb.scorrlock != kb.scorrlock;
			goto setled;
		default:
			if(vkscan & 0x80)
				break;


			int off = 0;
			if((kb.vkeys[VK_LSHIFT] || kb.vkeys[VK_RSHIFT]) && kb.vkeys[VK_RALT])
				off = 768;
			else if(kb.vkeys[VK_RALT])
				off = 512;
			else if(kb.vkeys[VK_LSHIFT] || kb.vkeys[VK_RSHIFT])
				off = 256;
	
			if(kb.keymap[vkscan + off])
				__fifo_send(KBD_DEVICE, &kb.keymap[vkscan + off], 1);
			
	}



	kb.vkeys[(vkscan & 0x7F) + (kb.e0 ? 128 : 0)] = !!!(vkscan & 0x80);
	kb.e0 = 0;
	return;
	PS2_WAIT;
	return;

setled:
	PS2_WAIT;
	outb(PS2_DATA, 0xED);


	PS2_WAIT;
	outb (
		PS2_DATA,
	
		(kb.scorrlock ? (1 << 0) : 0)	|
		(kb.numlock ? (1 << 1) : 0) 	|
		(kb.capslock ? (1 << 2) : 0)
	);
	
	PS2_WAIT;
	return;
}


void mouse_intr(void* unused) {
	int s, j;
	s = inb(PS2_CTRL);

	while((s & 0x01)) {
		j = inb(PS2_DATA);
		
		if((s & 0x20)) {
	
			mouse.pack[mouse.cycle] = j;

			switch(mouse.cycle) {
				case 0:
					if(!(j & 0x08))
						return;

					mouse.cycle++;
					break;
				case 1:
				//case 2:
					mouse.cycle++;
					break;
				case 2:
					if(
						(mouse.pack[0] & 0x80) ||
						(mouse.pack[0] & 0x40)
					) break;
				
					mouse.dx = (mouse.pack[1] - ((mouse.pack[0] & 0x10) ? 256 : 0)) * mouse.speed;
					mouse.dy = (mouse.pack[2] - ((mouse.pack[0] & 0x20) ? 256 : 0)) * mouse.speed;

					//mouse.dz = mouse.pack[3];

					mouse.x += mouse.dx;
					mouse.y -= mouse.dy;
					
					/* TODO: Add clipping */
					
	
					mouse.buttons[0] = (mouse.pack[0] & 0x01);
					mouse.buttons[1] = (mouse.pack[0] & 0x02);
					mouse.buttons[2] = (mouse.pack[0] & 0x04);
					
					
					__fifo_send(MOUSE_DEVICE, &mouse, sizeof(mouse));
					
					mouse.cycle = 0;
					break;
			}
		}
	
		s = inb(PS2_CTRL);
	}
}



int init(void) {
	memset(&kb.vkeys, 0, sizeof(kb) - sizeof(kb.keymap));
	memset(&mouse, 0, sizeof(mouse));


	#define MOUSE_WRITE(x)		\
		PS2_WAIT;				\
		outb(PS2_CTRL, 0xD4);	\
		PS2_WAIT;				\
		outb(PS2_DATA, x)

	#define MOUSE_READ(x)		\
		PS2_WAIT_0;				\
		x = inb(PS2_DATA)


	PS2_WAIT;
	outb(PS2_CTRL, 0xA8);
	PS2_WAIT;
	outb(PS2_CTRL, 0x20);
	PS2_WAIT_0;
	
	int s = inb(PS2_DATA) | 2;
	PS2_WAIT;

	outb(PS2_CTRL, 0x60);
	PS2_WAIT;
	outb(PS2_DATA, s);



	MOUSE_WRITE(0xF6);
	MOUSE_READ(s);

#if 0
	MOUSE_WRITE(0xF3);
	MOUSE_READ(s);
	MOUSE_WRITE(200);
	MOUSE_READ(s);
	MOUSE_WRITE(0xF3);
	MOUSE_READ(s);
	MOUSE_WRITE(100);
	MOUSE_READ(s);
	MOUSE_WRITE(0xF3);
	MOUSE_READ(s);
	MOUSE_WRITE(80);
	MOUSE_READ(s);
	MOUSE_WRITE(0xF2);
	MOUSE_READ(s);
#endif

	MOUSE_WRITE(0xF4);
	MOUSE_READ(s);
	


	mouse.speed = 1;
	mouse.clip.left = 0;
	mouse.clip.top = 0;
	mouse.clip.right = 0xFFFF;
	mouse.clip.bottom = 0xFFFF;


	if(sys_mkfifo(KBD_DEVICE, 0777) != 0)
		kprintf(ERROR, "%s: cannot create FIFO device!\n", KBD_DEVICE);
		
	if(sys_mkfifo(MOUSE_DEVICE, 0777) != 0)
		kprintf(ERROR, "%s: cannot create FIFO device!\n", MOUSE_DEVICE);
		

	irq_enable(1, kb_intr);
	irq_enable(12, mouse_intr);


	return E_OK;
}


#else

int init(void) {
	return E_ERR;
}

#endif


int dnit(void) {
	return E_OK;
}
